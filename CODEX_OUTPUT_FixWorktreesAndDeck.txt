WHAT CHANGED
- Added one-shot automation scripts under scripts/dev/:
  - worktree-cleanup.ps1: robust repo-root detection from nested dirs, porcelain worktree parsing, main-worktree heuristics, safe non-main cleanup, lock-aware retries/remediation, non-interactive execution, and dry-run mode.
  - merge-main-take-theirs.ps1: fetch + merge origin/main into target branch, conflict handling with explicit -TakeTheirsPaths policy only, commit/push flow, and non-interactive execution.
  - gh-pr-automerge.ps1: auto-merge mergeable Codex PRs when gh exists/authenticated; fallback command block if not.
  - scripts/dev/README.md: concise runbook + one-liners.
- Deck smoke determinism tightened further:
  - Added failure-only screenshot capture in tests/e2e/deck-smoke-00-04.e2e.spec.ts.
  - Enabled Playwright failure artifacts (screenshot: only-on-failure, trace: retain-on-failure) in tests/e2e/deck.playwright.config.ts.
- Verified deterministic deck contract in code:
  - slide-00-root exists in components/slides/Slide00.tsx.
  - Slide roots used by smoke test are aligned to actual wrappers (slide02-root, slide03-root, s04-root).
  - Nav contract exists (nav-prev, nav-next, nav-jump-*, nav-current-index, nav-current-id) in App.tsx.
- Workflow doc requirement satisfied by verification:
  - docs/workflow/DECK_MULTI_AGENT_STANDARD.md already exists and was preserved unchanged.

FILES CREATED
- scripts/dev/worktree-cleanup.ps1
- scripts/dev/merge-main-take-theirs.ps1
- scripts/dev/gh-pr-automerge.ps1
- scripts/dev/README.md
- CODEX_OUTPUT_FixWorktreesAndDeck.txt

FILES MODIFIED
- tests/e2e/deck-smoke-00-04.e2e.spec.ts
- tests/e2e/deck.playwright.config.ts

DELETION_REQUESTS
- None.

RENAMES
- None.

OUT_OF_SCOPE_EDITS
- None.

TESTS ADDED / MODIFIED
- MODIFIED: tests/e2e/deck-smoke-00-04.e2e.spec.ts
  - Added failure-only screenshot capture before diagnostics dump.
- MODIFIED: tests/e2e/deck.playwright.config.ts
  - Added failure-only diagnostics artifact settings.

COMMAND LOGS (exact commands + pass/fail)
1) powershell -ExecutionPolicy Bypass -File ..\..\scripts\dev\worktree-cleanup.ps1 -DryRun
- Workdir: components/slides
- Result: FAIL (initial)
- Error: Windows PowerShell 5.1 rejected #requires -Version 7.0.

2) powershell -ExecutionPolicy Bypass -File ..\..\scripts\dev\worktree-cleanup.ps1 -DryRun
- Workdir: components/slides
- Result: FAIL (intermediate)
- Error: call depth overflow due to Git function recursion (& git @Args resolving to function).

3) powershell -ExecutionPolicy Bypass -File ..\..\scripts\dev\worktree-cleanup.ps1 -DryRun
- Workdir: components/slides
- Result: PASS
- Notes: repo root resolved from nested dir; main worktree identified; non-main entries planned for safe remove/metadata cleanup; lock-safe delete path printed.

4) powershell -ExecutionPolicy Bypass -File ..\..\scripts\dev\merge-main-take-theirs.ps1 -DryRun -TakeTheirsPaths "tests/e2e/deck-smoke-00-04.e2e.spec.ts","components/slides/Slide00.tsx"
- Workdir: tests/e2e
- Result: FAIL (initial)
- Error: script blocked on dirty worktree.

5) powershell -ExecutionPolicy Bypass -File ..\..\scripts\dev\merge-main-take-theirs.ps1 -DryRun -TakeTheirsPaths "tests/e2e/deck-smoke-00-04.e2e.spec.ts","components/slides/Slide00.tsx"
- Workdir: tests/e2e
- Result: PASS
- Notes: dirty state tolerated in dry-run only; printed fetch/merge/push simulation.

6) powershell -ExecutionPolicy Bypass -File .\scripts\dev\gh-pr-automerge.ps1 -DryRun
- Workdir: repo root
- Result: PASS
- Notes: gh not installed; printed single fallback command block.

7) npm run typecheck
- Result: PASS
- Output: tsc -p tsconfig.verify.json --noEmit.

8) npm run build
- Result: PASS
- Output highlights: client-boundary PASS, no-rework PASS, vite build PASS.

9) npx playwright test -c tests/e2e/deck.playwright.config.ts
- Result: PASS
- Output: 1 passed (tests/e2e/deck-smoke-00-04.e2e.spec.ts).

10) Test-Path docs\workflow\DECK_MULTI_AGENT_STANDARD.md
- Result: PASS (True)
- Notes: file exists; preserved unchanged.

DIFFS (full diff)
diff --git a/tests/e2e/deck-smoke-00-04.e2e.spec.ts b/tests/e2e/deck-smoke-00-04.e2e.spec.ts
index 56ec179..f2f83bc 100644
--- a/tests/e2e/deck-smoke-00-04.e2e.spec.ts
+++ b/tests/e2e/deck-smoke-00-04.e2e.spec.ts
@@ -29,6 +29,12 @@ test("deck nav smoke: Slide00 to Slide04 and back to Slide03", async ({ page })
     try {
       await expect(page.getByTestId(rootTestId)).toBeVisible({ timeout: 20000 });
     } catch (error) {
+      await page
+        .screenshot({
+          path: `test-results/deck-smoke-root-failure-${rootTestId}.png`,
+          fullPage: true,
+        })
+        .catch(() => undefined);
       await printDiagnosticsOnFailure(rootTestId);
       throw error;
     }
diff --git a/tests/e2e/deck.playwright.config.ts b/tests/e2e/deck.playwright.config.ts
index 4b3c0e2..b1fec42 100644
--- a/tests/e2e/deck.playwright.config.ts
+++ b/tests/e2e/deck.playwright.config.ts
@@ -11,6 +11,8 @@ export default defineConfig({
   use: {
     baseURL: "http://127.0.0.1:3290",
     headless: true,
+    screenshot: "only-on-failure",
+    trace: "retain-on-failure",
   },
   webServer: {
     command: "node ./node_modules/vite/bin/vite.js --host 127.0.0.1 --port 3290 --strictPort",
diff --git a/scripts/dev/worktree-cleanup.ps1 b/scripts/dev/worktree-cleanup.ps1
new file mode 100644
index 0000000..f2c62f6
--- /dev/null
+++ b/scripts/dev/worktree-cleanup.ps1
@@ -0,0 +1,328 @@
+[CmdletBinding()]
+param(
+  [switch]$DryRun,
+  [int]$RetryCount = 3,
+  [int]$RetryDelaySeconds = 2
+)
+
+Set-StrictMode -Version Latest
+$ErrorActionPreference = "Stop"
+
+function Write-Step {
+  param(
+    [Parameter(Mandatory)][string]$Message,
+    [ConsoleColor]$Color = [ConsoleColor]::Cyan
+  )
+
+  Write-Host $Message -ForegroundColor $Color
+}
+
+function Git {
+  param([Parameter(ValueFromRemainingArguments = $true)][string[]]$Args)
+  & git.exe @Args 2>&1
+}
+
+function Format-Args {
+  param([Parameter(Mandatory)][string[]]$Args)
+
+  return ($Args | ForEach-Object {
+      if ($_ -match "\s") { '"{0}"' -f $_ } else { $_ }
+    }) -join " "
+}
+
+function Invoke-Git {
+  param(
+    [Parameter(Mandatory)][string[]]$Args,
+    [switch]$AllowFailure
+  )
+
+  $display = "git {0}" -f (Format-Args -Args $Args)
+  $isMutating = $false
+  if ($Args -contains "worktree" -and ($Args -contains "remove" -or $Args -contains "prune")) {
+    $isMutating = $true
+  }
+
+  if ($DryRun -and $isMutating) {
+    Write-Host ("[DRYRUN] {0}" -f $display) -ForegroundColor DarkGray
+    return [pscustomobject]@{
+      ExitCode = 0
+      Lines    = @()
+      Text     = ""
+      Display  = $display
+    }
+  }
+
+  $lines = @(Git @Args)
+  $exitCode = $LASTEXITCODE
+  if (-not $AllowFailure -and $exitCode -ne 0) {
+    throw ("Command failed ({0}): {1}`n{2}" -f $exitCode, $display, ($lines -join "`n"))
+  }
+
+  return [pscustomobject]@{
+    ExitCode = $exitCode
+    Lines    = $lines
+    Text     = $lines -join "`n"
+    Display  = $display
+  }
+}
+
+function Normalize-PathKey {
+  param([Parameter(Mandatory)][string]$PathText)
+
+  try {
+    return ([System.IO.Path]::GetFullPath($PathText)).TrimEnd("\").ToLowerInvariant()
+  }
+  catch {
+    return $PathText.TrimEnd("\").ToLowerInvariant()
+  }
+}
+
+function Resolve-RepoRoot {
+  param([Parameter(Mandatory)][string]$StartPath)
+
+  $seedPaths = @($StartPath, $PSScriptRoot) | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique
+  foreach ($seed in $seedPaths) {
+    $cursor = $seed
+    while (-not [string]::IsNullOrWhiteSpace($cursor)) {
+      $probe = Invoke-Git -Args @("-C", $cursor, "rev-parse", "--show-toplevel") -AllowFailure
+      if ($probe.ExitCode -eq 0 -and -not [string]::IsNullOrWhiteSpace($probe.Text.Trim())) {
+        return (Resolve-Path -LiteralPath $probe.Text.Trim()).Path
+      }
+
+      $parent = Split-Path -Parent $cursor
+      if ([string]::IsNullOrWhiteSpace($parent) -or $parent -eq $cursor) {
+        break
+      }
+      $cursor = $parent
+    }
+  }
+
+  throw "Unable to locate repository root from current directory or script directory."
+}
+
+function Get-WorktreeEntries {
+  param([Parameter(Mandatory)][string]$RepoRoot)
+
+  $res = Invoke-Git -Args @("-C", $RepoRoot, "worktree", "list", "--porcelain")
+  $items = New-Object System.Collections.Generic.List[object]
+  $current = [ordered]@{}
+  $lines = @($res.Text -split "`r?`n")
+  $lines += ""
+
+  foreach ($raw in $lines) {
+    $line = $raw.TrimEnd()
+    if ([string]::IsNullOrWhiteSpace($line)) {
+      if ($current.Contains("Path")) {
+        $items.Add([pscustomobject]@{
+            Path      = $current.Path
+            PathKey   = Normalize-PathKey -PathText $current.Path
+            BranchRef = if ($current.Contains("BranchRef")) { $current.BranchRef } else { $null }
+            Branch    = if ($current.Contains("Branch")) { $current.Branch } else { $null }
+            Detached  = [bool]($current.Contains("Detached") -and $current.Detached)
+            Bare      = [bool]($current.Contains("Bare") -and $current.Bare)
+          })
+      }
+      $current = [ordered]@{}
+      continue
+    }
+
+    if ($line -match "^worktree (.+)$") {
+      $pathText = $Matches[1]
+      try {
+        $pathText = (Resolve-Path -LiteralPath $pathText -ErrorAction Stop).Path
+      }
+      catch {
+        $pathText = [System.IO.Path]::GetFullPath($pathText)
+      }
+      $current.Path = $pathText.TrimEnd("\")
+      continue
+    }
+
+    if ($line -match "^branch (.+)$") {
+      $branchRef = $Matches[1]
+      $current.BranchRef = $branchRef
+      if ($branchRef -match "^refs/heads/(.+)$") {
+        $current.Branch = $Matches[1]
+      }
+      else {
+        $current.Branch = $branchRef
+      }
+      continue
+    }
+
+    if ($line -eq "detached") {
+      $current.Detached = $true
+      continue
+    }
+
+    if ($line -eq "bare") {
+      $current.Bare = $true
+      continue
+    }
+  }
+
+  return $items
+}
+
+function Select-MainWorktree {
+  param(
+    [Parameter(Mandatory)][object[]]$Entries,
+    [Parameter(Mandatory)][string]$RepoRoot
+  )
+
+  $repoRootKey = Normalize-PathKey -PathText $RepoRoot
+  $mainCandidates = @($Entries | Where-Object { $_.Branch -eq "main" })
+  if ($mainCandidates.Count -gt 0) {
+    $exactRepo = $mainCandidates | Where-Object { $_.PathKey -eq $repoRootKey } | Select-Object -First 1
+    if ($null -ne $exactRepo) { return $exactRepo }
+    return ($mainCandidates | Sort-Object { $_.Path.Length } | Select-Object -First 1)
+  }
+
+  $rootCandidate = $Entries | Where-Object { $_.PathKey -eq $repoRootKey } | Select-Object -First 1
+  if ($null -ne $rootCandidate) { return $rootCandidate }
+
+  $gitDirCandidate = $Entries | Where-Object { Test-Path -LiteralPath (Join-Path $_.Path ".git") -PathType Container } | Select-Object -First 1
+  if ($null -ne $gitDirCandidate) { return $gitDirCandidate }
+
+  return ($Entries | Sort-Object { $_.Path.Length } | Select-Object -First 1)
+}
+
+function Remove-DirectoryWithRetry {
+  param(
+    [Parameter(Mandatory)][string]$PathToRemove
+  )
+
+  if (-not (Test-Path -LiteralPath $PathToRemove -PathType Container)) {
+    return $true
+  }
+
+  for ($attempt = 1; $attempt -le $RetryCount; $attempt++) {
+    try {
+      if ($DryRun) {
+        Write-Host ("[DRYRUN] Remove-Item -LiteralPath '{0}' -Recurse -Force" -f $PathToRemove) -ForegroundColor DarkGray
+        return $true
+      }
+
+      Remove-Item -LiteralPath $PathToRemove -Recurse -Force -ErrorAction Stop
+      return $true
+    }
+    catch {
+      if ($attempt -lt $RetryCount) {
+        Write-Host ("Retry {0}/{1} while removing '{2}': {3}" -f $attempt, $RetryCount, $PathToRemove, $_.Exception.Message) -ForegroundColor Yellow
+        Start-Sleep -Seconds $RetryDelaySeconds
+      }
+      else {
+        Write-Host ("Failed to remove '{0}' after {1} attempts." -f $PathToRemove, $RetryCount) -ForegroundColor Red
+        Write-Host "Remediation:" -ForegroundColor Yellow
+        Write-Host ("  1) Close VS Code / Explorer windows using: {0}" -f $PathToRemove) -ForegroundColor Yellow
+        Write-Host "  2) Retry this same script command." -ForegroundColor Yellow
+        $handle = Get-Command handle.exe -ErrorAction SilentlyContinue
+        if ($null -ne $handle) {
+          Write-Host ("  3) Optional lock probe: handle.exe ""{0}""" -f $PathToRemove) -ForegroundColor Yellow
+        }
+        return $false
+      }
+    }
+  }
+
+  return $false
+}
+
+$repoRoot = Resolve-RepoRoot -StartPath (Get-Location).Path
+Set-Location -LiteralPath $repoRoot
+
+Write-Step -Message ("Repository root: {0}" -f $repoRoot)
+
+$entries = @(Get-WorktreeEntries -RepoRoot $repoRoot)
+if ($entries.Count -eq 0) {
+  throw "git worktree list returned no entries."
+}
+
+$mainWorktree = Select-MainWorktree -Entries $entries -RepoRoot $repoRoot
+if ($null -eq $mainWorktree) {
+  throw "Unable to determine main worktree."
+}
+
+Write-Step -Message ("Main worktree: {0}" -f $mainWorktree.Path) -Color Green
+
+$removed = New-Object System.Collections.Generic.List[string]
+$metadataOnly = New-Object System.Collections.Generic.List[string]
+$skipped = New-Object System.Collections.Generic.List[string]
+$failed = New-Object System.Collections.Generic.List[string]
+
+$total = $entries.Count
+$index = 0
+foreach ($entry in $entries) {
+  $index++
+  $percent = [int](($index / [Math]::Max(1, $total)) * 100)
+  Write-Progress -Activity "Cleaning git worktrees" -Status ("{0}" -f $entry.Path) -PercentComplete $percent
+
+  if ($entry.PathKey -eq $mainWorktree.PathKey) {
+    $skipped.Add($entry.Path)
+    continue
+  }
+
+  $gitMarker = Join-Path $entry.Path ".git"
+  $isGitFile = Test-Path -LiteralPath $gitMarker -PathType Leaf
+  $isGitDir = Test-Path -LiteralPath $gitMarker -PathType Container
+  $pathExists = Test-Path -LiteralPath $entry.Path -PathType Container
+
+  if ($pathExists -and $isGitDir -and -not $isGitFile) {
+    Write-Host ("Skipping unsafe directory (looks like full repo): {0}" -f $entry.Path) -ForegroundColor Yellow
+    $skipped.Add($entry.Path)
+    continue
+  }
+
+  Write-Step -Message ("Removing worktree: {0}" -f $entry.Path) -Color DarkYellow
+  $removeResult = Invoke-Git -Args @("-C", $repoRoot, "worktree", "remove", "--force", $entry.Path) -AllowFailure
+  if ($removeResult.ExitCode -ne 0) {
+    Write-Host ("git worktree remove returned exit {0} for {1}" -f $removeResult.ExitCode, $entry.Path) -ForegroundColor Yellow
+    $failed.Add($entry.Path)
+    continue
+  }
+
+  if ($pathExists -and -not $isGitFile) {
+    Write-Host ("Metadata removed, but directory was not deleted (missing worktree .git file): {0}" -f $entry.Path) -ForegroundColor Yellow
+    $metadataOnly.Add($entry.Path)
+    continue
+  }
+
+  $deleteSuccess = Remove-DirectoryWithRetry -PathToRemove $entry.Path
+  if ($deleteSuccess) {
+    $removed.Add($entry.Path)
+  }
+  else {
+    $failed.Add($entry.Path)
+  }
+}
+
+Write-Progress -Activity "Cleaning git worktrees" -Completed
+
+Write-Step -Message "Pruning stale worktree metadata..." -Color Cyan
+[void](Invoke-Git -Args @("-C", $repoRoot, "worktree", "prune") -AllowFailure)
+
+Write-Step -Message "Final worktree list:" -Color Cyan
+$finalList = Invoke-Git -Args @("-C", $repoRoot, "worktree", "list") -AllowFailure
+foreach ($line in $finalList.Lines) {
+  if (-not [string]::IsNullOrWhiteSpace($line)) {
+    Write-Host ("  {0}" -f $line) -ForegroundColor Gray
+  }
+}
+
+Write-Step -Message ("Removed: {0}" -f $removed.Count) -Color Green
+foreach ($item in $removed) { Write-Host ("  - {0}" -f $item) -ForegroundColor Green }
+
+Write-Step -Message ("Metadata-only removals: {0}" -f $metadataOnly.Count) -Color Yellow
+foreach ($item in $metadataOnly) { Write-Host ("  - {0}" -f $item) -ForegroundColor Yellow }
+
+Write-Step -Message ("Skipped: {0}" -f $skipped.Count) -Color Yellow
+foreach ($item in $skipped) { Write-Host ("  - {0}" -f $item) -ForegroundColor Yellow }
+
+if ($failed.Count -gt 0) {
+  Write-Step -Message ("Failed removals: {0}" -f $failed.Count) -Color Red
+  foreach ($item in $failed) { Write-Host ("  - {0}" -f $item) -ForegroundColor Red }
+  exit 1
+}
+
+Write-Step -Message "Worktree cleanup completed." -Color Green
+exit 0
diff --git a/scripts/dev/merge-main-take-theirs.ps1 b/scripts/dev/merge-main-take-theirs.ps1
new file mode 100644
index 0000000..9a2b45a
--- /dev/null
+++ b/scripts/dev/merge-main-take-theirs.ps1
@@ -0,0 +1,214 @@
+[CmdletBinding()]
+param(
+  [string]$TargetBranch = "",
+  [string]$Remote = "origin",
+  [string]$MainBranch = "main",
+  [string[]]$TakeTheirsPaths = @(),
+  [switch]$DryRun
+)
+
+Set-StrictMode -Version Latest
+$ErrorActionPreference = "Stop"
+
+function Write-Step {
+  param(
+    [Parameter(Mandatory)][string]$Message,
+    [ConsoleColor]$Color = [ConsoleColor]::Cyan
+  )
+
+  Write-Host $Message -ForegroundColor $Color
+}
+
+function Git {
+  param([Parameter(ValueFromRemainingArguments = $true)][string[]]$Args)
+  & git.exe @Args 2>&1
+}
+
+function Format-Args {
+  param([Parameter(Mandatory)][string[]]$Args)
+  return ($Args | ForEach-Object {
+      if ($_ -match "\s") { '"{0}"' -f $_ } else { $_ }
+    }) -join " "
+}
+
+function Invoke-Git {
+  param(
+    [Parameter(Mandatory)][string[]]$Args,
+    [switch]$AllowFailure
+  )
+
+  $display = "git {0}" -f (Format-Args -Args $Args)
+  $mutatingTokens = @("checkout", "fetch", "merge", "commit", "push", "add", "reset", "rebase", "cherry-pick")
+  $isMutating = $false
+  foreach ($token in $mutatingTokens) {
+    if ($Args -contains $token) {
+      $isMutating = $true
+      break
+    }
+  }
+
+  if ($DryRun -and $isMutating) {
+    Write-Host ("[DRYRUN] {0}" -f $display) -ForegroundColor DarkGray
+    return [pscustomobject]@{
+      ExitCode = 0
+      Lines    = @()
+      Text     = ""
+      Display  = $display
+    }
+  }
+
+  $lines = @(Git @Args)
+  $exitCode = $LASTEXITCODE
+  if (-not $AllowFailure -and $exitCode -ne 0) {
+    throw ("Command failed ({0}): {1}`n{2}" -f $exitCode, $display, ($lines -join "`n"))
+  }
+
+  return [pscustomobject]@{
+    ExitCode = $exitCode
+    Lines    = $lines
+    Text     = $lines -join "`n"
+    Display  = $display
+  }
+}
+
+function Resolve-RepoRoot {
+  param([Parameter(Mandatory)][string]$StartPath)
+
+  $seedPaths = @($StartPath, $PSScriptRoot) | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique
+  foreach ($seed in $seedPaths) {
+    $cursor = $seed
+    while (-not [string]::IsNullOrWhiteSpace($cursor)) {
+      $probe = Invoke-Git -Args @("-C", $cursor, "rev-parse", "--show-toplevel") -AllowFailure
+      if ($probe.ExitCode -eq 0 -and -not [string]::IsNullOrWhiteSpace($probe.Text.Trim())) {
+        return (Resolve-Path -LiteralPath $probe.Text.Trim()).Path
+      }
+
+      $parent = Split-Path -Parent $cursor
+      if ([string]::IsNullOrWhiteSpace($parent) -or $parent -eq $cursor) {
+        break
+      }
+      $cursor = $parent
+    }
+  }
+
+  throw "Unable to locate repository root from current directory or script directory."
+}
+
+function Normalize-RepoPath {
+  param([Parameter(Mandatory)][string]$PathText)
+  return $PathText.Replace("\", "/").Trim()
+}
+
+function Test-MatchesTakeTheirs {
+  param(
+    [Parameter(Mandatory)][string]$FilePath,
+    [Parameter(Mandatory)][string[]]$Patterns
+  )
+
+  $normalizedFile = Normalize-RepoPath -PathText $FilePath
+  foreach ($pattern in $Patterns) {
+    if ([string]::IsNullOrWhiteSpace($pattern)) {
+      continue
+    }
+
+    $normalizedPattern = Normalize-RepoPath -PathText $pattern
+    if ($normalizedFile -eq $normalizedPattern -or $normalizedFile -like $normalizedPattern) {
+      return $true
+    }
+  }
+
+  return $false
+}
+
+$repoRoot = Resolve-RepoRoot -StartPath (Get-Location).Path
+Set-Location -LiteralPath $repoRoot
+Write-Step -Message ("Repository root: {0}" -f $repoRoot)
+
+$currentBranchRes = Invoke-Git -Args @("-C", $repoRoot, "rev-parse", "--abbrev-ref", "HEAD")
+$currentBranch = $currentBranchRes.Text.Trim()
+if ([string]::IsNullOrWhiteSpace($currentBranch) -or $currentBranch -eq "HEAD") {
+  throw "Current checkout is detached. Provide -TargetBranch explicitly."
+}
+
+if ([string]::IsNullOrWhiteSpace($TargetBranch)) {
+  $TargetBranch = $currentBranch
+}
+
+Write-Step -Message ("Target branch: {0}" -f $TargetBranch) -Color Green
+if ($TakeTheirsPaths.Count -eq 0) {
+  Write-Host "Take-theirs list is empty. Only clean merges (or conflicts resolved manually) will proceed." -ForegroundColor Yellow
+}
+
+$dirty = Invoke-Git -Args @("-C", $repoRoot, "status", "--porcelain")
+if (-not [string]::IsNullOrWhiteSpace($dirty.Text)) {
+  if ($DryRun) {
+    Write-Host "Working tree is not clean. Continuing because -DryRun is active." -ForegroundColor Yellow
+  }
+  else {
+    throw "Working tree is not clean. Commit/stash changes before running this script."
+  }
+}
+
+Write-Progress -Activity "Merge from main" -Status "Checkout target branch" -PercentComplete 10
+if ($currentBranch -ne $TargetBranch) {
+  [void](Invoke-Git -Args @("-C", $repoRoot, "checkout", $TargetBranch))
+}
+
+Write-Progress -Activity "Merge from main" -Status "Fetch main from origin" -PercentComplete 30
+[void](Invoke-Git -Args @("-C", $repoRoot, "fetch", $Remote, $MainBranch, "--prune"))
+
+$mergeRef = "{0}/{1}" -f $Remote, $MainBranch
+Write-Progress -Activity "Merge from main" -Status ("Merging {0}" -f $mergeRef) -PercentComplete 50
+$mergeResult = Invoke-Git -Args @("-C", $repoRoot, "merge", "--no-ff", "--no-edit", $mergeRef) -AllowFailure
+
+$resolvedWithTheirs = New-Object System.Collections.Generic.List[string]
+if ($mergeResult.ExitCode -ne 0) {
+  Write-Host "Merge reported conflicts. Applying take-theirs policy for configured files." -ForegroundColor Yellow
+  $conflictsRes = Invoke-Git -Args @("-C", $repoRoot, "diff", "--name-only", "--diff-filter=U") -AllowFailure
+  $conflicts = @($conflictsRes.Lines | Where-Object { -not [string]::IsNullOrWhiteSpace($_) })
+  if ($conflicts.Count -eq 0) {
+    throw ("Merge failed without conflict file list. Output:`n{0}" -f $mergeResult.Text)
+  }
+
+  $unresolved = New-Object System.Collections.Generic.List[string]
+  foreach ($file in $conflicts) {
+    if (Test-MatchesTakeTheirs -FilePath $file -Patterns $TakeTheirsPaths) {
+      Write-Host ("Taking THEIRS for: {0}" -f $file) -ForegroundColor DarkYellow
+      [void](Invoke-Git -Args @("-C", $repoRoot, "checkout", "--theirs", "--", $file))
+      [void](Invoke-Git -Args @("-C", $repoRoot, "add", "--", $file))
+      $resolvedWithTheirs.Add($file)
+    }
+    else {
+      $unresolved.Add($file)
+    }
+  }
+
+  $remainingRes = Invoke-Git -Args @("-C", $repoRoot, "diff", "--name-only", "--diff-filter=U") -AllowFailure
+  $remaining = @($remainingRes.Lines | Where-Object { -not [string]::IsNullOrWhiteSpace($_) })
+  if ($remaining.Count -gt 0 -or $unresolved.Count -gt 0) {
+    [void](Invoke-Git -Args @("-C", $repoRoot, "merge", "--abort") -AllowFailure)
+    $allUnresolved = @($remaining + $unresolved) | Select-Object -Unique
+    throw ("Unresolved conflicts remain. Merge aborted.`n{0}" -f ($allUnresolved -join "`n"))
+  }
+
+  if ($DryRun) {
+    Write-Host "[DRYRUN] Skipping merge commit after conflict resolution." -ForegroundColor DarkGray
+  }
+  else {
+    $message = "merge(main): {0} into {1} (take theirs: {2})" -f $mergeRef, $TargetBranch, ([Math]::Max(1, $resolvedWithTheirs.Count))
+    [void](Invoke-Git -Args @("-C", $repoRoot, "commit", "-m", $message))
+  }
+}
+
+Write-Progress -Activity "Merge from main" -Status "Push target branch" -PercentComplete 85
+[void](Invoke-Git -Args @("-C", $repoRoot, "push", $Remote, $TargetBranch))
+
+Write-Progress -Activity "Merge from main" -Completed
+Write-Step -Message "Merge flow completed." -Color Green
+if ($resolvedWithTheirs.Count -gt 0) {
+  Write-Step -Message "Files resolved with THEIRS:" -Color DarkYellow
+  foreach ($item in $resolvedWithTheirs) {
+    Write-Host ("  - {0}" -f $item) -ForegroundColor DarkYellow
+  }
+}
+exit 0
diff --git a/scripts/dev/gh-pr-automerge.ps1 b/scripts/dev/gh-pr-automerge.ps1
new file mode 100644
index 0000000..d54e047
--- /dev/null
+++ b/scripts/dev/gh-pr-automerge.ps1
@@ -0,0 +1,124 @@
+[CmdletBinding()]
+param(
+  [string]$BaseBranch = "main",
+  [string]$HeadPrefix = "codex-",
+  [switch]$DryRun
+)
+
+Set-StrictMode -Version Latest
+$ErrorActionPreference = "Stop"
+
+function Write-Step {
+  param(
+    [Parameter(Mandatory)][string]$Message,
+    [ConsoleColor]$Color = [ConsoleColor]::Cyan
+  )
+
+  Write-Host $Message -ForegroundColor $Color
+}
+
+function Resolve-RepoRoot {
+  param([Parameter(Mandatory)][string]$StartPath)
+
+  $cursor = $StartPath
+  while (-not [string]::IsNullOrWhiteSpace($cursor)) {
+    $probe = & git.exe -C $cursor rev-parse --show-toplevel 2>$null
+    if ($LASTEXITCODE -eq 0 -and -not [string]::IsNullOrWhiteSpace(($probe -join "`n").Trim())) {
+      return (Resolve-Path -LiteralPath (($probe -join "`n").Trim())).Path
+    }
+
+    $parent = Split-Path -Parent $cursor
+    if ([string]::IsNullOrWhiteSpace($parent) -or $parent -eq $cursor) {
+      break
+    }
+    $cursor = $parent
+  }
+
+  throw "Unable to locate repository root from current directory."
+}
+
+function Print-FallbackCommandBlock {
+  param(
+    [Parameter(Mandatory)][string]$BaseBranchParam,
+    [Parameter(Mandatory)][string]$HeadPrefixParam
+  )
+
+  Write-Host "Optional fallback command block:" -ForegroundColor Yellow
+  Write-Host @"
+`$states = @('CLEAN','HAS_HOOKS','UNSTABLE')
+gh auth status -h github.com
+gh pr list --state open --base $BaseBranchParam --json number,headRefName,mergeStateStatus,isDraft | ConvertFrom-Json |
+  Where-Object { -not `$_.isDraft -and `$_.headRefName -like '$HeadPrefixParam*' -and `$states -contains `$_.mergeStateStatus } |
+  ForEach-Object { gh pr merge `$_.number --merge --delete-branch }
+"@ -ForegroundColor DarkGray
+}
+
+$repoRoot = Resolve-RepoRoot -StartPath (Get-Location).Path
+Set-Location -LiteralPath $repoRoot
+Write-Step -Message ("Repository root: {0}" -f $repoRoot)
+
+$gh = Get-Command gh -ErrorAction SilentlyContinue
+if ($null -eq $gh) {
+  Write-Step -Message "GitHub CLI (gh) is not installed. Skipping auto-merge." -Color Yellow
+  Print-FallbackCommandBlock -BaseBranchParam $BaseBranch -HeadPrefixParam $HeadPrefix
+  exit 0
+}
+
+& gh auth status -h github.com *> $null
+if ($LASTEXITCODE -ne 0) {
+  Write-Step -Message "GitHub CLI is not authenticated. Skipping auto-merge." -Color Yellow
+  Print-FallbackCommandBlock -BaseBranchParam $BaseBranch -HeadPrefixParam $HeadPrefix
+  exit 0
+}
+
+$json = & gh pr list --state open --base $BaseBranch --json number,title,headRefName,mergeStateStatus,isDraft,url
+if ($LASTEXITCODE -ne 0) {
+  throw "Failed to list PRs via gh."
+}
+
+$prs = @()
+if (-not [string]::IsNullOrWhiteSpace($json)) {
+  $prs = @($json | ConvertFrom-Json)
+}
+
+$mergeableStates = @("CLEAN", "HAS_HOOKS", "UNSTABLE")
+$candidates = @(
+  $prs | Where-Object {
+    -not $_.isDraft -and
+    $_.headRefName -like ("{0}*" -f $HeadPrefix) -and
+    $mergeableStates -contains $_.mergeStateStatus
+  }
+)
+
+Write-Step -Message ("Open PRs found: {0}" -f $prs.Count)
+Write-Step -Message ("Mergeable candidates ({0}*): {1}" -f $HeadPrefix, $candidates.Count) -Color Green
+
+$merged = 0
+$skipped = 0
+$total = [Math]::Max(1, $candidates.Count)
+$i = 0
+foreach ($pr in $candidates) {
+  $i++
+  $percent = [int](($i / $total) * 100)
+  Write-Progress -Activity "Auto-merging PRs" -Status ("PR #{0} {1}" -f $pr.number, $pr.headRefName) -PercentComplete $percent
+
+  if ($DryRun) {
+    Write-Host ("[DRYRUN] gh pr merge {0} --merge --delete-branch" -f $pr.number) -ForegroundColor DarkGray
+    $merged++
+    continue
+  }
+
+  & gh pr merge $pr.number --merge --delete-branch
+  if ($LASTEXITCODE -eq 0) {
+    $merged++
+    Write-Host ("Merged PR #{0}: {1}" -f $pr.number, $pr.url) -ForegroundColor Green
+  }
+  else {
+    $skipped++
+    Write-Host ("Skipped PR #{0}: merge command failed." -f $pr.number) -ForegroundColor Yellow
+  }
+}
+
+Write-Progress -Activity "Auto-merging PRs" -Completed
+Write-Step -Message ("Merged: {0} | Skipped: {1}" -f $merged, $skipped) -Color Green
+exit 0
diff --git a/scripts/dev/README.md b/scripts/dev/README.md
new file mode 100644
index 0000000..77326eb
--- /dev/null
+++ b/scripts/dev/README.md
@@ -0,0 +1,22 @@
+# Dev One-Shot Scripts
+
+Run from repo root (or any subdirectory; scripts auto-detect repo root):
+
+```powershell
+powershell -ExecutionPolicy Bypass -File .\scripts\dev\worktree-cleanup.ps1
+powershell -ExecutionPolicy Bypass -File .\scripts\dev\merge-main-take-theirs.ps1 -TargetBranch codex-D-slide00 -TakeTheirsPaths "package-lock.json","tests/e2e/deck-smoke-00-04.e2e.spec.ts"
+powershell -ExecutionPolicy Bypass -File .\scripts\dev\gh-pr-automerge.ps1
+```
+
+Dry-run mode:
+
+```powershell
+powershell -ExecutionPolicy Bypass -File .\scripts\dev\worktree-cleanup.ps1 -DryRun
+powershell -ExecutionPolicy Bypass -File .\scripts\dev\merge-main-take-theirs.ps1 -DryRun
+powershell -ExecutionPolicy Bypass -File .\scripts\dev\gh-pr-automerge.ps1 -DryRun
+```
+
+Notes:
+- `worktree-cleanup.ps1` only removes paths reported by `git worktree list --porcelain` and never deletes arbitrary folders.
+- `merge-main-take-theirs.ps1` merges `origin/main`; on conflicts it takes `--theirs` only for files listed in `-TakeTheirsPaths`.
+- `gh-pr-automerge.ps1` auto-merges mergeable Codex PRs if `gh` is installed and authenticated; otherwise it prints a fallback command block.

FINAL SUMMARY
- Worktree cleanup scripts
  - Ready: YES
  - Status: one-shot, non-interactive, safe-by-list-only deletion, lock retry/remediation, nested-dir root detection.
- Merge-from-main script
  - Ready: YES
  - Status: one-shot, branch autodetect or explicit target, conflict handling via explicit -TakeTheirsPaths, commit/push flow, dry-run support.
- Deck smoke determinism
  - Ready: YES
  - Status: typecheck/build/e2e pass; deterministic root/nav assertions; failure-only screenshot + trace diagnostics active.
- Doc added
  - Ready: YES
  - Status: docs/workflow/DECK_MULTI_AGENT_STANDARD.md already present and verified; preserved unchanged.
