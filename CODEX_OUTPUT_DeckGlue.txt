INVERSION · CODEX AGENT · DECK GLUE / ROUTER & SLIDENAV STABILIZER · OUTPUT
Generated: 2026-02-10 16:30:04

WHAT CHANGED
- Deck now deep-links and syncs URL via /slides/00.. style paths with Slide00 default landing.
- Global deterministic SlideNav exists independently of slide internals with required testids.
- Slide00..Slide04 wrappers expose stable root testids.
- Smoke e2e validates Slide00→01→02→03→04 then Prev to 03.

FILES CREATED
- tests/e2e/deck-smoke-00-04.e2e.spec.ts
- tests/e2e/deck.playwright.config.ts

FILES MODIFIED
- App.tsx
- components/slides/Slide00.tsx
- components/slides/Slide01.tsx
- components/slides/Slide02.tsx
- components/slides/Slide03.tsx
- components/slides/Slide04.tsx

TESTS ADDED
- tests/e2e/deck-smoke-00-04.e2e.spec.ts

ASSUMPTIONS / TODO
- Existing pre-worktree untracked files (slide01 assets/docs/tests) were left untouched.
- Existing keyboard navigation behavior remains unchanged; deterministic deck controls are provided via global SlideNav.

COMMAND LOGS
--- npm run typecheck ---
> copy-of-hitech-rts-a---deck-v32@0.0.0 typecheck
> tsc -p tsconfig.verify.json --noEmit

--- npm run build ---
> copy-of-hitech-rts-a---deck-v32@0.0.0 build
> node scripts/client-boundary-guard.mjs --strict && node scripts/no-rework-guard.mjs && vite build

[client-boundary] PASS no client exposure findings
[client-boundary] report=F:\OneDrive\Hitech\3.Proyectos\CHAT GPT AI Estudio\repos\Inversion__codex-A__slide01-05\.run\client-boundary-guard.json
[no-rework] PASS
vite v6.4.1 building for production...
✓ 216 modules transformed.
✓ built in 3.44s
(!) Some chunks are larger than 500 kB after minification.

--- npx playwright test -c tests/e2e/deck.playwright.config.ts ---
Running 1 test using 1 worker

ok 1 tests\e2e\deck-smoke-00-04.e2e.spec.ts:3:1 › deck nav smoke: Slide00 to Slide04 and back to Slide03 (12.9s)

1 passed (16.8s)

--- e2e stabilization log ---
Previous isolated smoke startup attempts while stabilizing config:
- Error: Timed out waiting 120000ms from config.webServer.
- Error: http://127.0.0.1:3290 is already used, make sure that nothing is running on the port/url or set reuseExistingServer:true in config.webServer.
- Error: No tests found
Resolved by: strict isolated port update, webServer command normalization, stale process cleanup, and testDir fix.

DIFFS (EXACT)
```diff
diff --git a/App.tsx b/App.tsx
index a3a4030..3c6a827 100644
--- a/App.tsx
+++ b/App.tsx
@@ -120,6 +120,9 @@ const ControlBar = () => {
 };
 
 const TOTAL_SLIDES = 20;
+const DECK_NAV_START = 0;
+const DECK_NAV_END = 4;
+const DECK_NAV_INDICES = [0, 1, 2, 3, 4] as const;
 
 const normalizeSlideIndex = (idx: number) => {
   const n = TOTAL_SLIDES;
@@ -127,6 +130,43 @@ const normalizeSlideIndex = (idx: number) => {
   return ((Math.trunc(idx) % n) + n) % n;
 };
 
+const clampDeckNavIndex = (idx: number) => {
+  const normalized = normalizeSlideIndex(idx);
+  if (normalized < DECK_NAV_START) return DECK_NAV_START;
+  if (normalized > DECK_NAV_END) return DECK_NAV_END;
+  return normalized;
+};
+
+const formatSlideId = (idx: number) => String(normalizeSlideIndex(idx)).padStart(2, "0");
+
+const parseSlideIndexFromLocation = (locationLike: Pick<Location, "pathname" | "hash" | "search">): number => {
+  const pathMatch = locationLike.pathname.match(/^\/slides\/(\d{1,2})\/?$/i);
+  if (pathMatch) {
+    return normalizeSlideIndex(Number(pathMatch[1]));
+  }
+
+  const hashRaw = locationLike.hash.startsWith("#")
+    ? locationLike.hash.slice(1)
+    : locationLike.hash;
+  const hashMatch = hashRaw.match(/^(?:slides\/|slide\/|slide-)?(\d{1,2})$/i);
+  if (hashMatch) {
+    return normalizeSlideIndex(Number(hashMatch[1]));
+  }
+
+  const query = new URLSearchParams(locationLike.search);
+  const querySlide = query.get("slide");
+  if (querySlide != null && querySlide.trim() !== "") {
+    const parsed = Number(querySlide);
+    if (Number.isFinite(parsed)) {
+      return normalizeSlideIndex(parsed);
+    }
+  }
+
+  return 0;
+};
+
+const slidePathFromIndex = (idx: number) => `/slides/${formatSlideId(idx)}`;
+
 const ModePill: React.FC = () => {
   const { mode } = useDeckMode();
 
@@ -214,6 +254,64 @@ const DemoScriptOverlay: React.FC<{ currentSlide: number; enabled: boolean }> =
   );
 };
 
+const DeckSlideNav: React.FC<{
+  currentSlide: number;
+  canPrev: boolean;
+  canNext: boolean;
+  onPrev: () => void;
+  onNext: () => void;
+  onJump: (index: number) => void;
+}> = ({ currentSlide, canPrev, canNext, onPrev, onNext, onJump }) => {
+  const currentSlideId = formatSlideId(currentSlide);
+
+  return (
+    <aside className="pointer-events-auto fixed bottom-4 right-4 z-[2147483004] rounded-xl border border-white/25 bg-black/70 px-3 py-3 backdrop-blur-md">
+      <div className="mb-2 flex items-center gap-2">
+        <button
+          type="button"
+          data-testid="nav-prev"
+          onClick={onPrev}
+          disabled={!canPrev}
+          className="rounded border border-white/25 px-3 py-1 text-xs font-code tracking-[0.2em] text-white disabled:cursor-not-allowed disabled:opacity-45"
+        >
+          PREV
+        </button>
+        <button
+          type="button"
+          data-testid="nav-next"
+          onClick={onNext}
+          disabled={!canNext}
+          className="rounded border border-white/25 px-3 py-1 text-xs font-code tracking-[0.2em] text-white disabled:cursor-not-allowed disabled:opacity-45"
+        >
+          NEXT
+        </button>
+      </div>
+      <div className="mb-2 flex items-center gap-1">
+        {DECK_NAV_INDICES.map((index) => {
+          const id = formatSlideId(index);
+          return (
+            <button
+              key={id}
+              type="button"
+              data-testid={`nav-jump-${id}`}
+              onClick={() => onJump(index)}
+              className="rounded border border-white/20 px-2 py-1 text-[10px] font-code tracking-[0.2em] text-white/90"
+            >
+              {id}
+            </button>
+          );
+        })}
+      </div>
+      <div data-testid="nav-current-index" className="text-[10px] font-code tracking-[0.18em] text-white/70">
+        {formatSlideId(currentSlide)}
+      </div>
+      <div data-testid="nav-current-id" className="text-[10px] font-code tracking-[0.18em] text-white/55">
+        slide-{currentSlideId}
+      </div>
+    </aside>
+  );
+};
+
 const AppInner: React.FC<{
   currentSlide: number;
   setCurrentSlide: React.Dispatch<React.SetStateAction<number>>;
@@ -278,6 +376,21 @@ const AppInner: React.FC<{
     cancelMirror();
     setCurrentSlide(normalizeSlideIndex(index));
   }, [cancelMirror, setCurrentSlide]);
+  const deckNavIndex = clampDeckNavIndex(normalizedSlide);
+  const deckCanPrev = deckNavIndex > DECK_NAV_START;
+  const deckCanNext = deckNavIndex < DECK_NAV_END;
+  const goToDeckSlide = useCallback((index: number) => {
+    cancelMirror();
+    setCurrentSlide(clampDeckNavIndex(index));
+  }, [cancelMirror, setCurrentSlide]);
+  const deckPrev = useCallback(() => {
+    if (!deckCanPrev) return;
+    goToDeckSlide(deckNavIndex - 1);
+  }, [deckCanPrev, deckNavIndex, goToDeckSlide]);
+  const deckNext = useCallback(() => {
+    if (!deckCanNext) return;
+    goToDeckSlide(deckNavIndex + 1);
+  }, [deckCanNext, deckNavIndex, goToDeckSlide]);
 
   useEffect(() => {
     if (!WOW_DEMO || !WOW_MIRROR || !mirrorAvailable) {
@@ -482,6 +595,14 @@ const AppInner: React.FC<{
       <div data-testid="boot-feature-state" style={{ display: "none" }}>
         demoScriptAvailable:{String(demoScriptAvailable)}|demoScriptActive:{String(demoScriptActive)}|mirrorAvailable:{String(mirrorAvailable)}|mirrorActive:{String(mirrorActive)}
       </div>
+      <DeckSlideNav
+        currentSlide={deckNavIndex}
+        canPrev={deckCanPrev}
+        canNext={deckCanNext}
+        onPrev={deckPrev}
+        onNext={deckNext}
+        onJump={goToDeckSlide}
+      />
 
       <TopHudRow visible={viewVisibility.showTopHudRow}>
         <ModePill />
@@ -518,7 +639,12 @@ const AppInner: React.FC<{
 const WOW_FLAG_SNAPSHOT = createWowFlagSnapshot();
 
 export default function App() {
-  const [currentSlide, setCurrentSlide] = useState(0);
+  const [currentSlide, setCurrentSlide] = useState(() => {
+    if (typeof window === "undefined") {
+      return 0;
+    }
+    return parseSlideIndexFromLocation(window.location);
+  });
 
   const [modalOpen, setModalOpen] = useState(false);
   const [modalImages, setModalImages] = useState<string[]>([]);
@@ -533,6 +659,30 @@ export default function App() {
 
   const whitelist = useMemo(() => [4, 13], []);
 
+  useEffect(() => {
+    if (typeof window === "undefined") return;
+
+    const syncFromUrl = () => {
+      setCurrentSlide(parseSlideIndexFromLocation(window.location));
+    };
+
+    window.addEventListener("popstate", syncFromUrl);
+    window.addEventListener("hashchange", syncFromUrl);
+    return () => {
+      window.removeEventListener("popstate", syncFromUrl);
+      window.removeEventListener("hashchange", syncFromUrl);
+    };
+  }, []);
+
+  useEffect(() => {
+    if (typeof window === "undefined") return;
+
+    const nextPath = slidePathFromIndex(currentSlide);
+    if (window.location.pathname !== nextPath) {
+      window.history.replaceState(window.history.state, "", nextPath);
+    }
+  }, [currentSlide]);
+
   return (
     <BootRuntimeProvider wowFlags={WOW_FLAG_SNAPSHOT}>
       <Slide00ViewVisibilityProvider defaultOn={OPERATOR_VIEW_DEFAULT_ON}>
diff --git a/components/slides/Slide00.tsx b/components/slides/Slide00.tsx
index 993674e..0945577 100644
--- a/components/slides/Slide00.tsx
+++ b/components/slides/Slide00.tsx
@@ -383,149 +383,151 @@ export const Slide00: React.FC<Slide00Props> = ({ nextSlide, prevSlide }) => {
   const diagnosticsSurfaceVisible = viewVisibility.showDiagnostics && OPERATOR_DIAGNOSTICS;
 
   return (
-    <SlideContainer>
-      <Slide00Shell
-        nav={<NavArea prev={prevSlide} next={nextSlide} />}
-        toast={<BootToast open={showToast} detail={toastDetail} onDismiss={() => setShowToast(false)} />}
-        diagnostics={
-          diagnosticsSurfaceVisible ? (
-            <>
-              <DiagnosticsDockToggle
-                open={diagnosticsOpen}
-                onClick={() => setDiagnosticsOpen((prev) => !prev)}
-              />
-              <DiagnosticsDock
-                open={diagnosticsOpen}
-                compact={diagnosticsCompact}
-                onBack={() => setDiagnosticsOpen(false)}
-                onToggleMode={() => setDiagnosticsCompact((prev) => !prev)}
-                metaItems={diagnosticsMeta}
-                controlRows={diagnosticsControls}
-                satisfiedRows={boot.diagnostics.satisfiedEvidence}
-                missingRows={boot.diagnostics.missingBlockers}
-                logRows={diagnosticsLogRows}
-                footerCopy="local diagnostics only · does not alter evidence semantics"
-                footerTime={new Date().toLocaleString()}
-              />
-            </>
-          ) : null
-        }
-      >
-        <BootTopline
-          brandTitle="HITECH RTS"
-          brandSubtitle="boot / deterministic gate"
-          slideLabel="slide 00 · boot gate"
-        />
-
-        <Header
-          title="BOOT CONSOLE"
-          breadcrumb="ACTION / WHY / CONFIRM"
-          slideNum={1}
-          rightBadge={`STATE ${status}`}
-        />
-
-        <BootCenterLayout
-          main={
-            <BootPanel
-              header={
-                <BootPanelHeader
-                  title="Operator arming required"
-                  subtitle={
-                    <>
-                      This deck starts in manual mode. Scripted systems remain blocked until
-                      <strong> evidence:system:armed </strong>
-                      is satisfied by explicit operator action.
-                    </>
-                  }
-                  whyLabel="why: register verifiable activity"
+    <div data-testid="slide-00-root" className="w-full h-full">
+      <SlideContainer>
+        <Slide00Shell
+          nav={<NavArea prev={prevSlide} next={nextSlide} />}
+          toast={<BootToast open={showToast} detail={toastDetail} onDismiss={() => setShowToast(false)} />}
+          diagnostics={
+            diagnosticsSurfaceVisible ? (
+              <>
+                <DiagnosticsDockToggle
+                  open={diagnosticsOpen}
+                  onClick={() => setDiagnosticsOpen((prev) => !prev)}
                 />
-              }
-              body={
-                <BootPanelBody
-                  status={boot.state.boot.status}
-                  canArm={boot.canArm}
-                  canConfirm={canConfirm}
-                  showConfirm={showConfirmButton}
-                  confirmLabel={confirmLabel}
-                  onArm={armNow}
-                  onConfirm={confirmArm}
-                  confirmState={confirmSlot.state}
-                  confirmText={confirmSlot.text}
-                  confirmStrongText={confirmSlot.strongText}
-                  cards={kpiCards}
+                <DiagnosticsDock
+                  open={diagnosticsOpen}
+                  compact={diagnosticsCompact}
+                  onBack={() => setDiagnosticsOpen(false)}
+                  onToggleMode={() => setDiagnosticsCompact((prev) => !prev)}
+                  metaItems={diagnosticsMeta}
+                  controlRows={diagnosticsControls}
+                  satisfiedRows={boot.diagnostics.satisfiedEvidence}
+                  missingRows={boot.diagnostics.missingBlockers}
+                  logRows={diagnosticsLogRows}
+                  footerCopy="local diagnostics only · does not alter evidence semantics"
+                  footerTime={new Date().toLocaleString()}
                 />
-              }
-              footer={
-                <BootPanelFooter>
-                  <p className="slide00-arm-emphasis-copy">
-                    arm lane reserved for glow, glass and directional emphasis modules.
-                  </p>
-                </BootPanelFooter>
-              }
-            />
+              </>
+            ) : null
           }
-          side={
-            <BootSideColumn>
-              <BootStatusBadge
-                isArmed={boot.isArmed}
-                isOperatorAssisted={boot.isOperatorAssisted}
-                narrative={statusNarrative(boot.state.boot.status)}
-                lastEventLabel={lastEventLabel}
-              />
-
-              <OpeningFlagsBadge
-                summary={cinematicFlagSummary || "none"}
-                autostartReason={humanReason(boot.gates.tourAutostart.reason)}
-                warning={boot.gates.tourAutostart.reason === "autostart-disabled-by-boot-contract"}
+        >
+          <BootTopline
+            brandTitle="HITECH RTS"
+            brandSubtitle="boot / deterministic gate"
+            slideLabel="slide 00 · boot gate"
+          />
+
+          <Header
+            title="BOOT CONSOLE"
+            breadcrumb="ACTION / WHY / CONFIRM"
+            slideNum={1}
+            rightBadge={`STATE ${status}`}
+          />
+
+          <BootCenterLayout
+            main={
+              <BootPanel
+                header={
+                  <BootPanelHeader
+                    title="Operator arming required"
+                    subtitle={
+                      <>
+                        This deck starts in manual mode. Scripted systems remain blocked until
+                        <strong> evidence:system:armed </strong>
+                        is satisfied by explicit operator action.
+                      </>
+                    }
+                    whyLabel="why: register verifiable activity"
+                  />
+                }
+                body={
+                  <BootPanelBody
+                    status={boot.state.boot.status}
+                    canArm={boot.canArm}
+                    canConfirm={canConfirm}
+                    showConfirm={showConfirmButton}
+                    confirmLabel={confirmLabel}
+                    onArm={armNow}
+                    onConfirm={confirmArm}
+                    confirmState={confirmSlot.state}
+                    confirmText={confirmSlot.text}
+                    confirmStrongText={confirmSlot.strongText}
+                    cards={kpiCards}
+                  />
+                }
+                footer={
+                  <BootPanelFooter>
+                    <p className="slide00-arm-emphasis-copy">
+                      arm lane reserved for glow, glass and directional emphasis modules.
+                    </p>
+                  </BootPanelFooter>
+                }
               />
+            }
+            side={
+              <BootSideColumn>
+                <BootStatusBadge
+                  isArmed={boot.isArmed}
+                  isOperatorAssisted={boot.isOperatorAssisted}
+                  narrative={statusNarrative(boot.state.boot.status)}
+                  lastEventLabel={lastEventLabel}
+                />
 
-              <ViewControlsTogglePanel
-                showTopHudRow={viewVisibility.showTopHudRow}
-                showTopRibbon={viewVisibility.showTopRibbon}
-                showDiagnostics={viewVisibility.showDiagnostics}
-                onTopHudRowChange={viewVisibility.setShowTopHudRow}
-                onTopRibbonChange={viewVisibility.setShowTopRibbon}
-                onDiagnosticsChange={viewVisibility.setShowDiagnostics}
-              />
+                <OpeningFlagsBadge
+                  summary={cinematicFlagSummary || "none"}
+                  autostartReason={humanReason(boot.gates.tourAutostart.reason)}
+                  warning={boot.gates.tourAutostart.reason === "autostart-disabled-by-boot-contract"}
+                />
 
-              <PersistenceIndicator
-                persisted={persistence.hasSnapshot}
-                keyCount={persistence.keys.length}
-                keys={persistence.keys}
-              />
+                <ViewControlsTogglePanel
+                  showTopHudRow={viewVisibility.showTopHudRow}
+                  showTopRibbon={viewVisibility.showTopRibbon}
+                  showDiagnostics={viewVisibility.showDiagnostics}
+                  onTopHudRowChange={viewVisibility.setShowTopHudRow}
+                  onTopRibbonChange={viewVisibility.setShowTopRibbon}
+                  onDiagnosticsChange={viewVisibility.setShowDiagnostics}
+                />
 
-              <ResetControls onSoftReset={softReset} onHardReset={hardReset} />
+                <PersistenceIndicator
+                  persisted={persistence.hasSnapshot}
+                  keyCount={persistence.keys.length}
+                  keys={persistence.keys}
+                />
 
-              <GateMatrix rows={gateRows} humanReason={humanReason} />
-            </BootSideColumn>
-          }
-        />
-
-        <EvidenceList title="evidence blockers" rows={blockerRows} formatTimestamp={formatTimestamp} />
-
-        <BootFoot
-          left={`local time: ${formatDateTime(Date.now())}`}
-          right={`last anchor: ${boot.diagnostics.lastInteractedAnchor ?? "--"}`}
-        />
-
-        <BootNote warning={boot.isOperatorAssisted}>
-          override path can unlock progression for operator testing, but it never satisfies
-          <strong> evidence:system:armed</strong>.
-        </BootNote>
-
-        <BootNote danger={boot.gateLocked}>
-          when locked, WOW tour/demo-script/opening-cinema stay disabled regardless of flags.
-        </BootNote>
-
-        <Slide00HiddenState
-          bootStatus={boot.state.boot.status}
-          armedEvidence={
-            boot.state.evidence.entries["evidence:system:armed"].satisfied
-              ? "satisfied"
-              : "missing"
-          }
-        />
-      </Slide00Shell>
-    </SlideContainer>
+                <ResetControls onSoftReset={softReset} onHardReset={hardReset} />
+
+                <GateMatrix rows={gateRows} humanReason={humanReason} />
+              </BootSideColumn>
+            }
+          />
+
+          <EvidenceList title="evidence blockers" rows={blockerRows} formatTimestamp={formatTimestamp} />
+
+          <BootFoot
+            left={`local time: ${formatDateTime(Date.now())}`}
+            right={`last anchor: ${boot.diagnostics.lastInteractedAnchor ?? "--"}`}
+          />
+
+          <BootNote warning={boot.isOperatorAssisted}>
+            override path can unlock progression for operator testing, but it never satisfies
+            <strong> evidence:system:armed</strong>.
+          </BootNote>
+
+          <BootNote danger={boot.gateLocked}>
+            when locked, WOW tour/demo-script/opening-cinema stay disabled regardless of flags.
+          </BootNote>
+
+          <Slide00HiddenState
+            bootStatus={boot.state.boot.status}
+            armedEvidence={
+              boot.state.evidence.entries["evidence:system:armed"].satisfied
+                ? "satisfied"
+                : "missing"
+            }
+          />
+        </Slide00Shell>
+      </SlideContainer>
+    </div>
   );
-};
+};
diff --git a/components/slides/Slide01.tsx b/components/slides/Slide01.tsx
index 3c0be4a..bd191a4 100644
--- a/components/slides/Slide01.tsx
+++ b/components/slides/Slide01.tsx
@@ -1,57 +1,20 @@
-import React, { useState } from "react";
-import { SlideContainer, Header, NavArea } from "../SlideRenderer";
-
-export const Slide01: React.FC<{ nextSlide: () => void; prevSlide: () => void }> = ({
-  nextSlide,
-  prevSlide,
-}) => {
-  const alerts = [
-    { id: 1, label: "CRITICAL_ERROR", desc: "Paros no planeados = Pérdida directa de utilidad.", color: "red" },
-    { id: 2, label: "WARNING_OPS", desc: "Bomberazos constantes. Equipo estresado sin rumbo.", color: "orange" },
-    { id: 3, label: "MISSING_DOCS", desc: "Cajas negras. Nadie sabe cómo funciona el equipo.", color: "red" },
-    { id: 4, label: "DEPENDENCY", desc: "Si el técnico se va, la planta se detiene.", color: "red" },
-  ];
-  const [hovered, setHovered] = useState<number | null>(null);
-
-  return (
-    <SlideContainer>
-      <Header title="EL PROBLEMA" breadcrumb="DIAGNÓSTICO" slideNum={2} />
-      <div className="w-full h-full flex gap-8 items-center animate-fade-up">
-        <div className="w-1/2 flex flex-col gap-3 justify-center h-full">
-          {alerts.map((a) => (
-            <div
-              key={a.id}
-              onMouseEnter={() => setHovered(a.id)}
-              onMouseLeave={() => setHovered(null)}
-              className={`
-                p-5 border-l-4 cursor-pointer transition-all duration-300 relative overflow-hidden group rounded-r-lg
-                ${a.color === "red" ? "border-red-600 bg-red-900/10" : "border-orange-500 bg-orange-900/10"}
-                ${hovered === a.id ? "translate-x-4 bg-white/10" : ""}
-              `}
-            >
-              <div className={`font-code text-xl font-bold tracking-widest ${a.color === "red" ? "text-red-500" : "text-orange-500"}`}>
-                [{a.label}]
-              </div>
-            </div>
-          ))}
-        </div>
-
-        <div className="w-1/2 h-full relative flex items-center">
-          <div className="w-full aspect-video border border-white/20 bg-black/60 p-6 flex items-center justify-center text-center rounded-xl">
-            {hovered ? (
-              <div className="animate-fade-up">
-                <div className="text-5xl mb-4">⚠️</div>
-                <h3 className="text-2xl text-white font-bold mb-2">{alerts.find((x) => x.id === hovered)?.label}</h3>
-                <p className="text-xl text-gray-300 leading-relaxed">{alerts.find((x) => x.id === hovered)?.desc}</p>
-              </div>
-            ) : (
-              <div className="text-gray-600 font-code text-lg animate-pulse">HOVER TO SCAN ERROR...</div>
-            )}
-          </div>
-        </div>
-      </div>
-
-      <NavArea prev={prevSlide} next={nextSlide} />
-    </SlideContainer>
-  );
-};
+import React from "react";
+import { Header, NavArea, SlideContainer } from "../SlideRenderer";
+import { Slide01Scene } from "./slide01-ui";
+
+type Slide01Props = {
+  nextSlide: () => void;
+  prevSlide: () => void;
+};
+
+export const Slide01: React.FC<Slide01Props> = ({ nextSlide, prevSlide }) => {
+  return (
+    <div data-testid="slide-01-root" className="w-full h-full">
+      <SlideContainer>
+        <Header title="ROUTE SELECTOR" breadcrumb="DIAGNOSTIC DECISION" slideNum={2} />
+        <Slide01Scene />
+        <NavArea prev={prevSlide} next={nextSlide} />
+      </SlideContainer>
+    </div>
+  );
+};
diff --git a/components/slides/Slide02.tsx b/components/slides/Slide02.tsx
index f11d22c..86cfe6e 100644
--- a/components/slides/Slide02.tsx
+++ b/components/slides/Slide02.tsx
@@ -5,68 +5,70 @@ export const Slide02: React.FC<{ nextSlide: () => void; prevSlide: () => void }>
   nextSlide,
   prevSlide,
 }) => {
-  const [sliderVal, setSliderVal] = useState(95);
-
-  return (
-    <SlideContainer>
-      <Header title="INSIGHT" breadcrumb="ORIGEN" slideNum={3} />
-
-      <div className="flex flex-col h-full justify-center">
-        <div className="w-full h-full max-h-[500px] relative select-none animate-fade-up border border-white/20 rounded-xl overflow-hidden group">
-          <div className="absolute inset-0 bg-[#050505] flex items-center justify-center z-0">
-            <div className="absolute inset-0 opacity-20 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-cyan/20 to-transparent" />
-            <div className="text-center z-10">
-              <h3 className="text-6xl font-display font-black text-white drop-shadow-[0_0_20px_rgba(0,240,255,0.5)] mb-2">
-                SISTEMA
-              </h3>
-              <p className="text-xl text-cyan font-code tracking-[8px]">HITECH RTS</p>
-            </div>
-          </div>
-
-          <div
-            className="absolute inset-0 bg-red-950 flex items-center justify-center overflow-hidden border-r-4 border-gold shadow-[10px_0_50px_rgba(0,0,0,0.8)] z-10"
-            style={{ width: `${sliderVal}%` }}
-          >
-            <div className="absolute inset-0 opacity-10 pointer-events-none mix-blend-overlay z-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')]" />
-            <div className="w-screen max-w-[1600px] h-full flex items-center justify-center relative z-10">
-              <div className="text-center">
-                <h3 className="text-6xl font-display font-black text-red-500 line-through decoration-white/50 decoration-4 mb-2 drop-shadow-[0_4px_0_rgba(0,0,0,1)]">
-                  CAOS
-                </h3>
-                <p className="text-xl text-white font-code tracking-[8px] font-bold drop-shadow-md">
-                  MODO SUPERVIVENCIA
-                </p>
-              </div>
-            </div>
-          </div>
-
-          <input
-            type="range"
-            min="0"
-            max="100"
-            value={sliderVal}
-            onChange={(e) => setSliderVal(Number(e.target.value))}
-            className="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-50"
-          />
-
-          <div
-            className="absolute top-1/2 -translate-y-1/2 w-10 h-10 bg-white rounded-full shadow-[0_0_20px_rgba(255,255,255,0.5)] flex items-center justify-center pointer-events-none z-40 transition-transform duration-75"
-            style={{ left: `calc(${sliderVal}% - 20px)` }}
-          >
-            <svg viewBox="0 0 24 24" className="w-5 h-5">
-              <path d="M14 6l6 6-6 6M10 6L4 12l6 6" fill="none" stroke="black" strokeWidth="2" />
-            </svg>
-          </div>
-
-          <div className="absolute bottom-4 left-0 w-full text-center pointer-events-none z-30">
-            <span className="bg-black/50 px-3 py-1 rounded text-white font-code text-xs border border-white/20 tracking-widest">
-              DESLIZA PARA EVOLUCIONAR
-            </span>
-          </div>
-        </div>
-      </div>
-
-      <NavArea prev={prevSlide} next={nextSlide} />
-    </SlideContainer>
-  );
-};
+  const [sliderVal, setSliderVal] = useState(95);
+
+  return (
+    <div data-testid="slide-02-root" className="w-full h-full">
+      <SlideContainer>
+        <Header title="INSIGHT" breadcrumb="ORIGEN" slideNum={3} />
+
+        <div className="flex flex-col h-full justify-center">
+          <div className="w-full h-full max-h-[500px] relative select-none animate-fade-up border border-white/20 rounded-xl overflow-hidden group">
+            <div className="absolute inset-0 bg-[#050505] flex items-center justify-center z-0">
+              <div className="absolute inset-0 opacity-20 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-cyan/20 to-transparent" />
+              <div className="text-center z-10">
+                <h3 className="text-6xl font-display font-black text-white drop-shadow-[0_0_20px_rgba(0,240,255,0.5)] mb-2">
+                  SISTEMA
+                </h3>
+                <p className="text-xl text-cyan font-code tracking-[8px]">HITECH RTS</p>
+              </div>
+            </div>
+
+            <div
+              className="absolute inset-0 bg-red-950 flex items-center justify-center overflow-hidden border-r-4 border-gold shadow-[10px_0_50px_rgba(0,0,0,0.8)] z-10"
+              style={{ width: `${sliderVal}%` }}
+            >
+              <div className="absolute inset-0 opacity-10 pointer-events-none mix-blend-overlay z-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')]" />
+              <div className="w-screen max-w-[1600px] h-full flex items-center justify-center relative z-10">
+                <div className="text-center">
+                  <h3 className="text-6xl font-display font-black text-red-500 line-through decoration-white/50 decoration-4 mb-2 drop-shadow-[0_4px_0_rgba(0,0,0,1)]">
+                    CAOS
+                  </h3>
+                  <p className="text-xl text-white font-code tracking-[8px] font-bold drop-shadow-md">
+                    MODO SUPERVIVENCIA
+                  </p>
+                </div>
+              </div>
+            </div>
+
+            <input
+              type="range"
+              min="0"
+              max="100"
+              value={sliderVal}
+              onChange={(e) => setSliderVal(Number(e.target.value))}
+              className="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-50"
+            />
+
+            <div
+              className="absolute top-1/2 -translate-y-1/2 w-10 h-10 bg-white rounded-full shadow-[0_0_20px_rgba(255,255,255,0.5)] flex items-center justify-center pointer-events-none z-40 transition-transform duration-75"
+              style={{ left: `calc(${sliderVal}% - 20px)` }}
+            >
+              <svg viewBox="0 0 24 24" className="w-5 h-5">
+                <path d="M14 6l6 6-6 6M10 6L4 12l6 6" fill="none" stroke="black" strokeWidth="2" />
+              </svg>
+            </div>
+
+            <div className="absolute bottom-4 left-0 w-full text-center pointer-events-none z-30">
+              <span className="bg-black/50 px-3 py-1 rounded text-white font-code text-xs border border-white/20 tracking-widest">
+                DESLIZA PARA EVOLUCIONAR
+              </span>
+            </div>
+          </div>
+        </div>
+
+        <NavArea prev={prevSlide} next={nextSlide} />
+      </SlideContainer>
+    </div>
+  );
+};
diff --git a/components/slides/Slide03.tsx b/components/slides/Slide03.tsx
index d52dada..da32fa6 100644
--- a/components/slides/Slide03.tsx
+++ b/components/slides/Slide03.tsx
@@ -2,13 +2,15 @@ import React from "react";
 import { SlideContainer, Header, NavArea } from "../SlideRenderer";
 import TractionVault from "../widgets/TractionVault";
 
-export const Slide03: React.FC<{ nextSlide: () => void; prevSlide: () => void }> = ({
-  nextSlide,
-  prevSlide,
-}) => (
-  <SlideContainer>
-    <Header title="TRACCIÓN" breadcrumb="EVIDENCIA" slideNum={4} />
-    <TractionVault />
-    <NavArea prev={prevSlide} next={nextSlide} />
-  </SlideContainer>
-);
+export const Slide03: React.FC<{ nextSlide: () => void; prevSlide: () => void }> = ({
+  nextSlide,
+  prevSlide,
+}) => (
+  <div data-testid="slide-03-root" className="w-full h-full">
+    <SlideContainer>
+      <Header title="TRACCIÓN" breadcrumb="EVIDENCIA" slideNum={4} />
+      <TractionVault />
+      <NavArea prev={prevSlide} next={nextSlide} />
+    </SlideContainer>
+  </div>
+);
diff --git a/components/slides/Slide04.tsx b/components/slides/Slide04.tsx
index 7708eb9..4562215 100644
--- a/components/slides/Slide04.tsx
+++ b/components/slides/Slide04.tsx
@@ -811,9 +811,10 @@ export const Slide04: React.FC<{ nextSlide: () => void; prevSlide: () => void }>
   };
 
   const selectedEvidence = hoverBadge ?? lockedBadge;
-
-  return (
-    <SlideContainer>
+
+  return (
+    <div data-testid="slide-04-root" className="w-full h-full">
+      <SlideContainer>
       <style>{`
         /* ===========================================================
            NASA SYSTEM — Motion + Glass + Scanlines + Noise
@@ -1396,9 +1397,10 @@ export const Slide04: React.FC<{ nextSlide: () => void; prevSlide: () => void }>
       <ToastStack toasts={toasts} />
 
       {/* NavArea - WRAPPED in z-100 */}
-      <div className="relative z-[100] pointer-events-auto">
-        <NavArea prev={prevSlide} next={nextSlide} />
-      </div>
-    </SlideContainer>
-  );
-};
+        <div className="relative z-[100] pointer-events-auto">
+          <NavArea prev={prevSlide} next={nextSlide} />
+        </div>
+      </SlideContainer>
+    </div>
+  );
+};
diff --git a/tests/e2e/deck-smoke-00-04.e2e.spec.ts b/tests/e2e/deck-smoke-00-04.e2e.spec.ts
new file mode 100644
index 0000000..448f646
--- /dev/null
+++ b/tests/e2e/deck-smoke-00-04.e2e.spec.ts
@@ -0,0 +1,36 @@
+import { expect, test } from "@playwright/test";
+
+test("deck nav smoke: Slide00 to Slide04 and back to Slide03", async ({ page }) => {
+  await page.goto("/slides/00");
+
+  await expect(page.getByTestId("slide-00-root")).toBeVisible();
+  await expect(page.getByTestId("nav-prev")).toBeDisabled();
+  await expect(page.getByTestId("nav-current-index")).toHaveText("00");
+  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-00");
+
+  await page.getByTestId("nav-next").click();
+  await expect(page.getByTestId("slide-01-root")).toBeVisible();
+  await expect(page.getByTestId("nav-current-index")).toHaveText("01");
+  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-01");
+
+  await page.getByTestId("nav-next").click();
+  await expect(page.getByTestId("slide-02-root")).toBeVisible();
+  await expect(page.getByTestId("nav-current-index")).toHaveText("02");
+  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-02");
+
+  await page.getByTestId("nav-next").click();
+  await expect(page.getByTestId("slide-03-root")).toBeVisible();
+  await expect(page.getByTestId("nav-current-index")).toHaveText("03");
+  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-03");
+
+  await page.getByTestId("nav-next").click();
+  await expect(page.getByTestId("slide-04-root")).toBeVisible();
+  await expect(page.getByTestId("nav-current-index")).toHaveText("04");
+  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-04");
+  await expect(page.getByTestId("nav-next")).toBeDisabled();
+
+  await page.getByTestId("nav-prev").click();
+  await expect(page.getByTestId("slide-03-root")).toBeVisible();
+  await expect(page.getByTestId("nav-current-index")).toHaveText("03");
+  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-03");
+});
diff --git a/tests/e2e/deck.playwright.config.ts b/tests/e2e/deck.playwright.config.ts
new file mode 100644
index 0000000..4b3c0e2
--- /dev/null
+++ b/tests/e2e/deck.playwright.config.ts
@@ -0,0 +1,22 @@
+import { defineConfig } from "@playwright/test";
+
+export default defineConfig({
+  testDir: ".",
+  testMatch: ["deck-smoke-00-04.e2e.spec.ts"],
+  timeout: 30000,
+  expect: { timeout: 5000 },
+  fullyParallel: false,
+  retries: 0,
+  workers: 1,
+  use: {
+    baseURL: "http://127.0.0.1:3290",
+    headless: true,
+  },
+  webServer: {
+    command: "node ./node_modules/vite/bin/vite.js --host 127.0.0.1 --port 3290 --strictPort",
+    cwd: process.cwd(),
+    url: "http://127.0.0.1:3290",
+    reuseExistingServer: false,
+    timeout: 120000,
+  },
+});
```

FULL CONTENTS OF CREATED/MODIFIED FILES

===== FILE: App.tsx =====
```tsx
import React, { useCallback, useEffect, useMemo, useState } from "react";
import Background from "./components/Background";
import Scaler from "./components/Scaler";
import SlideRenderer from "./components/SlideRenderer";
import Modal from "./components/Modal";
import AIChat from "./components/AIChat";
import { DeckModeProvider, useDeckMode } from "./components/DeckRuntimeMode";
import { SLIDE_LABELS } from "./components/SlideRenderer";
import {
  OPERATOR_VIEW_DEFAULT_ON,
  WOW_DEMO,
  WOW_DEMO_SCRIPT,
  WOW_DIAGNOSTICS,
  WOW_FLAGS,
  WOW_GUIDE_ENGINE,
  WOW_MIRROR,
  WOW_OVERLAY,
  WOW_TOUR,
  WOW_TOUR_SCRIPT,
} from "./config/wow";
import { emitGuideEvidence, TourOverlay, useTourEngine } from "./wow/tour";
import { hasTourTarget } from "./wow/tour/events";
import { TourAutostartStatus } from "./wow/tour/types";
import {
  Slide00ViewVisibilityProvider,
  TopHudRow,
  TopRibbon,
  useSlide00ViewVisibility,
} from "./components/slides/slide00-ui";
import {
  BootRuntimeProvider,
  canShowDemoScript,
  canShowMirrorIntro,
  canStartTourManually,
  createWowFlagSnapshot,
  isTourAutostartBlocked,
  useBootRuntime,
  useSlideEntryEvidence,
} from "./runtime/boot";

/* ==========================================
   B9 - ControlBar HUD Pro (v1.4.0)
   ========================================== */

const ControlBar = () => {
  const { mode, setStealth, setTrack, toggleInvestorLock, toggleAutoplay } = useDeckMode();

  const btn = (active: boolean, onClick: () => void, label: string, glow: string, testId: string) => (
    <button
      data-testid={testId}
      aria-pressed={active}
      onClick={onClick}
      style={{
        padding: "6px 14px",
        borderRadius: 10,
        fontSize: 11,
        letterSpacing: 2,
        textTransform: "uppercase",
        border: "1px solid rgba(255,255,255,.12)",
        background:
          active
            ? "rgba(255,255,255,.14)"
            : "rgba(255,255,255,.04)",
        boxShadow:
          active ? `0 0 18px ${glow}` : "none",
        color: "white",
        transition: "all .25s ease",
        cursor: "pointer",
      }}
    >
      {label}
    </button>
  );

  return (
    <div
      data-testid="controlbar"
      style={{
        position: "absolute",
        top: 14,
        left: 18,
        right: 18,
        height: 44,
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "0 18px",
        borderRadius: 16,
        background:
          "linear-gradient(180deg, rgba(0,0,0,.6), rgba(0,0,0,.4))",
        backdropFilter: "blur(12px)",
        border: "1px solid rgba(255,255,255,.08)",
        boxShadow: "0 12px 30px rgba(0,0,0,.55)",
        zIndex: 9999,
      }}
    >
      <div style={{ display: "flex", gap: 10 }}>
        {btn(mode.stealth, () => setStealth(), "Stealth", "rgba(120,120,120,.6)", "mode-stealth")}
        {btn(mode.track, () => setTrack(), "Track", "rgba(0,180,200,.9)", "mode-track")}
        {btn(mode.investorLock, () => toggleInvestorLock(), "Lock", "rgba(0,180,200,.6)", "mode-lock")}
        {btn(mode.autoplay && mode.investorLock, () => toggleAutoplay(), "Autoplay", "rgba(180,140,40,.9)", "mode-autoplay")}
      </div>

      <div
        data-testid="mode-hint"
        style={{
          fontSize: 10,
          opacity: 0.55,
          letterSpacing: 2,
          whiteSpace: "nowrap",
        }}
      >
        F1 STEALTH · F2 TRACK · F3 LOCK · F4 AUTOPLAY
      </div>
      <div data-testid="mode-state" style={{ display: "none" }}>
        {mode.stealth ? "stealth:on" : "stealth:off"}|{mode.track ? "track:on" : "track:off"}|{mode.investorLock ? "lock:on" : "lock:off"}|{mode.autoplay ? "autoplay:on" : "autoplay:off"}
      </div>
    </div>
  );
};

const TOTAL_SLIDES = 20;
const DECK_NAV_START = 0;
const DECK_NAV_END = 4;
const DECK_NAV_INDICES = [0, 1, 2, 3, 4] as const;

const normalizeSlideIndex = (idx: number) => {
  const n = TOTAL_SLIDES;
  if (!Number.isFinite(idx)) return 0;
  return ((Math.trunc(idx) % n) + n) % n;
};

const clampDeckNavIndex = (idx: number) => {
  const normalized = normalizeSlideIndex(idx);
  if (normalized < DECK_NAV_START) return DECK_NAV_START;
  if (normalized > DECK_NAV_END) return DECK_NAV_END;
  return normalized;
};

const formatSlideId = (idx: number) => String(normalizeSlideIndex(idx)).padStart(2, "0");

const parseSlideIndexFromLocation = (locationLike: Pick<Location, "pathname" | "hash" | "search">): number => {
  const pathMatch = locationLike.pathname.match(/^\/slides\/(\d{1,2})\/?$/i);
  if (pathMatch) {
    return normalizeSlideIndex(Number(pathMatch[1]));
  }

  const hashRaw = locationLike.hash.startsWith("#")
    ? locationLike.hash.slice(1)
    : locationLike.hash;
  const hashMatch = hashRaw.match(/^(?:slides\/|slide\/|slide-)?(\d{1,2})$/i);
  if (hashMatch) {
    return normalizeSlideIndex(Number(hashMatch[1]));
  }

  const query = new URLSearchParams(locationLike.search);
  const querySlide = query.get("slide");
  if (querySlide != null && querySlide.trim() !== "") {
    const parsed = Number(querySlide);
    if (Number.isFinite(parsed)) {
      return normalizeSlideIndex(parsed);
    }
  }

  return 0;
};

const slidePathFromIndex = (idx: number) => `/slides/${formatSlideId(idx)}`;

const ModePill: React.FC = () => {
  const { mode } = useDeckMode();

  if (mode.stealth) return null;

  return (
    <ControlBar />
  );
};

const MirrorIntro: React.FC<{ active: boolean }> = ({ active }) => {
  if (!active) return null;

  return (
    <div className="pointer-events-none absolute inset-0 z-[120] flex items-center justify-center bg-black">
      <div className="w-full max-w-[960px] px-10">
        <p className="wow-mirror-line">Every investor says they back AI.</p>
        <p className="wow-mirror-line wow-mirror-line--2">Very few actually understand it.</p>
        <p className="wow-mirror-line wow-mirror-line--3">Let&apos;s fix that.</p>
      </div>
    </div>
  );
};

const OperatorOverlay: React.FC<{ currentSlide: number }> = ({ currentSlide }) => {
  const { mode } = useDeckMode();
  const boot = useBootRuntime();
  const [aiMode, setAiMode] = React.useState("chat");

  React.useEffect(() => {
    const onModeChange = (event: Event) => {
      const custom = event as CustomEvent<{ mode?: string }>;
      const nextMode = custom.detail?.mode;
      if (typeof nextMode === "string" && nextMode) {
        setAiMode(nextMode);
      }
    };

    window.addEventListener("wow:ai-mode", onModeChange as EventListener);
    return () => window.removeEventListener("wow:ai-mode", onModeChange as EventListener);
  }, []);

  if (!WOW_OVERLAY) return null;

  const slideName = SLIDE_LABELS[currentSlide] ?? `Slide${String(currentSlide).padStart(2, "0")}`;
  const onFlags = Object.entries(WOW_FLAGS)
    .filter(([, isOn]) => isOn)
    .map(([name]) => name.replace("WOW_", "").toLowerCase())
    .join(" · ");

  return (
    <aside className="pointer-events-none absolute right-5 top-5 z-[130] min-w-[240px] rounded-xl border border-white/15 bg-black/55 px-3 py-2 text-[10px] font-code tracking-[0.2em] text-white/70 backdrop-blur-sm" data-testid="top-ribbon-operator-overlay">
      <div>SLIDE {String(currentSlide + 1).padStart(2, "0")} · {slideName}</div>
      <div className="mt-1">AI MODE · {aiMode.toUpperCase()}</div>
      <div className="mt-1">FLAGS · {onFlags || "none"}</div>
      <div className="mt-1">RUNTIME · {mode.track ? "TRACK" : "STD"}/{mode.stealth ? "STEALTH" : "OPEN"}</div>
      <div className="mt-1">BOOT · {boot.state.boot.status}</div>
      <div className="mt-1">GATE · {boot.gateLocked ? "LOCKED" : "OPEN"}</div>
      <div className="mt-1">ARMED · {String(boot.isArmed)}</div>
      <div className="mt-1">ASSISTED · {String(boot.isOperatorAssisted)}</div>
    </aside>
  );
};

const DemoScriptOverlay: React.FC<{ currentSlide: number; enabled: boolean }> = ({ currentSlide, enabled }) => {
  if (!enabled) return null;

  const slide = currentSlide + 1;
  const moment =
    slide <= 1
      ? "Set context: evidence-first operations."
      : slide <= 5
      ? "Open AIChat after proof lock pulse for conviction."
      : slide <= 12
      ? "Use AIChat to convert telemetry into board language."
      : "Close with outcome + next 30/60 day metric.";

  return (
    <aside className="wow-demo-script-overlay" data-testid="demo-script-overlay">
      <h4>DEMO SCRIPT</h4>
      <p>Slide {String(slide).padStart(2, "0")} moment: {moment}</p>
      <p className="wow-killer-q">Q1: What evidence appears first under audit pressure?</p>
      <p className="wow-killer-q">Q2: What 60-day KPI proves risk reduction is real?</p>
    </aside>
  );
};

const DeckSlideNav: React.FC<{
  currentSlide: number;
  canPrev: boolean;
  canNext: boolean;
  onPrev: () => void;
  onNext: () => void;
  onJump: (index: number) => void;
}> = ({ currentSlide, canPrev, canNext, onPrev, onNext, onJump }) => {
  const currentSlideId = formatSlideId(currentSlide);

  return (
    <aside className="pointer-events-auto fixed bottom-4 right-4 z-[2147483004] rounded-xl border border-white/25 bg-black/70 px-3 py-3 backdrop-blur-md">
      <div className="mb-2 flex items-center gap-2">
        <button
          type="button"
          data-testid="nav-prev"
          onClick={onPrev}
          disabled={!canPrev}
          className="rounded border border-white/25 px-3 py-1 text-xs font-code tracking-[0.2em] text-white disabled:cursor-not-allowed disabled:opacity-45"
        >
          PREV
        </button>
        <button
          type="button"
          data-testid="nav-next"
          onClick={onNext}
          disabled={!canNext}
          className="rounded border border-white/25 px-3 py-1 text-xs font-code tracking-[0.2em] text-white disabled:cursor-not-allowed disabled:opacity-45"
        >
          NEXT
        </button>
      </div>
      <div className="mb-2 flex items-center gap-1">
        {DECK_NAV_INDICES.map((index) => {
          const id = formatSlideId(index);
          return (
            <button
              key={id}
              type="button"
              data-testid={`nav-jump-${id}`}
              onClick={() => onJump(index)}
              className="rounded border border-white/20 px-2 py-1 text-[10px] font-code tracking-[0.2em] text-white/90"
            >
              {id}
            </button>
          );
        })}
      </div>
      <div data-testid="nav-current-index" className="text-[10px] font-code tracking-[0.18em] text-white/70">
        {formatSlideId(currentSlide)}
      </div>
      <div data-testid="nav-current-id" className="text-[10px] font-code tracking-[0.18em] text-white/55">
        slide-{currentSlideId}
      </div>
    </aside>
  );
};

const AppInner: React.FC<{
  currentSlide: number;
  setCurrentSlide: React.Dispatch<React.SetStateAction<number>>;
  modalOpen: boolean;
  openModal: (images: string[], title: string) => void;
  closeModal: () => void;
  modalImages: string[];
  modalTitle: string;
}> = ({
  currentSlide,
  setCurrentSlide,
  modalOpen,
  openModal,
  closeModal,
  modalImages,
  modalTitle,
}) => {
  const { mode } = useDeckMode();
  const boot = useBootRuntime();
  const viewVisibility = useSlide00ViewVisibility();
  const normalizedSlide = normalizeSlideIndex(currentSlide);
  useSlideEntryEvidence(normalizedSlide);

  const tourEnabled = canStartTourManually(boot.gates);
  const demoScriptAvailable = canShowDemoScript(boot.gates);
  const mirrorAvailable = canShowMirrorIntro(boot.gates);
  const [demoScriptActive, setDemoScriptActive] = useState(false);
  const [mirrorActive, setMirrorActive] = useState(false);

  const [autostartStatus, setAutostartStatus] = useState<TourAutostartStatus>({
    attempts: 0,
    started: false,
    reason: "not-requested",
  });

  const {
    state: tourState,
    activeStep: tourStep,
    stepComplete,
    api: tourApi,
    guideOverlayModel,
  } = useTourEngine({
    enabled: tourEnabled,
    currentSlide: normalizedSlide,
    scriptId: WOW_TOUR_SCRIPT || "enterprise",
  });
  const tourStepTargetExists = useMemo(() => hasTourTarget(tourStep?.targetSelector), [tourStep?.targetSelector, tourState.stepIndex, normalizedSlide]);

  const cancelMirror = useCallback(() => {
    setMirrorActive(false);
  }, []);

  const nextSlide = useCallback(() => {
    cancelMirror();
    setCurrentSlide((prev) => normalizeSlideIndex(prev + 1));
  }, [cancelMirror, setCurrentSlide]);
  const prevSlide = useCallback(() => {
    cancelMirror();
    setCurrentSlide((prev) => normalizeSlideIndex(prev - 1));
  }, [cancelMirror, setCurrentSlide]);
  const goToSlide = useCallback((index: number) => {
    cancelMirror();
    setCurrentSlide(normalizeSlideIndex(index));
  }, [cancelMirror, setCurrentSlide]);
  const deckNavIndex = clampDeckNavIndex(normalizedSlide);
  const deckCanPrev = deckNavIndex > DECK_NAV_START;
  const deckCanNext = deckNavIndex < DECK_NAV_END;
  const goToDeckSlide = useCallback((index: number) => {
    cancelMirror();
    setCurrentSlide(clampDeckNavIndex(index));
  }, [cancelMirror, setCurrentSlide]);
  const deckPrev = useCallback(() => {
    if (!deckCanPrev) return;
    goToDeckSlide(deckNavIndex - 1);
  }, [deckCanPrev, deckNavIndex, goToDeckSlide]);
  const deckNext = useCallback(() => {
    if (!deckCanNext) return;
    goToDeckSlide(deckNavIndex + 1);
  }, [deckCanNext, deckNavIndex, goToDeckSlide]);

  useEffect(() => {
    if (!WOW_DEMO || !WOW_MIRROR || !mirrorAvailable) {
      setMirrorActive(false);
      return;
    }

    if (normalizedSlide !== 0) {
      setMirrorActive(false);
      return;
    }

    if (!mirrorActive) return;
    setMirrorActive(true);
  }, [normalizedSlide, mirrorAvailable, mirrorActive]);

  useEffect(() => {
    if (!demoScriptAvailable && demoScriptActive) {
      setDemoScriptActive(false);
    }
  }, [demoScriptAvailable, demoScriptActive]);

  useEffect(() => {
    if (!mirrorAvailable && mirrorActive) {
      setMirrorActive(false);
    }
  }, [mirrorAvailable, mirrorActive]);

  useEffect(() => {
    const onDemoScriptToggle = (event: Event) => {
      const custom = event as CustomEvent<{ enabled?: boolean }>;
      if (!demoScriptAvailable) {
        setDemoScriptActive(false);
        return;
      }
      if (typeof custom.detail?.enabled === "boolean") {
        setDemoScriptActive(custom.detail.enabled);
        return;
      }
      setDemoScriptActive((prev) => !prev);
    };

    const onMirrorToggle = (event: Event) => {
      const custom = event as CustomEvent<{ enabled?: boolean }>;
      if (!mirrorAvailable) {
        setMirrorActive(false);
        return;
      }
      if (typeof custom.detail?.enabled === "boolean") {
        setMirrorActive(custom.detail.enabled);
        return;
      }
      setMirrorActive((prev) => !prev);
    };

    window.addEventListener("wow:demo-script-toggle", onDemoScriptToggle as EventListener);
    window.addEventListener("wow:mirror-toggle", onMirrorToggle as EventListener);
    return () => {
      window.removeEventListener("wow:demo-script-toggle", onDemoScriptToggle as EventListener);
      window.removeEventListener("wow:mirror-toggle", onMirrorToggle as EventListener);
    };
  }, [demoScriptAvailable, mirrorAvailable]);

  useEffect(() => {
    if (!WOW_DEMO) return;

    window.dispatchEvent(
      new CustomEvent("wow:tour-event", {
        detail: { name: "slide:changed", payload: { to: normalizedSlide }, ts: Date.now() },
      })
    );

    if (WOW_GUIDE_ENGINE) {
      emitGuideEvidence("slide:changed", { to: normalizedSlide });
      emitGuideEvidence("slide:entered", { slide: normalizedSlide });
    }
  }, [normalizedSlide]);

  useEffect(() => {
    if (!tourEnabled) return;
    window.dispatchEvent(
      new CustomEvent("wow:tour-step", {
        detail: {
          stepId: tourStep?.id ?? "",
          pasteQuestion: tourStep?.pasteQuestion ?? "",
          readAloudText: tourStep?.readAloudText ?? "",
          running: tourState.status === "running",
        },
      })
    );
  }, [tourEnabled, tourStep, tourState.status]);

  useEffect(() => {
    if (!tourEnabled || tourState.status !== "running") return;
    if (!tourStep?.id) return;
    if (tourStep.id === "open-aichat" || tourStep.id === "fixture-load" || tourStep.id === "ask-killer-question") {
      window.dispatchEvent(new CustomEvent("wow:tour-command", { detail: { cmd: "open-chat" } }));
    }
  }, [tourEnabled, tourState.status, tourStep?.id]);

  useEffect(() => {
    if (!WOW_DEMO || !WOW_TOUR) {
      setAutostartStatus({ attempts: 0, started: false, reason: "tour-disabled" });
      return;
    }

    if (!tourEnabled) {
      setAutostartStatus({ attempts: 0, started: false, reason: boot.gates.tour.reason });
      return;
    }

    if (isTourAutostartBlocked(boot.gates)) {
      setAutostartStatus({
        attempts: 0,
        started: false,
        reason: boot.gates.tourAutostart.reason,
      });
      return;
    }

    setAutostartStatus({ attempts: 0, started: false, reason: "manual-start-only" });
  }, [tourEnabled, boot.gates]);

  useEffect(() => {
    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key === "F1" || e.key === "F2" || e.key === "F3" || e.key === "F4") return;
      if (modalOpen) return;
      if (mode.investorLock) return;

      if (e.key === "ArrowRight" || e.key === " ") {
        nextSlide();
      } else if (e.key === "ArrowLeft") {
        prevSlide();
      }
    };

    window.addEventListener("keydown", onKeyDown, true);
    return () => window.removeEventListener("keydown", onKeyDown, true);
  }, [modalOpen, mode.investorLock, nextSlide, prevSlide]);

  useEffect(() => {
    if (!mode.investorLock) return;
    if (!mode.autoplay) return;

    const t = window.setInterval(() => {
      setCurrentSlide((prev) => normalizeSlideIndex(prev + 1));
    }, Math.max(1500, mode.autoplayMs));

    return () => window.clearInterval(t);
  }, [mode.investorLock, mode.autoplay, mode.autoplayMs, setCurrentSlide]);

  return (
    <div data-testid="deck-root" className="deck-stage-root relative w-screen h-screen overflow-hidden bg-black text-white font-main">
      <Background />
      <MirrorIntro active={mirrorActive} />
      <TopRibbon visible={viewVisibility.showTopRibbon}>
        <OperatorOverlay currentSlide={normalizedSlide} />
      </TopRibbon>
      <DemoScriptOverlay
        currentSlide={normalizedSlide}
        enabled={WOW_DEMO && WOW_DEMO_SCRIPT && demoScriptAvailable && demoScriptActive}
      />
      {tourEnabled && (
        <TourOverlay
          active={tourState.status === "running" || tourState.status === "completed"}
          scriptTitle={tourState.scriptTitle || "Enterprise Investor Demo"}
          stepIndex={tourState.stepIndex}
          totalSteps={tourState.steps.length || 1}
          step={tourStep}
          status={tourState.status}
          canNext={stepComplete || !!tourStep?.allowNextBeforeComplete}
          targetExists={tourStepTargetExists}
          autostartStatus={autostartStatus}
          stepComplete={stepComplete}
          completedStepIds={tourState.completedStepIds}
          guideOverlayModel={guideOverlayModel}
          onBack={tourApi.back}
          onNext={tourApi.next}
          onSkip={tourApi.skip}
          onRestart={() => {
            tourApi.stop();
            tourApi.start(WOW_TOUR_SCRIPT || "enterprise");
          }}
          onStart={() => tourApi.start(WOW_TOUR_SCRIPT || "enterprise")}
          onPasteQuestion={(text) => window.dispatchEvent(new CustomEvent("wow:tour-paste", { detail: { text } }))}
        />
      )}
      {viewVisibility.showDiagnostics && WOW_DIAGNOSTICS && !tourEnabled && WOW_DEMO && (
        <div className="fixed bottom-4 left-4 z-[2147483002] rounded border border-white/25 bg-black/80 px-3 py-2 text-[11px] text-white/80" data-testid="wow-diagnostics">
          WOW diagnostics: gate locked ({boot.gates.tour.reason}).
        </div>
      )}
      <div data-testid="global-mode-state" style={{ display: "none" }}>
        {mode.stealth ? "stealth:on" : "stealth:off"}|{mode.track ? "track:on" : "track:off"}|{mode.investorLock ? "lock:on" : "lock:off"}|{mode.autoplay ? "autoplay:on" : "autoplay:off"}
      </div>
      <div data-testid="boot-gate-state" style={{ display: "none" }}>
        status:{boot.state.boot.status}|gateLocked:{String(boot.gateLocked)}|armed:{String(boot.isArmed)}|operatorAssisted:{String(boot.isOperatorAssisted)}|tourReady:{String(canStartTourManually(boot.gates))}|tourAutostart:{boot.gates.tourAutostart.reason}
      </div>
      <div data-testid="boot-evidence-system-armed" style={{ display: "none" }}>
        {boot.state.evidence.entries["evidence:system:armed"].satisfied ? "satisfied" : "missing"}
      </div>
      <div data-testid="boot-feature-state" style={{ display: "none" }}>
        demoScriptAvailable:{String(demoScriptAvailable)}|demoScriptActive:{String(demoScriptActive)}|mirrorAvailable:{String(mirrorAvailable)}|mirrorActive:{String(mirrorActive)}
      </div>
      <DeckSlideNav
        currentSlide={deckNavIndex}
        canPrev={deckCanPrev}
        canNext={deckCanNext}
        onPrev={deckPrev}
        onNext={deckNext}
        onJump={goToDeckSlide}
      />

      <TopHudRow visible={viewVisibility.showTopHudRow}>
        <ModePill />
      </TopHudRow>

      <Scaler slideIndex={normalizedSlide}>
        <div className="deck-stage-frame w-full h-full relative [perspective:1400px]">
          <SlideRenderer
            index={normalizedSlide}
            totalSlides={TOTAL_SLIDES}
            nextSlide={nextSlide}
            prevSlide={prevSlide}
            goToSlide={goToSlide}
            openModal={openModal}
            wowDemo={WOW_DEMO}
          />
        </div>
      </Scaler>

      {modalOpen && (
        <Modal
          isOpen={modalOpen}
          onClose={closeModal}
          images={modalImages}
          title={modalTitle}
        />
      )}

      {!mode.stealth && <AIChat />}
    </div>
  );
};

const WOW_FLAG_SNAPSHOT = createWowFlagSnapshot();

export default function App() {
  const [currentSlide, setCurrentSlide] = useState(() => {
    if (typeof window === "undefined") {
      return 0;
    }
    return parseSlideIndexFromLocation(window.location);
  });

  const [modalOpen, setModalOpen] = useState(false);
  const [modalImages, setModalImages] = useState<string[]>([]);
  const [modalTitle, setModalTitle] = useState("");

  const openModal = (images: string[], title: string) => {
    setModalImages(images);
    setModalTitle(title);
    setModalOpen(true);
  };
  const closeModal = () => setModalOpen(false);

  const whitelist = useMemo(() => [4, 13], []);

  useEffect(() => {
    if (typeof window === "undefined") return;

    const syncFromUrl = () => {
      setCurrentSlide(parseSlideIndexFromLocation(window.location));
    };

    window.addEventListener("popstate", syncFromUrl);
    window.addEventListener("hashchange", syncFromUrl);
    return () => {
      window.removeEventListener("popstate", syncFromUrl);
      window.removeEventListener("hashchange", syncFromUrl);
    };
  }, []);

  useEffect(() => {
    if (typeof window === "undefined") return;

    const nextPath = slidePathFromIndex(currentSlide);
    if (window.location.pathname !== nextPath) {
      window.history.replaceState(window.history.state, "", nextPath);
    }
  }, [currentSlide]);

  return (
    <BootRuntimeProvider wowFlags={WOW_FLAG_SNAPSHOT}>
      <Slide00ViewVisibilityProvider defaultOn={OPERATOR_VIEW_DEFAULT_ON}>
        <DeckModeProvider slideIndex={normalizeSlideIndex(currentSlide)} heavyFxWhitelist={whitelist}>
          <AppInner
            currentSlide={currentSlide}
            setCurrentSlide={setCurrentSlide}
            modalOpen={modalOpen}
            openModal={openModal}
            closeModal={closeModal}
            modalImages={modalImages}
            modalTitle={modalTitle}
          />
        </DeckModeProvider>
      </Slide00ViewVisibilityProvider>
    </BootRuntimeProvider>
  );
}
```

===== FILE: components/slides/Slide00.tsx =====
```tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Header, NavArea, SlideContainer } from "../SlideRenderer";
import {
  OPERATOR_DIAGNOSTICS,
  WOW_DEMO_SCRIPT,
  WOW_MIRROR,
  WOW_OPENING_CINEMA,
  WOW_TOUR,
  WOW_TOUR_AUTOSTART,
} from "../../config/wow";
import { useBootRuntime } from "../../runtime/boot";
import {
  BootCenterLayout,
  BootFoot,
  BootNote,
  BootPanel,
  BootPanelBody,
  BootPanelFooter,
  BootPanelHeader,
  BootSideColumn,
  BootStatusBadge,
  BootToast,
  BootTopline,
  DiagnosticsDock,
  DiagnosticsDockToggle,
  EvidenceList,
  GateMatrix,
  OpeningFlagsBadge,
  PersistenceIndicator,
  ResetControls,
  Slide00HiddenState,
  Slide00Shell,
  ViewControlsTogglePanel,
  buildConfirmSlotContent,
  buildEvidenceRows,
  buildEvidenceStatusCards,
  buildGateRows,
  clearSystemStorageKeys,
  collectSystemStorageKeys,
  formatDateTime,
  formatTimestamp,
  humanReason,
  statusLabel,
  statusNarrative,
  useSlide00ViewVisibility,
} from "./slide00-ui";
import "./Slide00.boot.css";

type Slide00Props = {
  nextSlide: () => void;
  prevSlide: () => void;
};

type PersistenceState = {
  hasSnapshot: boolean;
  keys: string[];
};

function readPersistenceState(): PersistenceState {
  if (typeof window === "undefined") {
    return { hasSnapshot: false, keys: [] };
  }

  const keys = collectSystemStorageKeys(window.localStorage);
  return {
    hasSnapshot: keys.includes("hitech.boot.snapshot.v1"),
    keys,
  };
}

export const Slide00: React.FC<Slide00Props> = ({ nextSlide, prevSlide }) => {
  const boot = useBootRuntime();
  const viewVisibility = useSlide00ViewVisibility();
  const [showToast, setShowToast] = useState(false);
  const [toastDetail, setToastDetail] = useState("Sistema listo");
  const [diagnosticsOpen, setDiagnosticsOpen] = useState(false);
  const [diagnosticsCompact, setDiagnosticsCompact] = useState(false);
  const [demoScriptActive, setDemoScriptActive] = useState(false);
  const [mirrorActive, setMirrorActive] = useState(false);
  const [persistence, setPersistence] = useState<PersistenceState>(() => readPersistenceState());
  const lastToastLogIdRef = useRef<string | null>(null);

  const refreshPersistence = useCallback(() => {
    setPersistence(readPersistenceState());
  }, []);

  const evidenceRows = useMemo(() => buildEvidenceRows(boot), [boot.state.evidence]);
  const blockerRows = useMemo(
    () => evidenceRows.filter((row) => row.blocker),
    [evidenceRows]
  );
  const gateRows = useMemo(() => buildGateRows(boot), [boot.gates]);

  const kpiCards = useMemo(
    () =>
      buildEvidenceStatusCards({
        gateLocked: boot.gateLocked,
        armed: boot.isArmed,
        operatorAssisted: boot.isOperatorAssisted,
        missingBlockers: boot.diagnostics.evidenceSummary.blockersMissing,
        satisfiedBlockers: boot.diagnostics.evidenceSummary.blockersSatisfied,
      }),
    [boot.gateLocked, boot.isArmed, boot.isOperatorAssisted, boot.diagnostics.evidenceSummary]
  );

  const confirmSlot = useMemo(
    () =>
      buildConfirmSlotContent({
        status: boot.state.boot.status,
        isArmed: boot.isArmed,
      }),
    [boot.state.boot.status, boot.isArmed]
  );

  const showConfirmButton =
    boot.state.boot.status === "ARMED_PENDING_CONFIRM" ||
    (boot.state.boot.status === "OPERATOR_ASSISTED" && !boot.isArmed);

  const confirmLabel =
    boot.state.boot.status === "OPERATOR_ASSISTED" && !boot.isArmed
      ? "confirm arming (override path)"
      : "confirm arming";

  const canConfirm =
    boot.state.boot.status === "ARMED_PENDING_CONFIRM" ? boot.canConfirm : true;

  useEffect(() => {
    const lastLog = boot.state.operatorLog[boot.state.operatorLog.length - 1];
    if (!lastLog) return;
    if (lastLog.action !== "boot:arm:confirmed") return;
    if (lastToastLogIdRef.current === lastLog.id) return;

    lastToastLogIdRef.current = lastLog.id;
    setToastDetail(lastLog.title);
    setShowToast(true);
  }, [boot.state.operatorLog]);

  useEffect(() => {
    refreshPersistence();
  }, [boot.state, refreshPersistence]);

  useEffect(() => {
    if (viewVisibility.showDiagnostics) return;
    setDiagnosticsOpen(false);
  }, [viewVisibility.showDiagnostics]);

  const armNow = useCallback(() => {
    boot.recordAnchorInteraction("slide00:arm-system", "Primary arm button clicked");
    if (!boot.canArm) return;
    boot.requestArm();
  }, [boot]);

  const confirmArm = useCallback(() => {
    boot.recordAnchorInteraction("slide00:confirm-arm", "Arm confirmation clicked");
    if (boot.state.boot.status === "ARMED_PENDING_CONFIRM" && !boot.canConfirm) return;
    boot.confirmArm();
  }, [boot]);

  const toggleOverride = useCallback(() => {
    boot.recordAnchorInteraction("slide00:override-toggle", "Operator override toggled");
    boot.setOverride(!boot.state.boot.overrideEnabled);
  }, [boot]);

  const softReset = useCallback(() => {
    boot.recordAnchorInteraction("slide00:soft-reset", "Operator soft reset requested");
    boot.resetLocal();
    setShowToast(false);
    refreshPersistence();
  }, [boot, refreshPersistence]);

  const hardReset = useCallback(() => {
    boot.recordAnchorInteraction("slide00:hard-reset", "Operator hard reset requested");
    boot.resetLocal();

    if (typeof window !== "undefined") {
      const cleared = clearSystemStorageKeys(window.localStorage);
      boot.appendOperatorLog({
        level: "warning",
        title: "Hard reset completed",
        detail: `Cleared ${cleared} local storage key(s).`,
        action: "boot:reset:hard",
      });
    }

    setShowToast(false);
    refreshPersistence();
  }, [boot, refreshPersistence]);

  const copySnapshot = useCallback(async () => {
    boot.recordAnchorInteraction("slide00:snapshot-copy", "Operator requested snapshot copy");
    const copied = await boot.copySnapshotToClipboard();

    boot.appendOperatorLog({
      level: copied ? "success" : "warning",
      title: copied ? "Snapshot copied" : "Snapshot copy unavailable",
      detail: copied
        ? "Snapshot JSON copied to clipboard."
        : "Clipboard API unavailable. Use download snapshot.",
      action: copied ? "boot:snapshot:copied" : "boot:snapshot:copy:failed",
    });
  }, [boot]);

  const downloadSnapshot = useCallback(() => {
    boot.recordAnchorInteraction(
      "slide00:snapshot-download",
      "Operator requested snapshot download"
    );
    const downloaded = boot.downloadSnapshot("boot-snapshot.json");

    boot.appendOperatorLog({
      level: downloaded ? "success" : "warning",
      title: downloaded ? "Snapshot downloaded" : "Snapshot download unavailable",
      detail: downloaded
        ? "Snapshot file was generated locally."
        : "Download API unavailable in this environment.",
      action: downloaded ? "boot:snapshot:downloaded" : "boot:snapshot:download:failed",
    });
  }, [boot]);

  const toggleDemoScript = useCallback(() => {
    const next = !demoScriptActive;
    setDemoScriptActive(next);
    boot.recordAnchorInteraction(
      "slide00:toggle-demo-script",
      `Demo script toggled ${next ? "on" : "off"}`
    );
    window.dispatchEvent(
      new CustomEvent("wow:demo-script-toggle", { detail: { enabled: next } })
    );
  }, [boot, demoScriptActive]);

  const toggleMirror = useCallback(() => {
    const next = !mirrorActive;
    setMirrorActive(next);
    boot.recordAnchorInteraction(
      "slide00:toggle-mirror",
      `Mirror intro toggled ${next ? "on" : "off"}`
    );
    window.dispatchEvent(new CustomEvent("wow:mirror-toggle", { detail: { enabled: next } }));
  }, [boot, mirrorActive]);

  const diagnosticsMeta = useMemo(
    () => [
      {
        key: "state",
        label: "boot state",
        value: boot.state.boot.status,
        testId: "boot-state-value",
      },
      {
        key: "gate",
        label: "gate lock",
        value: boot.gateLocked ? "LOCKED" : "OPEN",
      },
      {
        key: "event",
        label: "last event",
        value: boot.diagnostics.lastEvent
          ? `${boot.diagnostics.lastEvent.id} · ${boot.diagnostics.lastEvent.action}`
          : "--",
      },
      {
        key: "anchor",
        label: "last anchor",
        value: boot.diagnostics.lastInteractedAnchor ?? "--",
      },
    ],
    [boot.state.boot.status, boot.gateLocked, boot.diagnostics.lastEvent, boot.diagnostics.lastInteractedAnchor]
  );

  const diagnosticsControls = useMemo(
    () => [
      {
        key: "override",
        copy: "Allow advance without arming (operator-assisted only).",
        actions: [
          {
            key: "toggle",
            label: boot.state.boot.overrideEnabled ? "override on" : "override off",
            active: boot.state.boot.overrideEnabled,
            onClick: toggleOverride,
            testId: "operator-override-toggle",
          },
        ],
      },
      {
        key: "reset",
        copy: "Soft reset local runtime to IDLE and clear active boot snapshot.",
        actions: [
          {
            key: "soft-reset",
            label: "soft reset",
            onClick: softReset,
            testId: "operator-reset-local",
          },
        ],
      },
      {
        key: "snapshot",
        copy: "Snapshot export (deterministic JSON).",
        actions: [
          {
            key: "copy",
            label: "copy",
            onClick: copySnapshot,
            testId: "operator-copy-snapshot",
          },
          {
            key: "download",
            label: "download",
            onClick: downloadSnapshot,
            testId: "operator-download-snapshot",
          },
        ],
      },
      {
        key: "demo-script",
        copy: "Manual script surface (still blocked before arming).",
        actions: [
          {
            key: "demo",
            label: demoScriptActive ? "script on" : "script off",
            active: demoScriptActive,
            onClick: toggleDemoScript,
          },
        ],
      },
      {
        key: "mirror",
        copy: "Manual mirror intro (still blocked before arming).",
        actions: [
          {
            key: "mirror",
            label: mirrorActive ? "mirror on" : "mirror off",
            active: mirrorActive,
            onClick: toggleMirror,
          },
        ],
      },
    ],
    [
      boot.state.boot.overrideEnabled,
      copySnapshot,
      demoScriptActive,
      downloadSnapshot,
      mirrorActive,
      softReset,
      toggleDemoScript,
      toggleMirror,
      toggleOverride,
    ]
  );

  const diagnosticsLogRows = useMemo(
    () =>
      boot.state.operatorLog
        .slice(-8)
        .reverse()
        .map((entry) => ({
          id: entry.id,
          head: `${entry.action} · ${formatTimestamp(entry.ts)}`,
          body: `${entry.title} - ${entry.detail}`,
        })),
    [boot.state.operatorLog]
  );

  const lastEventLabel = boot.diagnostics.lastEvent
    ? `${boot.diagnostics.lastEvent.id} · ${boot.diagnostics.lastEvent.action}`
    : "--";

  const cinematicFlagSummary = [
    WOW_TOUR ? "tour" : null,
    WOW_TOUR_AUTOSTART ? "tour_autostart" : null,
    WOW_DEMO_SCRIPT ? "demo_script" : null,
    WOW_OPENING_CINEMA ? "opening_cinema" : null,
    WOW_MIRROR ? "mirror" : null,
  ]
    .filter(Boolean)
    .join(", ");

  const status = statusLabel(boot.state.boot.status);

  const diagnosticsSurfaceVisible = viewVisibility.showDiagnostics && OPERATOR_DIAGNOSTICS;

  return (
    <div data-testid="slide-00-root" className="w-full h-full">
      <SlideContainer>
        <Slide00Shell
          nav={<NavArea prev={prevSlide} next={nextSlide} />}
          toast={<BootToast open={showToast} detail={toastDetail} onDismiss={() => setShowToast(false)} />}
          diagnostics={
            diagnosticsSurfaceVisible ? (
              <>
                <DiagnosticsDockToggle
                  open={diagnosticsOpen}
                  onClick={() => setDiagnosticsOpen((prev) => !prev)}
                />
                <DiagnosticsDock
                  open={diagnosticsOpen}
                  compact={diagnosticsCompact}
                  onBack={() => setDiagnosticsOpen(false)}
                  onToggleMode={() => setDiagnosticsCompact((prev) => !prev)}
                  metaItems={diagnosticsMeta}
                  controlRows={diagnosticsControls}
                  satisfiedRows={boot.diagnostics.satisfiedEvidence}
                  missingRows={boot.diagnostics.missingBlockers}
                  logRows={diagnosticsLogRows}
                  footerCopy="local diagnostics only · does not alter evidence semantics"
                  footerTime={new Date().toLocaleString()}
                />
              </>
            ) : null
          }
        >
          <BootTopline
            brandTitle="HITECH RTS"
            brandSubtitle="boot / deterministic gate"
            slideLabel="slide 00 · boot gate"
          />

          <Header
            title="BOOT CONSOLE"
            breadcrumb="ACTION / WHY / CONFIRM"
            slideNum={1}
            rightBadge={`STATE ${status}`}
          />

          <BootCenterLayout
            main={
              <BootPanel
                header={
                  <BootPanelHeader
                    title="Operator arming required"
                    subtitle={
                      <>
                        This deck starts in manual mode. Scripted systems remain blocked until
                        <strong> evidence:system:armed </strong>
                        is satisfied by explicit operator action.
                      </>
                    }
                    whyLabel="why: register verifiable activity"
                  />
                }
                body={
                  <BootPanelBody
                    status={boot.state.boot.status}
                    canArm={boot.canArm}
                    canConfirm={canConfirm}
                    showConfirm={showConfirmButton}
                    confirmLabel={confirmLabel}
                    onArm={armNow}
                    onConfirm={confirmArm}
                    confirmState={confirmSlot.state}
                    confirmText={confirmSlot.text}
                    confirmStrongText={confirmSlot.strongText}
                    cards={kpiCards}
                  />
                }
                footer={
                  <BootPanelFooter>
                    <p className="slide00-arm-emphasis-copy">
                      arm lane reserved for glow, glass and directional emphasis modules.
                    </p>
                  </BootPanelFooter>
                }
              />
            }
            side={
              <BootSideColumn>
                <BootStatusBadge
                  isArmed={boot.isArmed}
                  isOperatorAssisted={boot.isOperatorAssisted}
                  narrative={statusNarrative(boot.state.boot.status)}
                  lastEventLabel={lastEventLabel}
                />

                <OpeningFlagsBadge
                  summary={cinematicFlagSummary || "none"}
                  autostartReason={humanReason(boot.gates.tourAutostart.reason)}
                  warning={boot.gates.tourAutostart.reason === "autostart-disabled-by-boot-contract"}
                />

                <ViewControlsTogglePanel
                  showTopHudRow={viewVisibility.showTopHudRow}
                  showTopRibbon={viewVisibility.showTopRibbon}
                  showDiagnostics={viewVisibility.showDiagnostics}
                  onTopHudRowChange={viewVisibility.setShowTopHudRow}
                  onTopRibbonChange={viewVisibility.setShowTopRibbon}
                  onDiagnosticsChange={viewVisibility.setShowDiagnostics}
                />

                <PersistenceIndicator
                  persisted={persistence.hasSnapshot}
                  keyCount={persistence.keys.length}
                  keys={persistence.keys}
                />

                <ResetControls onSoftReset={softReset} onHardReset={hardReset} />

                <GateMatrix rows={gateRows} humanReason={humanReason} />
              </BootSideColumn>
            }
          />

          <EvidenceList title="evidence blockers" rows={blockerRows} formatTimestamp={formatTimestamp} />

          <BootFoot
            left={`local time: ${formatDateTime(Date.now())}`}
            right={`last anchor: ${boot.diagnostics.lastInteractedAnchor ?? "--"}`}
          />

          <BootNote warning={boot.isOperatorAssisted}>
            override path can unlock progression for operator testing, but it never satisfies
            <strong> evidence:system:armed</strong>.
          </BootNote>

          <BootNote danger={boot.gateLocked}>
            when locked, WOW tour/demo-script/opening-cinema stay disabled regardless of flags.
          </BootNote>

          <Slide00HiddenState
            bootStatus={boot.state.boot.status}
            armedEvidence={
              boot.state.evidence.entries["evidence:system:armed"].satisfied
                ? "satisfied"
                : "missing"
            }
          />
        </Slide00Shell>
      </SlideContainer>
    </div>
  );
};
```

===== FILE: components/slides/Slide01.tsx =====
```tsx
import React from "react";
import { Header, NavArea, SlideContainer } from "../SlideRenderer";
import { Slide01Scene } from "./slide01-ui";

type Slide01Props = {
  nextSlide: () => void;
  prevSlide: () => void;
};

export const Slide01: React.FC<Slide01Props> = ({ nextSlide, prevSlide }) => {
  return (
    <div data-testid="slide-01-root" className="w-full h-full">
      <SlideContainer>
        <Header title="ROUTE SELECTOR" breadcrumb="DIAGNOSTIC DECISION" slideNum={2} />
        <Slide01Scene />
        <NavArea prev={prevSlide} next={nextSlide} />
      </SlideContainer>
    </div>
  );
};
```

===== FILE: components/slides/Slide02.tsx =====
```tsx
import React, { useState } from "react";
import { SlideContainer, Header, NavArea } from "../SlideRenderer";

export const Slide02: React.FC<{ nextSlide: () => void; prevSlide: () => void }> = ({
  nextSlide,
  prevSlide,
}) => {
  const [sliderVal, setSliderVal] = useState(95);

  return (
    <div data-testid="slide-02-root" className="w-full h-full">
      <SlideContainer>
        <Header title="INSIGHT" breadcrumb="ORIGEN" slideNum={3} />

        <div className="flex flex-col h-full justify-center">
          <div className="w-full h-full max-h-[500px] relative select-none animate-fade-up border border-white/20 rounded-xl overflow-hidden group">
            <div className="absolute inset-0 bg-[#050505] flex items-center justify-center z-0">
              <div className="absolute inset-0 opacity-20 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-cyan/20 to-transparent" />
              <div className="text-center z-10">
                <h3 className="text-6xl font-display font-black text-white drop-shadow-[0_0_20px_rgba(0,240,255,0.5)] mb-2">
                  SISTEMA
                </h3>
                <p className="text-xl text-cyan font-code tracking-[8px]">HITECH RTS</p>
              </div>
            </div>

            <div
              className="absolute inset-0 bg-red-950 flex items-center justify-center overflow-hidden border-r-4 border-gold shadow-[10px_0_50px_rgba(0,0,0,0.8)] z-10"
              style={{ width: `${sliderVal}%` }}
            >
              <div className="absolute inset-0 opacity-10 pointer-events-none mix-blend-overlay z-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')]" />
              <div className="w-screen max-w-[1600px] h-full flex items-center justify-center relative z-10">
                <div className="text-center">
                  <h3 className="text-6xl font-display font-black text-red-500 line-through decoration-white/50 decoration-4 mb-2 drop-shadow-[0_4px_0_rgba(0,0,0,1)]">
                    CAOS
                  </h3>
                  <p className="text-xl text-white font-code tracking-[8px] font-bold drop-shadow-md">
                    MODO SUPERVIVENCIA
                  </p>
                </div>
              </div>
            </div>

            <input
              type="range"
              min="0"
              max="100"
              value={sliderVal}
              onChange={(e) => setSliderVal(Number(e.target.value))}
              className="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-50"
            />

            <div
              className="absolute top-1/2 -translate-y-1/2 w-10 h-10 bg-white rounded-full shadow-[0_0_20px_rgba(255,255,255,0.5)] flex items-center justify-center pointer-events-none z-40 transition-transform duration-75"
              style={{ left: `calc(${sliderVal}% - 20px)` }}
            >
              <svg viewBox="0 0 24 24" className="w-5 h-5">
                <path d="M14 6l6 6-6 6M10 6L4 12l6 6" fill="none" stroke="black" strokeWidth="2" />
              </svg>
            </div>

            <div className="absolute bottom-4 left-0 w-full text-center pointer-events-none z-30">
              <span className="bg-black/50 px-3 py-1 rounded text-white font-code text-xs border border-white/20 tracking-widest">
                DESLIZA PARA EVOLUCIONAR
              </span>
            </div>
          </div>
        </div>

        <NavArea prev={prevSlide} next={nextSlide} />
      </SlideContainer>
    </div>
  );
};
```

===== FILE: components/slides/Slide03.tsx =====
```tsx
import React from "react";
import { SlideContainer, Header, NavArea } from "../SlideRenderer";
import TractionVault from "../widgets/TractionVault";

export const Slide03: React.FC<{ nextSlide: () => void; prevSlide: () => void }> = ({
  nextSlide,
  prevSlide,
}) => (
  <div data-testid="slide-03-root" className="w-full h-full">
    <SlideContainer>
      <Header title="TRACCIÓN" breadcrumb="EVIDENCIA" slideNum={4} />
      <TractionVault />
      <NavArea prev={prevSlide} next={nextSlide} />
    </SlideContainer>
  </div>
);
```

===== FILE: components/slides/Slide04.tsx =====
```tsx
import React, { useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { SlideContainer, Header, NavArea } from "../SlideRenderer";
import { WOW_DEMO, WOW_EVIDENCE_IMPACT, WOW_PROOF_LOCK } from "../../config/wow";
import { useStableTimeout } from "../../wow";
import { emitTourEvent } from "../../wow/tour";

/**
 * =============================================================
 * Slide04 — AUDIT-PROOF REALITY (NASA-level)
 * SOLUCIÓN / PROPUESTA DE VALOR
 * "La realidad que nos obligó a crear el motor"
 * =============================================================
 *
 * Concept:
 * - Not "how the engine works" (that's SmartService slide)
 * - This is "why the engine had to exist"
 *
 * Narrative in 3 acts:
 *   Act I   — BEFORE / Black Box
 *   Act II  — THE QUESTION (executive tension) [focus core]
 *   Act III — THE SHIFT (truth in the instant) + badges
 *
 * Closing statement:
 *   "Y sé que es así,
 *    porque así es como se accede a la operación real."
 *
 * Interactions (15+):
 *  1) Hover Act II => global focus mode (dims others)
 *  2) Hover Act I => subtle uncertainty distortion overlay
 *  3) Hover Act III => badges glow + scan accent
 *  4) Hover invalid items => animated strike + micro-jitter
 *  5) Hover badges => tooltip with auto-placement
 *  6) Click badge => lock tooltip
 *  7) ESC => clear focus + tooltip lock
 *  8) TAB outlines (auditor-friendly)
 *  9) Enter on badge => lock/unlock tooltip
 * 10) Proximity glow => panel reacts to cursor distance
 * 11) Idle narrative pulse => Act II subtly "breathes" every ~14s
 * 12) Long-hover Act II => caption appears ("This is where systems fail.")
 * 13) Long-hover Act III => caption appears ("This is where evidence begins.")
 * 14) Toggle "Evidence Overlay" => shows evidence markers, no engine explanation
 * 15) Copy-to-clipboard on evidence token click (ID) + toast
 *
 * Motion safety:
 *  - Prefers Reduced Motion honored (kills loops / parallax)
 *
 * Styling:
 *  - Tailwind inline + embedded <style> tokens, like your Slide06
 *
 * IMPORTANT:
 *  - No external CSS, no global changes.
 */

type Placement = "top" | "bottom" | "left" | "right";
type BadgeId = "REAL_TIME" | "TRACEABLE" | "EVIDENCE_READY";
type ActId = "ACT_I" | "ACT_II" | "ACT_III";

type BadgeDef = {
  id: BadgeId;
  label: string;
  sub: string;
  hint: string;
  meta: string[];
  tone: "cyan" | "emerald" | "amber";
};

const cx = (...xs: Array<string | false | null | undefined>) => xs.filter(Boolean).join(" ");

function usePrefersReducedMotion(): boolean {
  const [reduced, setReduced] = useState(false);
  useEffect(() => {
    const mq = window.matchMedia?.("(prefers-reduced-motion: reduce)");
    if (!mq) return;
    const onChange = () => setReduced(!!mq.matches);
    onChange();
    mq.addEventListener?.("change", onChange);
    return () => mq.removeEventListener?.("change", onChange);
  }, []);
  return reduced;
}

function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

function lerp(a: number, b: number, t: number) {
  return a + (b - a) * t;
}

function nowMs() {
  return typeof performance !== "undefined" ? performance.now() : Date.now();
}

function useInterval(callback: () => void, delay: number | null) {
  const cb = useRef(callback);
  useEffect(() => {
    cb.current = callback;
  }, [callback]);

  useEffect(() => {
    if (delay == null) return;
    const id = window.setInterval(() => cb.current(), delay);
    return () => window.clearInterval(id);
  }, [delay]);
}

function useRafLoop(enabled: boolean, cb: (t: number) => void) {
  const rafRef = useRef<number | null>(null);
  const lastRef = useRef<number>(0);

  useEffect(() => {
    if (!enabled) return;
    const loop = (t: number) => {
      rafRef.current = requestAnimationFrame(loop);
      if (t - lastRef.current < 16) return; // ~60fps
      lastRef.current = t;
      cb(t);
    };
    rafRef.current = requestAnimationFrame(loop);
    return () => {
      if (rafRef.current != null) cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
    };
  }, [enabled, cb]);
}

/** Clipboard helper with graceful fallback */
async function copyText(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    try {
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position = "fixed";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return ok;
    } catch {
      return false;
    }
  }
}

const COLORS = {
  BG: "#070A0F",
  CYAN: "#02A7CA",
  TEAL: "#00F5D4",
  GOLD: "#AB7B26",
  EMERALD: "#34D399",
  AMBER: "#F59E0B",
  RED: "#FB7185",
  WHITE: "#EAF2FF",
};

const GLOW = {
  CYAN_A: "drop-shadow-[0_0_10px_rgba(2,167,202,0.20)]",
  CYAN_B: "drop-shadow-[0_0_16px_rgba(2,167,202,0.30)]",
  CYAN_C: "drop-shadow-[0_0_22px_rgba(2,167,202,0.42)]",
  EMERALD_A: "drop-shadow-[0_0_10px_rgba(52,211,153,0.18)]",
  EMERALD_B: "drop-shadow-[0_0_16px_rgba(52,211,153,0.26)]",
  AMBER_A: "drop-shadow-[0_0_10px_rgba(245,158,11,0.18)]",
  AMBER_B: "drop-shadow-[0_0_16px_rgba(245,158,11,0.26)]",
  WHITE_A: "drop-shadow-[0_0_10px_rgba(255,255,255,0.10)]",
  WHITE_B: "drop-shadow-[0_0_18px_rgba(255,255,255,0.16)]",
};

const BADGES: BadgeDef[] = [
  {
    id: "REAL_TIME",
    label: "REAL-TIME",
    sub: "Latency < 1s",
    hint: "See it as it happens — not after.",
    meta: ["Streaming telemetry", "SLA-grade cadence", "No blind windows"],
    tone: "cyan",
  },
  {
    id: "TRACEABLE",
    label: "TRACEABLE",
    sub: "Chain of custody",
    hint: "Every signal has a source, timestamp, and lineage.",
    meta: ["Event lineage", "Source attribution", "Immutable references"],
    tone: "emerald",
  },
  {
    id: "EVIDENCE_READY",
    label: "EVIDENCE-READY",
    sub: "Audit-defensible",
    hint: "Recorded at the moment of occurrence.",
    meta: ["Evidence capsule", "Export-ready", "Defensible records"],
    tone: "amber",
  },
];

const INVALID_SOURCES = [
  { k: "Reports written later", note: "Post-fact narrative" },
  { k: "Opinions", note: "Human variance" },
  { k: "Assumptions", note: "No defensibility" },
];

const BEFORE_BULLETS = [
  "Signals existed",
  "Systems were running",
  "Explanations came after the fact",
];

function toneClasses(tone: BadgeDef["tone"]) {
  if (tone === "cyan") {
    return {
      border: "border-cyan/35 hover:border-cyan/60",
      text: "text-cyan/90",
      glow: "shadow-[0_0_28px_rgba(2,167,202,0.20)]",
      glowHover: "hover:shadow-[0_0_46px_rgba(2,167,202,0.26)]",
      chip: "bg-cyan/12",
      dot: "bg-cyan/70",
      ring: "ring-cyan/25",
      grad: "from-cyan/14 via-cyan/6 to-transparent",
    };
  }
  if (tone === "emerald") {
    return {
      border: "border-emerald-300/25 hover:border-emerald-300/55",
      text: "text-emerald-200/95",
      glow: "shadow-[0_0_28px_rgba(52,211,153,0.16)]",
      glowHover: "hover:shadow-[0_0_46px_rgba(52,211,153,0.22)]",
      chip: "bg-emerald-400/10",
      dot: "bg-emerald-300/70",
      ring: "ring-emerald-300/25",
      grad: "from-emerald-400/14 via-emerald-400/6 to-transparent",
    };
  }
  return {
    border: "border-amber-300/25 hover:border-amber-300/55",
    text: "text-amber-200/95",
    glow: "shadow-[0_0_28px_rgba(245,158,11,0.16)]",
    glowHover: "hover:shadow-[0_0_46px_rgba(245,158,11,0.22)]",
    chip: "bg-amber-400/10",
    dot: "bg-amber-300/70",
    ring: "ring-amber-300/25",
    grad: "from-amber-400/14 via-amber-400/6 to-transparent",
  };
}

/** Tooltip auto placement using bounds + anchor rect */
function computePlacement(
  anchor: DOMRect,
  tipW: number,
  tipH: number,
  bounds?: { width: number; height: number }
): Placement {
  const pad = 12;
  const vw = bounds?.width ?? window.innerWidth;
  const vh = bounds?.height ?? window.innerHeight;

  const topOk = anchor.top - tipH - pad > 0;
  const bottomOk = anchor.bottom + tipH + pad < vh;
  const leftOk = anchor.left - tipW - pad > 0;
  const rightOk = anchor.right + tipW + pad < vw;

  // Prefer bottom, then top, then right, then left — unless blocked
  if (bottomOk) return "bottom";
  if (topOk) return "top";
  if (rightOk) return "right";
  if (leftOk) return "left";
  return "bottom";
}

function placeStyle(
  anchor: DOMRect,
  placement: Placement,
  tipW: number,
  tipH: number,
  bounds?: { width: number; height: number }
): React.CSSProperties {
  const pad = 12;
  const vw = bounds?.width ?? window.innerWidth;
  const vh = bounds?.height ?? window.innerHeight;

  const centerX = anchor.left + anchor.width / 2;
  const centerY = anchor.top + anchor.height / 2;

  let left = 0;
  let top = 0;

  if (placement === "bottom") {
    left = centerX - tipW / 2;
    top = anchor.bottom + pad;
  } else if (placement === "top") {
    left = centerX - tipW / 2;
    top = anchor.top - tipH - pad;
  } else if (placement === "right") {
    left = anchor.right + pad;
    top = centerY - tipH / 2;
  } else {
    left = anchor.left - tipW - pad;
    top = centerY - tipH / 2;
  }

  // clamp into viewport
  left = clamp(left, 10, vw - tipW - 10);
  top = clamp(top, 10, vh - tipH - 10);

  return { left, top };
}

function useLongHover(active: boolean, ms: number) {
  const [long, setLong] = useState(false);
  useEffect(() => {
    if (!active) {
      setLong(false);
      return;
    }
    const id = window.setTimeout(() => setLong(true), ms);
    return () => window.clearTimeout(id);
  }, [active, ms]);
  return long;
}

/** Toast system (simple, local) */
type Toast = { id: string; msg: string; tone: "ok" | "warn" | "err" };
function useToasts() {
  const [toasts, setToasts] = useState<Toast[]>([]);
  const push = (msg: string, tone: Toast["tone"] = "ok") => {
    const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    setToasts((t) => [...t, { id, msg, tone }]);
    window.setTimeout(() => {
      setToasts((t) => t.filter((x) => x.id !== id));
    }, 2400);
  };
  return { toasts, push };
}

function ToastStack({ toasts }: { toasts: Toast[] }) {
  return (
    <div className="absolute right-5 bottom-5 z-[99999] space-y-2">
      {toasts.map((t) => {
        const tone =
          t.tone === "ok"
            ? "border-emerald-300/25 bg-emerald-400/10 text-emerald-100"
            : t.tone === "warn"
            ? "border-amber-300/25 bg-amber-400/10 text-amber-100"
            : "border-rose-300/25 bg-rose-400/10 text-rose-100";
        return (
          <div
            key={t.id}
            className={cx(
              "w-[320px] rounded-xl border px-3 py-2 backdrop-blur-md shadow-[0_0_50px_rgba(0,0,0,0.55)]",
              tone
            )}
          >
            <div className="text-[12px] font-code tracking-[0.18em] opacity-80">SYSTEM</div>
            <div className="mt-1 text-[13px] font-main leading-snug">{t.msg}</div>
          </div>
        );
      })}
    </div>
  );
}

/** Dark-glass surface wrapper (shared) */
function GlassSurface({
  className,
  children,
  sheen = true,
  noise = true,
  innerBorder = true,
  pulse = false,
  tone = "neutral",
}: {
  className?: string;
  children: React.ReactNode;
  sheen?: boolean;
  noise?: boolean;
  innerBorder?: boolean;
  pulse?: boolean;
  tone?: "neutral" | "focus" | "cyan";
}) {
  const toneCls =
    tone === "focus"
      ? "bg-black/45 border-white/10 shadow-[0_40px_120px_rgba(0,0,0,0.45)]"
      : tone === "cyan"
      ? "bg-black/42 border-cyan/18 shadow-[0_34px_110px_rgba(0,0,0,0.46)]"
      : "bg-black/40 border-white/8 shadow-[0_34px_110px_rgba(0,0,0,0.46)]";

  return (
    <div className={cx("relative rounded-2xl border backdrop-blur-xl overflow-hidden", toneCls, className)}>
      {sheen && (
        <div
          className="pointer-events-none absolute inset-0 opacity-[0.55]"
          style={{
            background:
              "radial-gradient(900px 520px at 22% 18%, rgba(255,255,255,0.10) 0%, rgba(255,255,255,0.04) 22%, transparent 60%)",
          }}
        />
      )}
      {innerBorder && (
        <div className="pointer-events-none absolute inset-[1px] rounded-2xl border border-white/10 opacity-[0.55]" />
      )}
      {noise && (
        <svg className="pointer-events-none absolute inset-0 opacity-[0.07]" width="100%" height="100%">
          <filter id="nf">
            <feTurbulence type="fractalNoise" baseFrequency="0.75" numOctaves="3" stitchTiles="stitch" />
          </filter>
          <rect width="100%" height="100%" filter="url(#nf)" />
        </svg>
      )}
      {pulse && <div className="pointer-events-none absolute inset-0 opacity-[0.16] scan-ambient" />}
      {children}
    </div>
  );
}

/** Soft divider line */
function SoftLine({ className }: { className?: string }) {
  return <div className={cx("h-px w-full bg-gradient-to-r from-transparent via-white/10 to-transparent", className)} />;
}

/** Badge tooltip content */
function BadgeTooltip({
  badge,
  placement,
  style,
  locked,
  onClose,
}: {
  badge: BadgeDef;
  placement: Placement;
  style: React.CSSProperties;
  locked: boolean;
  onClose: () => void;
}) {
  const t = toneClasses(badge.tone);
  return (
    <div
      className={cx(
        "absolute z-[99990] w-[340px] rounded-2xl border px-4 py-3 backdrop-blur-xl",
        "bg-black/55 border-white/12 shadow-[0_0_80px_rgba(0,0,0,0.65)]"
      )}
      style={style}
      role="dialog"
      aria-label={`${badge.label} details`}
      data-tooltip="badge"
    >
      <div className="flex items-start justify-between gap-3">
        <div className="min-w-0">
          <div className={cx("text-[12px] font-code tracking-[0.26em] opacity-80", t.text)}>{badge.label}</div>
          <div className="mt-1 text-[14px] font-display font-semibold text-white/92">{badge.sub}</div>
          <div className="mt-2 text-[13px] font-main leading-snug text-white/78">{badge.hint}</div>
        </div>
        {locked && (
          <button
            type="button"
            className="shrink-0 rounded-lg border border-white/10 bg-white/5 px-2 py-1 text-[10px] font-code tracking-[0.24em] text-white/70 hover:text-white"
            onClick={onClose}
          >
            CLOSE
          </button>
        )}
      </div>

      <SoftLine className="my-3 opacity-70" />

      <div className="grid grid-cols-1 gap-2">
        {badge.meta.map((m, idx) => (
          <div key={idx} className="flex items-start gap-2">
            <span className={cx("mt-[7px] h-1.5 w-1.5 rounded-full", t.dot)} />
            <div className="text-[12px] font-code tracking-[0.10em] text-white/70">{m}</div>
          </div>
        ))}
      </div>

      <div className="mt-3 flex items-center justify-between">
        <div className="text-[10px] font-code tracking-[0.26em] text-white/45">PRESS ENTER TO LOCK · ESC TO CLEAR</div>
        <div className={cx("h-6 rounded-full px-2 flex items-center text-[10px] font-code tracking-[0.22em]", t.chip)}>
          VERIFIED
        </div>
      </div>

      <div className={cx("pointer-events-none absolute inset-0 opacity-[0.12]", t.glow)} />
      <div
        className="pointer-events-none absolute inset-0 opacity-[0.20]"
        style={{ background: `linear-gradient(135deg, rgba(255,255,255,0.06), transparent 55%)` }}
      />

      {/* tooltip arrow */}
      <div className="pointer-events-none absolute inset-0">
        <div
          className={cx(
            "absolute h-2.5 w-2.5 rotate-45 border border-white/12 bg-black/55",
            placement === "top"
              ? "left-1/2 bottom-[-6px] -translate-x-1/2 border-t-0 border-l-0"
              : placement === "bottom"
              ? "left-1/2 top-[-6px] -translate-x-1/2 border-b-0 border-r-0"
              : placement === "left"
              ? "right-[-6px] top-1/2 -translate-y-1/2 border-b-0 border-l-0"
              : "left-[-6px] top-1/2 -translate-y-1/2 border-t-0 border-r-0"
          )}
        />
      </div>
    </div>
  );
}

/** Evidence overlay (optional) */
function EvidenceOverlay({
  show,
  reducedMotion,
}: {
  show: boolean;
  reducedMotion: boolean;
}) {
  if (!show) return null;
  return (
    <div className="pointer-events-none absolute inset-0 z-[20]">
      <div className={cx("absolute inset-0 opacity-[0.10]", !reducedMotion && "scan-strong")} />
      <div
        className="absolute inset-0 opacity-[0.09]"
        style={{
          background:
            "radial-gradient(1000px 600px at 50% 35%, rgba(2,167,202,0.11) 0%, rgba(2,167,202,0.05) 28%, transparent 60%)",
        }}
      />
      <div className="absolute left-6 top-6 rounded-xl border border-cyan/20 bg-cyan/8 px-3 py-2 backdrop-blur-md">
        <div className="text-[10px] font-code tracking-[0.26em] text-cyan/85">EVIDENCE OVERLAY</div>
        <div className="mt-1 text-[12px] font-main text-white/70">Markers indicate defensible capture points.</div>
      </div>

      {/* crosshair */}
      <div className="absolute left-1/2 top-1/2 h-[220px] w-[220px] -translate-x-1/2 -translate-y-1/2 opacity-[0.12]">
        <div className="absolute inset-0 rounded-full border border-white/12" />
        <div className="absolute inset-[14px] rounded-full border border-white/10" />
        <div className="absolute left-1/2 top-0 h-full w-px -translate-x-1/2 bg-white/10" />
        <div className="absolute top-1/2 left-0 h-px w-full -translate-y-1/2 bg-white/10" />
      </div>
    </div>
  );
}

/** Small affordance strip */
function AffordanceStrip({
  left,
  right,
}: {
  left: string;
  right: string;
}) {
  return (
    <div className="mt-4 flex items-center justify-between gap-4">
      <div className="text-[10px] font-code tracking-[0.26em] text-white/45">{left}</div>
      <div className="text-[10px] font-code tracking-[0.26em] text-white/45">{right}</div>
    </div>
  );
}

export const Slide04: React.FC<{ nextSlide: () => void; prevSlide: () => void }> = ({
  nextSlide,
  prevSlide,
}) => {
  const reducedMotion = usePrefersReducedMotion();
  const { toasts, push } = useToasts();
  const wowEvidence = WOW_DEMO && WOW_EVIDENCE_IMPACT;
  const wowProofLock = WOW_DEMO && WOW_PROOF_LOCK;

  // Global focus + interactive state
  const [activeAct, setActiveAct] = useState<ActId | null>(null);
  const [lockFocus, setLockFocus] = useState(false);

  // Badge tooltip
  const [hoverBadge, setHoverBadge] = useState<BadgeId | null>(null);
  const [lockedBadge, setLockedBadge] = useState<BadgeId | null>(null);
  const [tipPlacement, setTipPlacement] = useState<Placement>("bottom");
  const [tipStyle, setTipStyle] = useState<React.CSSProperties>({ left: -9999, top: -9999 });

  // Evidence overlay toggle
  const [evidenceOverlay, setEvidenceOverlay] = useState(false);
  const [evidenceFlash, setEvidenceFlash] = useState(false);
  const [proofCommitPulse, setProofCommitPulse] = useState(false);
  const proofPulseTimeout = useStableTimeout();

  // Proximity glow
  const containerRef = useRef<HTMLDivElement | null>(null);
  const [prox, setProx] = useState({ x: 0.5, y: 0.35, a: 0 }); // normalized + intensity
  const proxTarget = useRef(prox);

  // Narrative pulse
  const [narrativePulse, setNarrativePulse] = useState(false);

  // Long-hover captions
  const act2Hover = activeAct === "ACT_II" || lockFocus;
  const act3Hover = activeAct === "ACT_III";
  const act2Long = useLongHover(act2Hover && !reducedMotion, 800);
  const act3Long = useLongHover(act3Hover && !reducedMotion, 800);

  // compute effective focus mode
  const focusOn: ActId | null = lockFocus ? "ACT_II" : activeAct;

  // Idle narrative pulse every ~14s
  useInterval(
    () => {
      if (reducedMotion) return;
      if (lockFocus) return;
      // only pulse if user isn't hovering anything
      if (activeAct != null) return;
      setNarrativePulse(true);
      window.setTimeout(() => setNarrativePulse(false), 900);
    },
    reducedMotion ? null : 14000
  );

  // Keyboard controls: ESC clears lock and tooltip; "E" toggles overlay
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if (e.key === "F1" || e.key === "F2" || e.key === "F3" || e.key === "F4") return;
      if (e.key === "Escape") {
        setLockFocus(false);
        setActiveAct(null);
        setLockedBadge(null);
        setHoverBadge(null);
      }
      if (e.key.toLowerCase() === "e" && (e.ctrlKey || e.metaKey)) {
        // Ctrl/Cmd+E toggles evidence overlay
        e.preventDefault();
        setEvidenceOverlay((v) => !v);
        push("Evidence overlay toggled.", "ok");
      }
      if (e.key === "Enter") {
        // If a badge is hovered, toggle lock
        if (hoverBadge) {
          setLockedBadge((prev) => (prev === hoverBadge ? null : hoverBadge));
        }
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [hoverBadge, push]);

  // Proximity glow: track mouse, smooth with RAF
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;

    const onMove = (ev: MouseEvent) => {
      const r = el.getBoundingClientRect();
      const nx = (ev.clientX - r.left) / r.width;
      const ny = (ev.clientY - r.top) / r.height;
      const dx = nx - 0.5;
      const dy = ny - 0.35;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const a = clamp(1 - dist * 1.35, 0, 1);

      proxTarget.current = { x: clamp(nx, 0, 1), y: clamp(ny, 0, 1), a };
    };

    const onLeave = () => {
      proxTarget.current = { x: 0.5, y: 0.35, a: 0 };
    };

    el.addEventListener("mousemove", onMove);
    el.addEventListener("mouseleave", onLeave);
    return () => {
      el.removeEventListener("mousemove", onMove);
      el.removeEventListener("mouseleave", onLeave);
    };
  }, []);

  useRafLoop(!reducedMotion, () => {
    setProx((p) => {
      const t = proxTarget.current;
      const nx = lerp(p.x, t.x, 0.08);
      const ny = lerp(p.y, t.y, 0.08);
      const na = lerp(p.a, t.a, 0.08);
      return { x: nx, y: ny, a: na };
    });
  });

  // Badge tooltip position update (on hover or lock)
  useLayoutEffect(() => {
    const bid = lockedBadge ?? hoverBadge;
    if (!bid) return;

    const btn = document.querySelector<HTMLButtonElement>(`[data-badge="${bid}"]`);
    if (!btn) return;

    const anchor = btn.getBoundingClientRect();
    const container = containerRef.current;
    const tipW = 340;
    const tipH = 220;

    if (container) {
      const bounds = container.getBoundingClientRect();
      const relAnchor = new DOMRect(
        anchor.left - bounds.left,
        anchor.top - bounds.top,
        anchor.width,
        anchor.height
      );
      const placement = computePlacement(relAnchor, tipW, tipH, { width: bounds.width, height: bounds.height });
      const style = placeStyle(relAnchor, placement, tipW, tipH, { width: bounds.width, height: bounds.height });
      setTipPlacement(placement);
      setTipStyle(style);
      return;
    }

    const placement = computePlacement(anchor, tipW, tipH);
    const style = placeStyle(anchor, placement, tipW, tipH);

    setTipPlacement(placement);
    setTipStyle(style);
  }, [hoverBadge, lockedBadge]);

  // Helper: dims for focus
  const DIM_OTHER =
    focusOn == null
      ? "opacity-100"
      : "opacity-[0.14] blur-[0.7px] saturate-0";

  const DIM_SELF =
    focusOn == null
      ? "opacity-100"
      : "opacity-100";

  const mainBgStyle: React.CSSProperties = useMemo(() => {
    const x = (prox.x * 100).toFixed(2);
    const y = (prox.y * 100).toFixed(2);
    const a = prox.a;

    return {
      background:
        `radial-gradient(900px 560px at ${x}% ${y}%, rgba(2,167,202,${0.10 + 0.12 * a}) 0%, rgba(2,167,202,${0.04 + 0.06 * a}) 22%, transparent 60%),` +
        `radial-gradient(1200px 720px at 50% 35%, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0.02) 22%, transparent 58%),` +
        `linear-gradient(180deg, rgba(7,10,15,1) 0%, rgba(7,10,15,0.98) 100%)`,
    };
  }, [prox]);

  const badgeTooltipBadge = useMemo(() => {
    const id = lockedBadge ?? hoverBadge;
    if (!id) return null;
    return BADGES.find((b) => b.id === id) ?? null;
  }, [hoverBadge, lockedBadge]);

  // click outside tooltip closes lock (avoid accidental close inside)
  useEffect(() => {
    if (!lockedBadge) return;
    const onDown = (e: MouseEvent) => {
      const t = e.target as HTMLElement | null;
      if (!t) return;
      if (t.closest?.('[data-tooltip="badge"]')) return;
      if (t.closest?.("[data-badge]")) return;
      setLockedBadge(null);
    };
    window.addEventListener("mousedown", onDown);
    return () => window.removeEventListener("mousedown", onDown);
  }, [lockedBadge]);

  const onBadgeEnter = (id: BadgeId) => {
    setHoverBadge(id);
    emitTourEvent("evidence:hover", { badge: id });
  };
  const onBadgeLeave = (id: BadgeId) => {
    // If locked, keep it
    if (lockedBadge === id) return;
    setHoverBadge((prev) => (prev === id ? null : prev));
  };

  // Evidence token click (simulate)
  const onEvidenceTokenClick = async () => {
    const token = `EV-${Math.random().toString(16).slice(2, 6).toUpperCase()}-${Math.random()
      .toString(16)
      .slice(2, 6)
      .toUpperCase()}`;
    const ok = await copyText(token);
    if (wowEvidence) {
      setEvidenceFlash(true);
      window.setTimeout(() => setEvidenceFlash(false), 560);
    }
    if (wowProofLock) {
      setProofCommitPulse(true);
      proofPulseTimeout.schedule(() => setProofCommitPulse(false), 640);
    }
    emitTourEvent("evidence:copied", { tokenCopied: ok });
    push(ok ? `Evidence token copied: ${token}` : `Could not copy token: ${token}`, ok ? "ok" : "warn");
  };

  const onBadgeLockToggle = (id: BadgeId) => {
    setLockedBadge((prev) => {
      const next = prev === id ? null : id;
      if (next) emitTourEvent("evidence:locked", { badge: id });
      return next;
    });
  };

  // Act container handlers
  const setAct = (id: ActId | null) => {
    if (lockFocus) return;
    setActiveAct(id);
  };

  const toggleLockFocus = () => {
    // Lock always centers on Act II (the question)
    setLockFocus((v) => !v);
    setActiveAct(null);
    if (wowProofLock) {
      setProofCommitPulse(true);
      proofPulseTimeout.schedule(() => setProofCommitPulse(false), 640);
    }
  };

  const selectedEvidence = hoverBadge ?? lockedBadge;

  return (
    <div data-testid="slide-04-root" className="w-full h-full">
      <SlideContainer>
      <style>{`
        /* ===========================================================
           NASA SYSTEM — Motion + Glass + Scanlines + Noise
           =========================================================== */

        @keyframes scanAmbient {
          0% { transform: translateY(-14px); opacity: 0.0; }
          10% { opacity: 0.15; }
          50% { opacity: 0.18; }
          100% { transform: translateY(14px); opacity: 0.0; }
        }
        .scan-ambient {
          background: repeating-linear-gradient(
            180deg,
            rgba(255,255,255,0.06) 0px,
            rgba(255,255,255,0.06) 1px,
            transparent 1px,
            transparent 6px
          );
          animation: scanAmbient 6.5s linear infinite;
        }

        @keyframes scanStrong {
          0% { transform: translateY(-18px); opacity: 0.0; }
          20% { opacity: 0.22; }
          50% { opacity: 0.26; }
          100% { transform: translateY(18px); opacity: 0.0; }
        }
        .scan-strong {
          background: repeating-linear-gradient(
            180deg,
            rgba(2,167,202,0.10) 0px,
            rgba(2,167,202,0.10) 1px,
            transparent 1px,
            transparent 7px
          );
          animation: scanStrong 5.2s linear infinite;
        }

        @keyframes badgeBreath {
          0%, 100% { filter: brightness(1); transform: translateY(0px); }
          50% { filter: brightness(1.08); transform: translateY(-1px); }
        }
        .badge-breath {
          animation: badgeBreath 7.2s ease-in-out infinite;
        }

        @keyframes strikeDraw {
          0% { transform: scaleX(0); opacity: 0.0; }
          35% { opacity: 0.7; }
          100% { transform: scaleX(1); opacity: 0.9; }
        }
        .strike-draw {
          transform-origin: left;
          animation: strikeDraw 360ms ease-out both;
        }

        @keyframes microJitter {
          0% { transform: translateX(0px); }
          20% { transform: translateX(-0.5px); }
          40% { transform: translateX(0.6px); }
          60% { transform: translateX(-0.4px); }
          80% { transform: translateX(0.4px); }
          100% { transform: translateX(0px); }
        }
        .micro-jitter {
          animation: microJitter 240ms ease-out;
        }

        @keyframes narrativePulse {
          0% { box-shadow: 0 0 0 rgba(2,167,202,0.0); }
          50% { box-shadow: 0 0 60px rgba(2,167,202,0.12); }
          100% { box-shadow: 0 0 0 rgba(2,167,202,0.0); }
        }
        .narrative-pulse {
          animation: narrativePulse 900ms ease-out;
        }

        @keyframes wowEvidencePulse {
          0% { opacity: 0; transform: scale(0.985); }
          50% { opacity: 1; }
          100% { opacity: 0; transform: scale(1); }
        }
        .wow-evidence-pulse {
          animation: wowEvidencePulse 540ms cubic-bezier(.2,.8,.2,1);
        }

        @keyframes proofCommitCeremony {
          0% { opacity: 0; transform: scale(0.985); }
          30% { opacity: 1; }
          100% { opacity: 0; transform: scale(1); }
        }
        .proof-commit-pulse {
          animation: proofCommitCeremony 640ms cubic-bezier(.2,.8,.2,1);
        }

        @keyframes softGlowSweep {
          0% { transform: translateX(-40%); opacity: 0.0; }
          20% { opacity: 0.10; }
          60% { opacity: 0.10; }
          100% { transform: translateX(40%); opacity: 0.0; }
        }
        .soft-sweep::after {
          content: "";
          position: absolute;
          inset: -20%;
          background: linear-gradient(90deg, transparent, rgba(255,255,255,0.08), transparent);
          transform: translateX(-40%);
          animation: softGlowSweep 8.6s ease-in-out infinite;
          pointer-events: none;
        }

        /* Uncertainty overlay (Act I hover) */
        @keyframes uncertainty {
          0% { opacity: 0.0; transform: translateY(0px); }
          50% { opacity: 0.16; transform: translateY(1px); }
          100% { opacity: 0.0; transform: translateY(0px); }
        }
        .uncertainty {
          background: repeating-linear-gradient(
            90deg,
            rgba(255,255,255,0.06) 0px,
            rgba(255,255,255,0.06) 1px,
            transparent 1px,
            transparent 10px
          );
          animation: uncertainty 1.8s ease-in-out infinite;
        }

        /* Nice keyboard focus that doesn't look ugly */
        .a11y-focus:focus-visible {
          outline: none;
          box-shadow: 0 0 0 2px rgba(2,167,202,0.28), 0 0 0 6px rgba(2,167,202,0.10);
        }

        /* Reduced motion overrides */
        @media (prefers-reduced-motion: reduce) {
          .scan-ambient, .scan-strong, .badge-breath, .soft-sweep::after, .uncertainty {
            animation: none !important;
          }
        }
      `}</style>

      {/* Background master - ADDED pointer-events-none */}
      <div className="absolute inset-0 pointer-events-none" style={mainBgStyle} />

      {/* Ambient vignette + subtle grain */}
      <div
        className="pointer-events-none absolute inset-0 opacity-[0.80]"
        style={{
          background:
            "radial-gradient(1400px 900px at 50% 35%, transparent 0%, rgba(0,0,0,0.40) 60%, rgba(0,0,0,0.70) 100%)",
        }}
      />
      <svg className="pointer-events-none absolute inset-0 opacity-[0.06]" width="100%" height="100%">
        <filter id="bgNoise">
          <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch" />
        </filter>
        <rect width="100%" height="100%" filter="url(#bgNoise)" />
      </svg>

      <Header title="PROPUESTA DE VALOR" breadcrumb="SOLUCIÓN" slideNum={5} />

      {/* Layout wrapper */}
      <div ref={containerRef} className={`relative h-full w-full px-16 pt-4 pb-10 ${wowEvidence ? "wow-s04-evidence" : ""}`}>
        {wowProofLock && selectedEvidence && (
          <div
            className="pointer-events-none absolute inset-0 z-[26]"
            style={{
              background: "radial-gradient(920px 640px at 74% 42%, rgba(0,0,0,0.02), rgba(0,0,0,0.44) 72%)",
            }}
          />
        )}
        {/* Top header line (right tag) */}
        <div className="absolute right-16 top-[92px] z-[5] flex items-center gap-2">
          <div className="h-2 w-2 rounded-full bg-cyan/60 shadow-[0_0_16px_rgba(2,167,202,0.20)]" />
          <div className="text-[11px] font-code tracking-[0.32em] text-white/60">AUDIT-PROOF REALITY</div>
        </div>

        {/* MAIN GRID */}
        <div className="relative mt-[118px] grid grid-cols-12 gap-6 h-[792px]">
          {/* Act I */}
          <div
            className={cx("col-span-4 transition-all duration-200", focusOn && focusOn !== "ACT_I" ? DIM_OTHER : DIM_SELF)}
            onMouseEnter={() => setAct("ACT_I")}
            onMouseLeave={() => setAct(null)}
          >
            <GlassSurface
              className={cx("h-full p-10 soft-sweep", focusOn === "ACT_I" && "shadow-[0_0_70px_rgba(255,255,255,0.06)]")}
              tone="neutral"
              pulse={!reducedMotion}
            >
              <div className="relative z-[2]">
                <div className="text-[12px] font-code tracking-[0.28em] text-white/55">BEFORE</div>
                <div className={cx("mt-2 text-[24px] font-display font-semibold text-white/92", GLOW.WHITE_A)}>
                  OPERATION AS A BLACK BOX
                </div>

                <div className="mt-5 space-y-3">
                  {BEFORE_BULLETS.map((b, i) => (
                    <div key={i} className="flex items-start gap-3">
                      <span className="mt-[7px] h-1.5 w-1.5 rounded-full bg-white/35" />
                      <div className="text-[14px] font-main leading-snug text-white/72">{b}</div>
                    </div>
                  ))}
                </div>

                <SoftLine className="my-6 opacity-70" />

                <div className="text-[12px] font-main text-white/60">
                  Data existed, but truth was fragmented.
                </div>

                <AffordanceStrip left="HOVER: reveal uncertainty" right="TAB: move focus" />
              </div>

              {/* Uncertainty layer on hover */}
              <div
                className={cx(
                  "pointer-events-none absolute inset-0 opacity-0 transition-opacity duration-200",
                  activeAct === "ACT_I" && !reducedMotion && "opacity-100"
                )}
              >
                <div className="absolute inset-0 uncertainty" />
                <div
                  className="absolute inset-0 opacity-[0.18]"
                  style={{
                    background:
                      "radial-gradient(700px 420px at 40% 22%, rgba(255,255,255,0.12) 0%, transparent 60%)",
                  }}
                />
              </div>
            </GlassSurface>
          </div>

          {/* Act II (core) */}
          <div
            className={cx("col-span-4 transition-all duration-200", focusOn && focusOn !== "ACT_II" ? DIM_OTHER : DIM_SELF)}
            onMouseEnter={() => setAct("ACT_II")}
            onMouseLeave={() => setAct(null)}
          >
            <GlassSurface
              className={cx(
                "h-full p-14 relative",
                "border-white/14",
                narrativePulse && "narrative-pulse",
                (activeAct === "ACT_II" || lockFocus) && "shadow-[0_0_90px_rgba(2,167,202,0.14)]"
              )}
              tone="focus"
              pulse={!reducedMotion}
            >
              <div className="relative z-[3]">
                <div className="flex items-center justify-between">
                  <div className="text-[12px] font-code tracking-[0.30em] text-white/65">THE QUESTION</div>

                  <button
                    type="button"
                    className={cx(
                      "a11y-focus rounded-xl border px-3 py-2 text-[10px] font-code tracking-[0.26em] transition-all",
                      lockFocus
                        ? "border-cyan/40 bg-cyan/10 text-cyan/85 shadow-[0_0_24px_rgba(2,167,202,0.16)]"
                        : "border-white/10 bg-white/5 text-white/55 hover:text-white/80 hover:border-white/18"
                    )}
                    onClick={toggleLockFocus}
                    aria-label="Toggle focus lock"
                  >
                    {lockFocus ? "FOCUS LOCKED" : "LOCK FOCUS"}
                  </button>
                </div>

                <div className={cx("mt-6 text-[30px] font-display font-semibold leading-tight text-white/92", GLOW.WHITE_B)}>
                  Si me preguntas cómo sé esto…
                </div>

                <div className="mt-6">
                  <div className="text-[12px] font-code tracking-[0.26em] text-white/50">THE WRONG SOURCES</div>

                  <div className="mt-3 space-y-3">
                    {INVALID_SOURCES.map((s, idx) => {
                      const hovering = activeAct === "ACT_II" && !lockFocus;
                      return (
                        <div
                          key={idx}
                          className={cx(
                            "relative rounded-xl border border-white/10 bg-white/3 px-4 py-3 backdrop-blur-md",
                            "transition-all duration-200"
                          )}
                          onMouseEnter={() => setAct("ACT_II")}
                        >
                          <div className="flex items-center justify-between gap-3">
                            <div className="min-w-0">
                              <div className="text-[13px] font-main text-white/70">{s.k}</div>
                              <div className="mt-1 text-[11px] font-code tracking-[0.16em] text-white/45">{s.note}</div>
                            </div>

                            <div className="shrink-0 text-[10px] font-code tracking-[0.28em] text-rose-200/70">
                              INVALID
                            </div>
                          </div>

                          {/* strike-through on hover */}
                          <div
                            className={cx(
                              "pointer-events-none absolute left-3 right-3 top-1/2 h-px -translate-y-1/2 bg-rose-300/30 opacity-0",
                              hovering && "opacity-100 strike-draw"
                            )}
                          />
                        </div>
                      );
                    })}
                  </div>

                  <div
                    className={cx(
                      "mt-6 text-[12px] font-main text-white/62",
                      (activeAct === "ACT_II" || lockFocus) && "micro-jitter"
                    )}
                  >
                    None of them are defensible.
                  </div>

                  <AffordanceStrip
                    left="HOVER: focus · CLICK: lock"
                    right="ESC: clear · Ctrl/Cmd+E: evidence overlay"
                  />

                  {act2Long && (
                    <div className="mt-5 rounded-xl border border-white/10 bg-white/4 px-4 py-3">
                      <div className="text-[10px] font-code tracking-[0.30em] text-white/55">EXECUTIVE REALITY</div>
                      <div className="mt-2 text-[13px] font-main text-white/70">
                        This is where systems fail — not technically, but defensibly.
                      </div>
                    </div>
                  )}
                </div>
              </div>

              {/* Focus bloom */}
              <div
                className={cx(
                  "pointer-events-none absolute inset-0 opacity-[0.18]",
                  (activeAct === "ACT_II" || lockFocus) ? "scan-strong" : "scan-ambient"
                )}
              />
              <div
                className="pointer-events-none absolute inset-0 opacity-[0.22]"
                style={{
                  background:
                    "radial-gradient(900px 620px at 50% 30%, rgba(2,167,202,0.14) 0%, rgba(2,167,202,0.06) 26%, transparent 60%)",
                }}
              />
            </GlassSurface>
          </div>

          {/* Act III */}
          <div
            className={cx("col-span-4 transition-all duration-200", focusOn && focusOn !== "ACT_III" ? DIM_OTHER : DIM_SELF)}
            onMouseEnter={() => setAct("ACT_III")}
            onMouseLeave={() => setAct(null)}
          >
            <GlassSurface
              className={cx("h-full p-10 relative soft-sweep", activeAct === "ACT_III" && "shadow-[0_0_90px_rgba(2,167,202,0.12)]")}
              tone="cyan"
              pulse={!reducedMotion}
            >
              <div className="relative z-[3]">
                <div className="text-[12px] font-code tracking-[0.30em] text-white/65">THE SHIFT</div>

                <div className={cx("mt-3 text-[24px] font-display font-semibold leading-snug text-white/92", GLOW.CYAN_B)}>
                  — Porque lo vi cuando pasó.
                </div>

                <div className="mt-5 text-[12px] font-main text-white/66">
                  Operational truth, generated at the moment of occurrence.
                </div>

                <SoftLine className="my-6 opacity-70" />

                <div className="flex flex-wrap gap-3">
                  {BADGES.map((b) => {
                    const t = toneClasses(b.tone);
                    const isLocked = lockedBadge === b.id;
                    const isHovering = hoverBadge === b.id;
                    const on = isLocked || isHovering || activeAct === "ACT_III";

                    return (
                      <button
                        key={b.id}
                        type="button"
                        className={cx(
                          "a11y-focus group relative rounded-2xl border px-4 py-3 text-left transition-all duration-200",
                          "bg-black/28 backdrop-blur-md",
                          wowEvidence && "hover:-translate-y-[2px] hover:scale-[1.01]",
                          t.border,
                          t.glow,
                          t.glowHover,
                          on && "badge-breath",
                          wowProofLock && on && "shadow-[0_0_42px_rgba(2,167,202,0.28)]",
                          isLocked && "ring-1 " + t.ring
                        )}
                        data-badge={b.id}
                        onMouseEnter={() => onBadgeEnter(b.id)}
                        onMouseLeave={() => onBadgeLeave(b.id)}
                        onClick={() => onBadgeLockToggle(b.id)}
                        aria-label={`${b.label} badge`}
                      >
                        <div className="flex items-center justify-between gap-3">
                          <div className="min-w-0">
                            <div className={cx("text-[11px] font-code tracking-[0.28em]", t.text)}>{b.label}</div>
                            <div className="mt-1 text-[13px] font-display font-semibold text-white/92">{b.sub}</div>
                          </div>
                          <div className={cx("h-8 w-8 rounded-xl border border-white/10 bg-white/5 flex items-center justify-center")}>
                            <div className={cx("h-2 w-2 rounded-full", t.dot)} />
                          </div>
                        </div>

                        <div
                          className="pointer-events-none absolute inset-0 opacity-[0.20]"
                          style={{
                            background: `radial-gradient(220px 140px at 30% 20%, rgba(255,255,255,0.10) 0%, transparent 62%)`,
                          }}
                        />
                        <div className={cx("pointer-events-none absolute inset-0 opacity-[0.12]", t.glow)} />
                      </button>
                    );
                  })}
                </div>

                <AffordanceStrip
                  left="HOVER: details · ENTER: lock tooltip"
                  right="CLICK badge: lock · ESC: clear"
                />

                {/* Evidence token row */}
                <div className="mt-7 rounded-xl border border-white/10 bg-white/4 px-4 py-3">
                  <div className="flex items-center justify-between gap-3">
                    <div className="min-w-0">
                      <div className="text-[10px] font-code tracking-[0.30em] text-white/55">EVIDENCE TOKEN</div>
                      <div className="mt-1 text-[12px] font-code tracking-[0.18em] text-white/70">
                        Click to copy a defensible reference
                      </div>
                    </div>
                    <button
                      type="button"
                      data-testid="s04-copy-token"
                      className="a11y-focus rounded-xl border border-white/10 bg-white/5 px-3 py-2 text-[10px] font-code tracking-[0.26em] text-white/70 hover:text-white"
                      onClick={onEvidenceTokenClick}
                    >
                      COPY
                    </button>
                  </div>
                </div>

                {act3Long && (
                  <div className="mt-5 rounded-xl border border-white/10 bg-white/4 px-4 py-3">
                    <div className="text-[10px] font-code tracking-[0.30em] text-white/55">SYSTEM CONSEQUENCE</div>
                    <div className="mt-2 text-[13px] font-main text-white/70">
                      This is where evidence begins — automatically, continuously, defensibly.
                    </div>
                  </div>
                )}
              </div>

              {/* Badge halo on hover */}
              <div
                className={cx(
                  "pointer-events-none absolute inset-0 opacity-0 transition-opacity duration-200",
                  activeAct === "ACT_III" && "opacity-100"
                )}
              >
                <div className={cx("absolute inset-0", !reducedMotion ? "scan-ambient" : "")} />
                <div
                  className="absolute inset-0 opacity-[0.20]"
                  style={{
                    background:
                      "radial-gradient(900px 620px at 62% 34%, rgba(2,167,202,0.12) 0%, rgba(2,167,202,0.05) 28%, transparent 60%)",
                  }}
                />
              </div>
            </GlassSurface>
          </div>

          {/* Evidence overlay (on top of grid) */}
          <EvidenceOverlay show={evidenceOverlay} reducedMotion={reducedMotion} />

          {/* Soft global dim when focus lock on (acts behind feel distant) */}
          {(lockFocus || lockedBadge) && (
            <div
              className="absolute inset-0 z-[50] pointer-events-none"
              style={{
                background:
                  "radial-gradient(1200px 820px at 50% 35%, rgba(0,0,0,0.18) 0%, rgba(0,0,0,0.48) 55%, rgba(0,0,0,0.68) 100%)",
                opacity: 1,
              }}
            />
          )}
        </div>

        {/* STATEMENT FINAL - ADDED pointer-events-none */}
        <div className="mt-6 relative z-[10] pointer-events-none">
          <div className="mx-auto max-w-[1100px] text-center">
            <div className="text-[16px] font-main leading-relaxed text-white/65">
              Y sé que es así,
              <br />
              porque así es como se accede a la operación real.
            </div>
            <div className="mt-3 text-[10px] font-code tracking-[0.28em] text-white/38">
              Operational truth, in real time · No reports written after the fact
            </div>
          </div>

          {/* Micro controls row - ADDED pointer-events-auto */}
          <div className="mt-4 flex items-center justify-center gap-3 pointer-events-auto">
            <button
              type="button"
              className={cx(
                "a11y-focus rounded-xl border px-3 py-2 text-[10px] font-code tracking-[0.26em] transition-all",
                evidenceOverlay
                  ? "border-cyan/35 bg-cyan/10 text-cyan/85 shadow-[0_0_22px_rgba(2,167,202,0.16)]"
                  : "border-white/10 bg-white/5 text-white/55 hover:text-white/80 hover:border-white/18"
              )}
                    onClick={() => setEvidenceOverlay((v) => !v)}
                  >
              {evidenceOverlay ? "EVIDENCE OVERLAY: ON" : "EVIDENCE OVERLAY: OFF"}
            </button>

            <button
              type="button"
              className={cx(
                "a11y-focus rounded-xl border px-3 py-2 text-[10px] font-code tracking-[0.26em] transition-all",
                lockFocus
                  ? "border-cyan/35 bg-cyan/10 text-cyan/85 shadow-[0_0_22px_rgba(2,167,202,0.16)]"
                  : "border-white/10 bg-white/5 text-white/55 hover:text-white/80 hover:border-white/18"
              )}
              onClick={toggleLockFocus}
            >
              {lockFocus ? "FOCUS MODE: LOCKED" : "FOCUS MODE: AUTO"}
            </button>

            <button
              type="button"
              className="a11y-focus rounded-xl border border-white/10 bg-white/5 px-3 py-2 text-[10px] font-code tracking-[0.26em] text-white/55 hover:text-white/80 hover:border-white/18"
              onClick={() => {
                setActiveAct(null);
                setLockFocus(false);
                setLockedBadge(null);
                setHoverBadge(null);
                push("Cleared focus and locks.", "ok");
              }}
            >
              CLEAR
            </button>
          </div>
        </div>
      {wowEvidence && evidenceFlash && (
        <div className="pointer-events-none absolute inset-0 z-[60] wow-evidence-pulse">
          <div className="absolute inset-[18%] rounded-[28px] border border-cyan/35 shadow-[0_0_80px_rgba(2,167,202,0.22)]" />
          <div className="absolute inset-0 opacity-[0.16]" style={{ background: "radial-gradient(900px 500px at 50% 50%, rgba(2,167,202,0.22), transparent 70%)" }} />
        </div>
      )}
      {wowProofLock && proofCommitPulse && (
        <div className="pointer-events-none absolute inset-0 z-[61] proof-commit-pulse">
          <div className="absolute inset-[20%] rounded-[24px] border border-emerald-300/30 shadow-[0_0_70px_rgba(52,211,153,0.22)]" />
          <div className="absolute inset-0 opacity-[0.18]" style={{ background: "radial-gradient(700px 360px at 50% 58%, rgba(52,211,153,0.24), transparent 72%)" }} />
        </div>
      )}
      {/* Badge tooltip (hover or locked) */}
      {badgeTooltipBadge && (
        <BadgeTooltip
          badge={badgeTooltipBadge}
          placement={tipPlacement}
          style={tipStyle}
          locked={!!lockedBadge}
          onClose={() => setLockedBadge(null)}
        />
      )}
      </div>

      {/* Toasts */}
      <ToastStack toasts={toasts} />

      {/* NavArea - WRAPPED in z-100 */}
        <div className="relative z-[100] pointer-events-auto">
          <NavArea prev={prevSlide} next={nextSlide} />
        </div>
      </SlideContainer>
    </div>
  );
};
```

===== FILE: tests/e2e/deck-smoke-00-04.e2e.spec.ts =====
```tsx
import { expect, test } from "@playwright/test";

test("deck nav smoke: Slide00 to Slide04 and back to Slide03", async ({ page }) => {
  await page.goto("/slides/00");

  await expect(page.getByTestId("slide-00-root")).toBeVisible();
  await expect(page.getByTestId("nav-prev")).toBeDisabled();
  await expect(page.getByTestId("nav-current-index")).toHaveText("00");
  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-00");

  await page.getByTestId("nav-next").click();
  await expect(page.getByTestId("slide-01-root")).toBeVisible();
  await expect(page.getByTestId("nav-current-index")).toHaveText("01");
  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-01");

  await page.getByTestId("nav-next").click();
  await expect(page.getByTestId("slide-02-root")).toBeVisible();
  await expect(page.getByTestId("nav-current-index")).toHaveText("02");
  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-02");

  await page.getByTestId("nav-next").click();
  await expect(page.getByTestId("slide-03-root")).toBeVisible();
  await expect(page.getByTestId("nav-current-index")).toHaveText("03");
  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-03");

  await page.getByTestId("nav-next").click();
  await expect(page.getByTestId("slide-04-root")).toBeVisible();
  await expect(page.getByTestId("nav-current-index")).toHaveText("04");
  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-04");
  await expect(page.getByTestId("nav-next")).toBeDisabled();

  await page.getByTestId("nav-prev").click();
  await expect(page.getByTestId("slide-03-root")).toBeVisible();
  await expect(page.getByTestId("nav-current-index")).toHaveText("03");
  await expect(page.getByTestId("nav-current-id")).toHaveText("slide-03");
});
```

===== FILE: tests/e2e/deck.playwright.config.ts =====
```tsx
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: ".",
  testMatch: ["deck-smoke-00-04.e2e.spec.ts"],
  timeout: 30000,
  expect: { timeout: 5000 },
  fullyParallel: false,
  retries: 0,
  workers: 1,
  use: {
    baseURL: "http://127.0.0.1:3290",
    headless: true,
  },
  webServer: {
    command: "node ./node_modules/vite/bin/vite.js --host 127.0.0.1 --port 3290 --strictPort",
    cwd: process.cwd(),
    url: "http://127.0.0.1:3290",
    reuseExistingServer: false,
    timeout: 120000,
  },
});
```
