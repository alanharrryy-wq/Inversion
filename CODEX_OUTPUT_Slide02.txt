INVERSION · CODEX AGENT #2 · Slide02 Output
Generated: 2026-02-10

## SUMMARY
- Slide02 rebuilt as thin wrapper + modular slide02-ui runtime.
- Deterministic model/reducer/replay/context implementation added.
- Unit suites added and passing via tsx runner.
- Typecheck and build pass.
- Slide02 Playwright smoke spec added (execution blocked by occupied port 3200 and e2e run cap).
- Total lines across in-scope files: 5499

## FILE LIST
- components/slides/Slide02.tsx
- components\slides\slide02-ui\core\context.spec.ts
- components\slides\slide02-ui\core\context.ts
- components\slides\slide02-ui\core\fixtures.ts
- components\slides\slide02-ui\core\fsm.spec.ts
- components\slides\slide02-ui\core\fsm.ts
- components\slides\slide02-ui\core\index.ts
- components\slides\slide02-ui\core\model.spec.ts
- components\slides\slide02-ui\core\model.ts
- components\slides\slide02-ui\core\replay.spec.ts
- components\slides\slide02-ui\core\replay.ts
- components\slides\slide02-ui\core\run-slide02-unit.ts
- components\slides\slide02-ui\core\selectors.ts
- components\slides\slide02-ui\core\test-utils.ts
- components\slides\slide02-ui\core\types.ts
- components\slides\slide02-ui\core\useSlide02Machine.ts
- components\slides\slide02-ui\index.ts
- components\slides\slide02-ui\styles.css
- components\slides\slide02-ui\ui\ControlsPanel.tsx
- components\slides\slide02-ui\ui\EvidencePanel.tsx
- components\slides\slide02-ui\ui\HudToggle.tsx
- components\slides\slide02-ui\ui\index.ts
- components\slides\slide02-ui\ui\ReplayPanel.tsx
- components\slides\slide02-ui\ui\Scene.tsx
- docs\slide02\00-contract.md
- docs\slide02\REPORT.md
- tests/e2e/slide02-bridge-smoke.e2e.spec.ts

## COMMAND LOG (EXCERPT)
- npm ci => PASS
- npx tsx components/slides/slide02-ui/core/run-slide02-unit.ts => PASS
- npm run typecheck => PASS
- npm run build => PASS
- npx playwright test tests/e2e/slide02-bridge-smoke.e2e.spec.ts => FAIL (port 3200 already used)
- npx playwright test tests/e2e/slide02-bridge-smoke.e2e.spec.ts => FAIL (port 3200 already used)

## GIT DIFF
diff --git a/components/slides/Slide02.tsx b/components/slides/Slide02.tsx
index f11d22c..b65b58c 100644
--- a/components/slides/Slide02.tsx
+++ b/components/slides/Slide02.tsx
@@ -1,72 +1,30 @@
-import React, { useState } from "react";
-import { SlideContainer, Header, NavArea } from "../SlideRenderer";
-
-export const Slide02: React.FC<{ nextSlide: () => void; prevSlide: () => void }> = ({
-  nextSlide,
-  prevSlide,
-}) => {
-  const [sliderVal, setSliderVal] = useState(95);
-
-  return (
-    <SlideContainer>
-      <Header title="INSIGHT" breadcrumb="ORIGEN" slideNum={3} />
-
-      <div className="flex flex-col h-full justify-center">
-        <div className="w-full h-full max-h-[500px] relative select-none animate-fade-up border border-white/20 rounded-xl overflow-hidden group">
-          <div className="absolute inset-0 bg-[#050505] flex items-center justify-center z-0">
-            <div className="absolute inset-0 opacity-20 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-cyan/20 to-transparent" />
-            <div className="text-center z-10">
-              <h3 className="text-6xl font-display font-black text-white drop-shadow-[0_0_20px_rgba(0,240,255,0.5)] mb-2">
-                SISTEMA
-              </h3>
-              <p className="text-xl text-cyan font-code tracking-[8px]">HITECH RTS</p>
-            </div>
-          </div>
-
-          <div
-            className="absolute inset-0 bg-red-950 flex items-center justify-center overflow-hidden border-r-4 border-gold shadow-[10px_0_50px_rgba(0,0,0,0.8)] z-10"
-            style={{ width: `${sliderVal}%` }}
-          >
-            <div className="absolute inset-0 opacity-10 pointer-events-none mix-blend-overlay z-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')]" />
-            <div className="w-screen max-w-[1600px] h-full flex items-center justify-center relative z-10">
-              <div className="text-center">
-                <h3 className="text-6xl font-display font-black text-red-500 line-through decoration-white/50 decoration-4 mb-2 drop-shadow-[0_4px_0_rgba(0,0,0,1)]">
-                  CAOS
-                </h3>
-                <p className="text-xl text-white font-code tracking-[8px] font-bold drop-shadow-md">
-                  MODO SUPERVIVENCIA
-                </p>
-              </div>
-            </div>
-          </div>
-
-          <input
-            type="range"
-            min="0"
-            max="100"
-            value={sliderVal}
-            onChange={(e) => setSliderVal(Number(e.target.value))}
-            className="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-50"
-          />
-
-          <div
-            className="absolute top-1/2 -translate-y-1/2 w-10 h-10 bg-white rounded-full shadow-[0_0_20px_rgba(255,255,255,0.5)] flex items-center justify-center pointer-events-none z-40 transition-transform duration-75"
-            style={{ left: `calc(${sliderVal}% - 20px)` }}
-          >
-            <svg viewBox="0 0 24 24" className="w-5 h-5">
-              <path d="M14 6l6 6-6 6M10 6L4 12l6 6" fill="none" stroke="black" strokeWidth="2" />
-            </svg>
-          </div>
-
-          <div className="absolute bottom-4 left-0 w-full text-center pointer-events-none z-30">
-            <span className="bg-black/50 px-3 py-1 rounded text-white font-code text-xs border border-white/20 tracking-widest">
-              DESLIZA PARA EVOLUCIONAR
-            </span>
-          </div>
-        </div>
-      </div>
-
-      <NavArea prev={prevSlide} next={nextSlide} />
-    </SlideContainer>
-  );
-};
+import React from "react";
+import { Header, NavArea, SlideContainer } from "../SlideRenderer";
+import { Scene } from "./slide02-ui";
+
+type Slide02Props = {
+  nextSlide: () => void;
+  prevSlide: () => void;
+};
+
+export const Slide02: React.FC<Slide02Props> = ({ nextSlide, prevSlide }) => {
+  return (
+    <SlideContainer>
+      <Header title="PUENTE OPERATIVO" breadcrumb="SISTEMA" slideNum={3} />
+
+      <Scene
+        uiStrings={{
+          heading: "Bridge: Constraint Tightening",
+          subheading:
+            "Compact continuity layer from selected route into deterministic system evidence.",
+          hint:
+            "Adjust the controls to tighten constraints. Panels update instantly from reducer output.",
+          replayHint:
+            "Replay capture/playback is deterministic and does not depend on timers or random input.",
+        }}
+      />
+
+      <NavArea prev={prevSlide} next={nextSlide} />
+    </SlideContainer>
+  );
+};

## FULL FILE CONTENTS

### FILE: components/slides/Slide02.tsx
```
import React from "react";
import { Header, NavArea, SlideContainer } from "../SlideRenderer";
import { Scene } from "./slide02-ui";

type Slide02Props = {
  nextSlide: () => void;
  prevSlide: () => void;
};

export const Slide02: React.FC<Slide02Props> = ({ nextSlide, prevSlide }) => {
  return (
    <SlideContainer>
      <Header title="PUENTE OPERATIVO" breadcrumb="SISTEMA" slideNum={3} />

      <Scene
        uiStrings={{
          heading: "Bridge: Constraint Tightening",
          subheading:
            "Compact continuity layer from selected route into deterministic system evidence.",
          hint:
            "Adjust the controls to tighten constraints. Panels update instantly from reducer output.",
          replayHint:
            "Replay capture/playback is deterministic and does not depend on timers or random input.",
        }}
      />

      <NavArea prev={prevSlide} next={nextSlide} />
    </SlideContainer>
  );
};
```

### FILE: components\slides\slide02-ui\core\context.spec.ts
```
import { strict as assert } from "node:assert";
import {
  ensureRouteOrDefault,
  exportSeedSummary,
  resolveSlide02SeedContext,
  routeIdToHuman,
  routeSourceLabel,
  sanitizeRouteForReplay,
  Slide02ContextInput,
} from "./context";
import { createDefaultSeedContext } from "./model";
import { runSuite, expectStringContains } from "./test-utils";

type FakeStorageData = Record<string, string>;

class FakeStorage implements Storage {
  private data: FakeStorageData;

  constructor(seed: FakeStorageData = {}) {
    this.data = { ...seed };
  }

  get length(): number {
    return Object.keys(this.data).length;
  }

  clear(): void {
    this.data = {};
  }

  getItem(key: string): string | null {
    return Object.prototype.hasOwnProperty.call(this.data, key) ? this.data[key] : null;
  }

  key(index: number): string | null {
    const keys = Object.keys(this.data);
    return keys[index] ?? null;
  }

  removeItem(key: string): void {
    delete this.data[key];
  }

  setItem(key: string, value: string): void {
    this.data[key] = value;
  }
}

function withWindowMock<T>(mockWindow: any, run: () => T): T {
  const original = (globalThis as any).window;
  (globalThis as any).window = mockWindow;

  try {
    return run();
  } finally {
    if (original === undefined) {
      delete (globalThis as any).window;
    } else {
      (globalThis as any).window = original;
    }
  }
}

function createWindowMock(seed?: {
  search?: string;
  historyState?: Record<string, unknown>;
  localStorage?: FakeStorageData;
  sessionStorage?: FakeStorageData;
  selectedRoute?: unknown;
  bundledSeed?: Partial<Slide02ContextInput>;
}) {
  return {
    location: {
      search: seed?.search ?? "",
    },
    history: {
      state: seed?.historyState ?? null,
    },
    localStorage: new FakeStorage(seed?.localStorage ?? {}),
    sessionStorage: new FakeStorage(seed?.sessionStorage ?? {}),
    __INVERSION_SELECTED_ROUTE__: seed?.selectedRoute,
    __INVERSION_SLIDE02_SEED__: seed?.bundledSeed,
  };
}

function test_default_seed_without_window() {
  const seed = withWindowMock(undefined, () => resolveSlide02SeedContext());

  assert.equal(seed.route, createDefaultSeedContext().route);
  assert.equal(seed.routeSource, "default");
  assert.deepEqual(seed.constraints, createDefaultSeedContext().constraints);
}

function test_manual_seed_input() {
  const manual = resolveSlide02SeedContext({
    route: "margin",
    routeSource: "external-payload",
    strictness: 88,
    budgetGuard: 74,
    latencyGuard: 20,
  });

  assert.equal(manual.route, "margin-defense");
  assert.equal(manual.routeSource, "external-payload");
  assert.equal(manual.constraints.strictness, 88);
  assert.equal(manual.constraints.budgetGuard, 74);
  assert.equal(manual.constraints.latencyGuard, 20);
}

function test_query_seed_resolution() {
  const mock = createWindowMock({
    search: "?route=throughput&strictness=67&budget=72&latency=31",
  });

  const seed = withWindowMock(mock, () => resolveSlide02SeedContext());

  assert.equal(seed.route, "throughput-push");
  assert.equal(seed.routeSource, "query");
  assert.equal(seed.constraints.strictness, 67);
  assert.equal(seed.constraints.budgetGuard, 72);
  assert.equal(seed.constraints.latencyGuard, 31);
}

function test_history_seed_resolution() {
  const mock = createWindowMock({
    historyState: {
      route: "quality",
      strict: 81,
      budget: 61,
      latency: 25,
    },
  });

  const seed = withWindowMock(mock, () => resolveSlide02SeedContext());

  assert.equal(seed.route, "quality-ringfence");
  assert.equal(seed.routeSource, "history");
  assert.equal(seed.constraints.strictness, 81);
  assert.equal(seed.constraints.budgetGuard, 61);
  assert.equal(seed.constraints.latencyGuard, 25);
}

function test_storage_seed_resolution() {
  const mock = createWindowMock({
    localStorage: {
      "inversion.selectedRoute": "margin-defense",
      "inversion.slide02.strictness": "69",
      "inversion.slide02.budget": "66",
      "inversion.slide02.latency": "19",
    },
  });

  const seed = withWindowMock(mock, () => resolveSlide02SeedContext());

  assert.equal(seed.route, "margin-defense");
  assert.equal(seed.routeSource, "local-storage");
  assert.equal(seed.constraints.strictness, 69);
  assert.equal(seed.constraints.budgetGuard, 66);
  assert.equal(seed.constraints.latencyGuard, 19);
}

function test_window_external_seed_resolution() {
  const mock = createWindowMock({
    selectedRoute: "quality",
    bundledSeed: {
      strictness: 73,
      budgetGuard: 70,
      latencyGuard: 22,
    },
  });

  const seed = withWindowMock(mock, () => resolveSlide02SeedContext());

  assert.equal(seed.route, "quality-ringfence");
  assert.equal(seed.routeSource, "external-payload");
  assert.equal(seed.constraints.strictness, 73);
  assert.equal(seed.constraints.budgetGuard, 70);
  assert.equal(seed.constraints.latencyGuard, 22);
}

function test_precedence_manual_over_query() {
  const mock = createWindowMock({
    search: "?route=throughput&strictness=61&budget=64&latency=37",
  });

  const seed = withWindowMock(mock, () =>
    resolveSlide02SeedContext({
      route: "quality",
      strictness: 91,
      budgetGuard: 88,
      latencyGuard: 14,
      routeSource: "external-payload",
    })
  );

  assert.equal(seed.route, "quality-ringfence");
  assert.equal(seed.routeSource, "external-payload");
  assert.equal(seed.constraints.strictness, 91);
  assert.equal(seed.constraints.budgetGuard, 88);
  assert.equal(seed.constraints.latencyGuard, 14);
}

function test_precedence_query_over_history_storage_window() {
  const mock = createWindowMock({
    search: "?route=margin&strictness=72&budget=74&latency=30",
    historyState: {
      route: "quality",
      strictness: 40,
      budgetGuard: 40,
      latencyGuard: 40,
    },
    localStorage: {
      "inversion.selectedRoute": "throughput-push",
      "inversion.slide02.strictness": "35",
      "inversion.slide02.budget": "35",
      "inversion.slide02.latency": "35",
    },
    selectedRoute: "stabilize-operations",
  });

  const seed = withWindowMock(mock, () => resolveSlide02SeedContext());

  assert.equal(seed.route, "margin-defense");
  assert.equal(seed.routeSource, "query");
  assert.equal(seed.constraints.strictness, 72);
  assert.equal(seed.constraints.budgetGuard, 74);
  assert.equal(seed.constraints.latencyGuard, 30);
}

function test_sanitized_constraints_from_seed_sources() {
  const mock = createWindowMock({
    search: "?route=throughput&strictness=150&budget=-40&latency=foo",
  });

  const seed = withWindowMock(mock, () => resolveSlide02SeedContext());

  assert.equal(seed.constraints.strictness, 100);
  assert.equal(seed.constraints.budgetGuard, 0);
  assert.equal(seed.constraints.latencyGuard, 38);
}

function test_route_source_labels() {
  assert.equal(routeSourceLabel("default"), "Fallback default");
  assert.equal(routeSourceLabel("query"), "URL query");
  assert.equal(routeSourceLabel("history"), "History state");
  assert.equal(routeSourceLabel("local-storage"), "Local storage");
  assert.equal(routeSourceLabel("external-payload"), "External payload");
}

function test_route_id_human_labels() {
  assert.equal(routeIdToHuman("stabilize-operations"), "Stabilize Operations");
  assert.equal(routeIdToHuman("throughput-push"), "Throughput Push");
  assert.equal(routeIdToHuman("margin-defense"), "Margin Defense");
  assert.equal(routeIdToHuman("quality-ringfence"), "Quality Ringfence");
}

function test_seed_summary_export() {
  const seed = {
    route: "throughput-push",
    routeSource: "query",
    constraints: { strictness: 67, budgetGuard: 72, latencyGuard: 31 },
  } as const;

  const summary = exportSeedSummary(seed as any);

  expectStringContains(summary, "route:throughput-push", "summary route");
  expectStringContains(summary, "source:query", "summary source");
  expectStringContains(summary, "strictness:67", "summary strictness");
  expectStringContains(summary, "budget:72", "summary budget");
  expectStringContains(summary, "latency:31", "summary latency");
}

function test_route_sanitizers() {
  assert.equal(sanitizeRouteForReplay("speed"), "throughput-push");
  assert.equal(sanitizeRouteForReplay("qa"), "quality-ringfence");

  assert.equal(ensureRouteOrDefault("margin"), "margin-defense");
  assert.equal(ensureRouteOrDefault("unknown"), "stabilize-operations");
  assert.equal(ensureRouteOrDefault(null), "stabilize-operations");

  assert.equal(
    ensureRouteOrDefault("unknown", "quality-ringfence"),
    "stabilize-operations"
  );
}

function test_session_storage_fallback() {
  const mock = createWindowMock({
    sessionStorage: {
      "hitech.route": "quality-ringfence",
      "hitech.slide02.strictness": "70",
      "hitech.slide02.budget": "68",
      "hitech.slide02.latency": "26",
    },
  });

  const seed = withWindowMock(mock, () => resolveSlide02SeedContext());

  assert.equal(seed.route, "quality-ringfence");
  assert.equal(seed.routeSource, "local-storage");
  assert.equal(seed.constraints.strictness, 70);
  assert.equal(seed.constraints.budgetGuard, 68);
  assert.equal(seed.constraints.latencyGuard, 26);
}

function test_manual_empty_object_does_not_break_defaults() {
  const seed = resolveSlide02SeedContext({});
  assert.equal(seed.route, "stabilize-operations");
  assert.equal(seed.constraints.strictness, 56);
  assert.equal(seed.constraints.budgetGuard, 62);
  assert.equal(seed.constraints.latencyGuard, 38);
}

function test_manual_partial_constraints() {
  const seed = resolveSlide02SeedContext({
    budgetGuard: 91,
  });

  assert.equal(seed.route, "stabilize-operations");
  assert.equal(seed.constraints.strictness, 56);
  assert.equal(seed.constraints.budgetGuard, 91);
  assert.equal(seed.constraints.latencyGuard, 38);
}

export function runSlide02ContextSpecs() {
  const result = runSuite("slide02-context", [
    { id: "default_seed_without_window", run: test_default_seed_without_window },
    { id: "manual_seed_input", run: test_manual_seed_input },
    { id: "query_seed_resolution", run: test_query_seed_resolution },
    { id: "history_seed_resolution", run: test_history_seed_resolution },
    { id: "storage_seed_resolution", run: test_storage_seed_resolution },
    { id: "window_external_seed_resolution", run: test_window_external_seed_resolution },
    { id: "precedence_manual_over_query", run: test_precedence_manual_over_query },
    { id: "precedence_query_over_history_storage_window", run: test_precedence_query_over_history_storage_window },
    { id: "sanitized_constraints_from_seed_sources", run: test_sanitized_constraints_from_seed_sources },
    { id: "route_source_labels", run: test_route_source_labels },
    { id: "route_id_human_labels", run: test_route_id_human_labels },
    { id: "seed_summary_export", run: test_seed_summary_export },
    { id: "route_sanitizers", run: test_route_sanitizers },
    { id: "session_storage_fallback", run: test_session_storage_fallback },
    { id: "manual_empty_object_does_not_break_defaults", run: test_manual_empty_object_does_not_break_defaults },
    { id: "manual_partial_constraints", run: test_manual_partial_constraints },
  ]);

  return result;
}
```

### FILE: components\slides\slide02-ui\core\context.ts
```
import {
  ConstraintValues,
  RouteSourceKind,
  Slide02SeedContext,
  Slide02RouteId,
} from "./types";
import {
  SLIDE02_DEFAULT_CONSTRAINTS,
  SLIDE02_DEFAULT_ROUTE,
  createDefaultSeedContext,
  normalizeRoute,
  sanitizeConstraints,
} from "./model";

const ROUTE_QUERY_KEYS = ["route", "selectedRoute", "selected_route", "r"] as const;
const STRICTNESS_QUERY_KEYS = ["strictness", "strict", "governance"] as const;
const BUDGET_QUERY_KEYS = ["budget", "budgetGuard", "capital"] as const;
const LATENCY_QUERY_KEYS = ["latency", "latencyGuard", "responseLag"] as const;

const ROUTE_STORAGE_KEYS = [
  "inversion.selectedRoute",
  "inversion.route",
  "hitech.selectedRoute",
  "hitech.route",
] as const;

const STRICTNESS_STORAGE_KEYS = [
  "inversion.slide02.strictness",
  "inversion.strictness",
  "hitech.slide02.strictness",
] as const;

const BUDGET_STORAGE_KEYS = [
  "inversion.slide02.budget",
  "inversion.budget",
  "hitech.slide02.budget",
] as const;

const LATENCY_STORAGE_KEYS = [
  "inversion.slide02.latency",
  "inversion.latency",
  "hitech.slide02.latency",
] as const;

export interface Slide02ContextInput {
  route?: string | null;
  strictness?: number | string | null;
  budgetGuard?: number | string | null;
  latencyGuard?: number | string | null;
  routeSource?: RouteSourceKind;
}

declare global {
  interface Window {
    __INVERSION_SELECTED_ROUTE__?: unknown;
    __INVERSION_SLIDE02_SEED__?: Partial<Slide02ContextInput>;
  }
}

function parseFiniteNumber(value: unknown): number | null {
  if (typeof value === "number" && Number.isFinite(value)) {
    return value;
  }

  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = Number(trimmed);
    if (Number.isFinite(parsed)) return parsed;
  }

  return null;
}

function pickFromSearchParams(
  params: URLSearchParams,
  keys: ReadonlyArray<string>
): string | null {
  const hit = keys
    .map((key) => params.get(key))
    .find((value) => typeof value === "string" && value.trim().length > 0);

  return hit ?? null;
}

function pickFromStorage(storage: Storage | null, keys: ReadonlyArray<string>): string | null {
  if (!storage) return null;

  const hit = keys
    .map((key) => {
      try {
        return storage.getItem(key);
      } catch {
        return null;
      }
    })
    .find((value) => typeof value === "string" && value.trim().length > 0);

  return hit ?? null;
}

function constraintsFromRaw(input: {
  strictness?: unknown;
  budgetGuard?: unknown;
  latencyGuard?: unknown;
}): ConstraintValues {
  const strictness = parseFiniteNumber(input.strictness);
  const budgetGuard = parseFiniteNumber(input.budgetGuard);
  const latencyGuard = parseFiniteNumber(input.latencyGuard);

  return sanitizeConstraints({
    strictness: strictness ?? SLIDE02_DEFAULT_CONSTRAINTS.strictness,
    budgetGuard: budgetGuard ?? SLIDE02_DEFAULT_CONSTRAINTS.budgetGuard,
    latencyGuard: latencyGuard ?? SLIDE02_DEFAULT_CONSTRAINTS.latencyGuard,
  });
}

function resolveQuerySeed(search: string): Partial<Slide02SeedContext> | null {
  if (!search || !search.trim()) return null;

  const params = new URLSearchParams(search);
  const routeRaw = pickFromSearchParams(params, ROUTE_QUERY_KEYS);
  const strictnessRaw = pickFromSearchParams(params, STRICTNESS_QUERY_KEYS);
  const budgetRaw = pickFromSearchParams(params, BUDGET_QUERY_KEYS);
  const latencyRaw = pickFromSearchParams(params, LATENCY_QUERY_KEYS);

  const hasAny = [routeRaw, strictnessRaw, budgetRaw, latencyRaw].some((value) => value !== null);
  if (!hasAny) return null;

  const route = normalizeRoute(routeRaw);
  const constraints = constraintsFromRaw({
    strictness: strictnessRaw,
    budgetGuard: budgetRaw,
    latencyGuard: latencyRaw,
  });

  return {
    route,
    routeSource: "query",
    constraints,
    rawRouteInput: routeRaw ?? undefined,
  };
}

function resolveHistorySeed(historyState: unknown): Partial<Slide02SeedContext> | null {
  if (!historyState || typeof historyState !== "object") return null;

  const maybe = historyState as Record<string, unknown>;
  const routeCandidate = maybe.route ?? maybe.selectedRoute ?? maybe.selected_route;

  const strictness = maybe.strictness ?? maybe.strict;
  const budget = maybe.budgetGuard ?? maybe.budget;
  const latency = maybe.latencyGuard ?? maybe.latency;

  const hasAny =
    routeCandidate !== undefined || strictness !== undefined || budget !== undefined || latency !== undefined;

  if (!hasAny) return null;

  return {
    route: normalizeRoute(routeCandidate),
    routeSource: "history",
    constraints: constraintsFromRaw({
      strictness,
      budgetGuard: budget,
      latencyGuard: latency,
    }),
    rawRouteInput: typeof routeCandidate === "string" ? routeCandidate : undefined,
  };
}

function resolveStorageSeed(
  localStorageRef: Storage | null,
  sessionStorageRef: Storage | null
): Partial<Slide02SeedContext> | null {
  const routeRaw =
    pickFromStorage(localStorageRef, ROUTE_STORAGE_KEYS) ??
    pickFromStorage(sessionStorageRef, ROUTE_STORAGE_KEYS);

  const strictnessRaw =
    pickFromStorage(localStorageRef, STRICTNESS_STORAGE_KEYS) ??
    pickFromStorage(sessionStorageRef, STRICTNESS_STORAGE_KEYS);

  const budgetRaw =
    pickFromStorage(localStorageRef, BUDGET_STORAGE_KEYS) ??
    pickFromStorage(sessionStorageRef, BUDGET_STORAGE_KEYS);

  const latencyRaw =
    pickFromStorage(localStorageRef, LATENCY_STORAGE_KEYS) ??
    pickFromStorage(sessionStorageRef, LATENCY_STORAGE_KEYS);

  const hasAny = [routeRaw, strictnessRaw, budgetRaw, latencyRaw].some((value) => value !== null);
  if (!hasAny) return null;

  return {
    route: normalizeRoute(routeRaw),
    routeSource: "local-storage",
    constraints: constraintsFromRaw({
      strictness: strictnessRaw,
      budgetGuard: budgetRaw,
      latencyGuard: latencyRaw,
    }),
    rawRouteInput: routeRaw ?? undefined,
  };
}

function resolveWindowSeed(windowRef: Window): Partial<Slide02SeedContext> | null {
  const direct = windowRef.__INVERSION_SELECTED_ROUTE__;
  const bundle = windowRef.__INVERSION_SLIDE02_SEED__;

  if (!direct && !bundle) return null;

  const routeCandidate = bundle?.route ?? direct;
  const strictness = bundle?.strictness;
  const budget = bundle?.budgetGuard;
  const latency = bundle?.latencyGuard;

  return {
    route: normalizeRoute(routeCandidate),
    routeSource: "external-payload",
    constraints: constraintsFromRaw({
      strictness,
      budgetGuard: budget,
      latencyGuard: latency,
    }),
    rawRouteInput: typeof routeCandidate === "string" ? routeCandidate : undefined,
  };
}

function mergeSeeds(
  defaults: Slide02SeedContext,
  candidate: Partial<Slide02SeedContext> | null
): Slide02SeedContext {
  if (!candidate) return defaults;

  return {
    route: normalizeRoute(candidate.route ?? defaults.route),
    routeSource: candidate.routeSource ?? defaults.routeSource,
    constraints: sanitizeConstraints(candidate.constraints ?? defaults.constraints),
    rawRouteInput: candidate.rawRouteInput ?? defaults.rawRouteInput,
  };
}

function resolveManualInput(input: Partial<Slide02ContextInput> | null | undefined): Partial<Slide02SeedContext> | null {
  if (!input) return null;

  const hasAny =
    input.route !== undefined ||
    input.strictness !== undefined ||
    input.budgetGuard !== undefined ||
    input.latencyGuard !== undefined;

  if (!hasAny) return null;

  return {
    route: normalizeRoute(input.route),
    routeSource: input.routeSource ?? "external-payload",
    constraints: constraintsFromRaw({
      strictness: input.strictness,
      budgetGuard: input.budgetGuard,
      latencyGuard: input.latencyGuard,
    }),
    rawRouteInput: typeof input.route === "string" ? input.route : undefined,
  };
}

export function resolveSlide02SeedContext(
  manualInput?: Partial<Slide02ContextInput> | null
): Slide02SeedContext {
  const defaults = createDefaultSeedContext();

  if (typeof window === "undefined") {
    return mergeSeeds(defaults, resolveManualInput(manualInput));
  }

  const querySeed = resolveQuerySeed(window.location.search);
  const historySeed = resolveHistorySeed(window.history?.state);
  const storageSeed = resolveStorageSeed(window.localStorage, window.sessionStorage);
  const windowSeed = resolveWindowSeed(window);
  const manualSeed = resolveManualInput(manualInput);

  // Precedence: manual > query > history > storage > window > defaults
  const candidates: Array<Partial<Slide02SeedContext> | null> = [
    windowSeed,
    storageSeed,
    historySeed,
    querySeed,
    manualSeed,
  ];

  return candidates.reduce((acc, candidate) => mergeSeeds(acc, candidate), defaults);
}

export function routeSourceLabel(source: RouteSourceKind): string {
  switch (source) {
    case "default":
      return "Fallback default";
    case "query":
      return "URL query";
    case "history":
      return "History state";
    case "local-storage":
      return "Local storage";
    case "external-payload":
      return "External payload";
    default:
      return "Fallback default";
  }
}

export function routeIdToHuman(route: Slide02RouteId): string {
  if (route === "stabilize-operations") return "Stabilize Operations";
  if (route === "throughput-push") return "Throughput Push";
  if (route === "margin-defense") return "Margin Defense";
  return "Quality Ringfence";
}

export function exportSeedSummary(seed: Slide02SeedContext): string {
  return [
    `route:${seed.route}`,
    `source:${seed.routeSource}`,
    `strictness:${seed.constraints.strictness}`,
    `budget:${seed.constraints.budgetGuard}`,
    `latency:${seed.constraints.latencyGuard}`,
  ].join("|");
}

export function sanitizeRouteForReplay(input: unknown): Slide02RouteId {
  return normalizeRoute(input);
}

export function ensureRouteOrDefault(input: unknown, fallback: Slide02RouteId = SLIDE02_DEFAULT_ROUTE): Slide02RouteId {
  const normalized = normalizeRoute(input);
  return normalized || fallback;
}
```

### FILE: components\slides\slide02-ui\core\fixtures.ts
```
import { ConstraintValues, DecisionCode, OperabilityBand, ReplayEvent, Slide02RouteId } from "./types";

export interface ModelScenario {
  id: string;
  route: Slide02RouteId;
  constraints: ConstraintValues;
  expectedDecision: DecisionCode;
  expectedBand: OperabilityBand;
  expectedReadinessRange: [number, number];
  expectedContinuityRange: [number, number];
  expectedRiskRange: [number, number];
}

export interface ReplayScenario {
  id: string;
  base: {
    route: Slide02RouteId;
    constraints: ConstraintValues;
  };
  trace: ReplayEvent[];
  expected: {
    route: Slide02RouteId;
    constraints: ConstraintValues;
    decision: DecisionCode;
    band: OperabilityBand;
  };
}

export const MODEL_SCENARIOS: ModelScenario[] = [
  {
    id: "default-baseline",
    route: "stabilize-operations",
    constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
    expectedDecision: "PROCEED",
    expectedBand: "Stable",
    expectedReadinessRange: [56, 74],
    expectedContinuityRange: [55, 75],
    expectedRiskRange: [30, 55],
  },
  {
    id: "ops-budget-collapse",
    route: "stabilize-operations",
    constraints: { strictness: 56, budgetGuard: 10, latencyGuard: 38 },
    expectedDecision: "PROCEED",
    expectedBand: "Managed",
    expectedReadinessRange: [35, 55],
    expectedContinuityRange: [40, 62],
    expectedRiskRange: [45, 72],
  },
  {
    id: "ops-latency-heavy",
    route: "stabilize-operations",
    constraints: { strictness: 58, budgetGuard: 65, latencyGuard: 86 },
    expectedDecision: "PROCEED",
    expectedBand: "Managed",
    expectedReadinessRange: [30, 55],
    expectedContinuityRange: [20, 55],
    expectedRiskRange: [55, 95],
  },
  {
    id: "ops-hard-lock-funded",
    route: "stabilize-operations",
    constraints: { strictness: 84, budgetGuard: 87, latencyGuard: 20 },
    expectedDecision: "PROCEED+",
    expectedBand: "Hardened",
    expectedReadinessRange: [68, 90],
    expectedContinuityRange: [70, 95],
    expectedRiskRange: [8, 35],
  },
  {
    id: "throughput-balanced",
    route: "throughput-push",
    constraints: { strictness: 52, budgetGuard: 63, latencyGuard: 41 },
    expectedDecision: "PROCEED",
    expectedBand: "Managed",
    expectedReadinessRange: [60, 84],
    expectedContinuityRange: [40, 66],
    expectedRiskRange: [38, 64],
  },
  {
    id: "throughput-latency-overhang",
    route: "throughput-push",
    constraints: { strictness: 44, budgetGuard: 71, latencyGuard: 84 },
    expectedDecision: "TIGHTEN",
    expectedBand: "Managed",
    expectedReadinessRange: [42, 68],
    expectedContinuityRange: [10, 38],
    expectedRiskRange: [68, 95],
  },
  {
    id: "throughput-low-budget",
    route: "throughput-push",
    constraints: { strictness: 48, budgetGuard: 22, latencyGuard: 44 },
    expectedDecision: "TIGHTEN",
    expectedBand: "Managed",
    expectedReadinessRange: [28, 52],
    expectedContinuityRange: [20, 46],
    expectedRiskRange: [55, 80],
  },
  {
    id: "throughput-high-budget-low-latency",
    route: "throughput-push",
    constraints: { strictness: 41, budgetGuard: 86, latencyGuard: 18 },
    expectedDecision: "PROCEED",
    expectedBand: "Stable",
    expectedReadinessRange: [72, 94],
    expectedContinuityRange: [44, 70],
    expectedRiskRange: [30, 55],
  },
  {
    id: "throughput-hard-lock-funded",
    route: "throughput-push",
    constraints: { strictness: 92, budgetGuard: 92, latencyGuard: 14 },
    expectedDecision: "PROCEED+",
    expectedBand: "Hardened",
    expectedReadinessRange: [76, 100],
    expectedContinuityRange: [64, 95],
    expectedRiskRange: [0, 45],
  },
  {
    id: "margin-baseline",
    route: "margin-defense",
    constraints: { strictness: 57, budgetGuard: 60, latencyGuard: 38 },
    expectedDecision: "PROCEED",
    expectedBand: "Managed",
    expectedReadinessRange: [52, 76],
    expectedContinuityRange: [46, 72],
    expectedRiskRange: [32, 58],
  },
  {
    id: "margin-strict-low-budget",
    route: "margin-defense",
    constraints: { strictness: 88, budgetGuard: 28, latencyGuard: 30 },
    expectedDecision: "PROCEED",
    expectedBand: "Managed",
    expectedReadinessRange: [40, 64],
    expectedContinuityRange: [48, 74],
    expectedRiskRange: [24, 48],
  },
  {
    id: "margin-low-strict-low-budget",
    route: "margin-defense",
    constraints: { strictness: 20, budgetGuard: 20, latencyGuard: 50 },
    expectedDecision: "HOLD",
    expectedBand: "Fragile",
    expectedReadinessRange: [20, 42],
    expectedContinuityRange: [8, 34],
    expectedRiskRange: [62, 90],
  },
  {
    id: "margin-latency-crisis",
    route: "margin-defense",
    constraints: { strictness: 62, budgetGuard: 56, latencyGuard: 94 },
    expectedDecision: "TIGHTEN",
    expectedBand: "Managed",
    expectedReadinessRange: [20, 44],
    expectedContinuityRange: [6, 45],
    expectedRiskRange: [60, 100],
  },
  {
    id: "margin-hard-lock-funded",
    route: "margin-defense",
    constraints: { strictness: 84, budgetGuard: 84, latencyGuard: 16 },
    expectedDecision: "PROCEED+",
    expectedBand: "Hardened",
    expectedReadinessRange: [68, 96],
    expectedContinuityRange: [66, 94],
    expectedRiskRange: [6, 32],
  },
  {
    id: "quality-baseline",
    route: "quality-ringfence",
    constraints: { strictness: 62, budgetGuard: 58, latencyGuard: 34 },
    expectedDecision: "PROCEED",
    expectedBand: "Stable",
    expectedReadinessRange: [50, 74],
    expectedContinuityRange: [56, 82],
    expectedRiskRange: [20, 48],
  },
  {
    id: "quality-hard-lock",
    route: "quality-ringfence",
    constraints: { strictness: 90, budgetGuard: 64, latencyGuard: 12 },
    expectedDecision: "PROCEED",
    expectedBand: "Stable",
    expectedReadinessRange: [58, 84],
    expectedContinuityRange: [74, 100],
    expectedRiskRange: [0, 24],
  },
  {
    id: "quality-low-budget",
    route: "quality-ringfence",
    constraints: { strictness: 74, budgetGuard: 18, latencyGuard: 28 },
    expectedDecision: "PROCEED",
    expectedBand: "Managed",
    expectedReadinessRange: [28, 52],
    expectedContinuityRange: [44, 68],
    expectedRiskRange: [36, 62],
  },
  {
    id: "quality-latency-overrun",
    route: "quality-ringfence",
    constraints: { strictness: 72, budgetGuard: 52, latencyGuard: 82 },
    expectedDecision: "PROCEED",
    expectedBand: "Managed",
    expectedReadinessRange: [26, 50],
    expectedContinuityRange: [34, 58],
    expectedRiskRange: [50, 84],
  },
  {
    id: "quality-extreme-latency-low-budget",
    route: "quality-ringfence",
    constraints: { strictness: 66, budgetGuard: 20, latencyGuard: 98 },
    expectedDecision: "HOLD",
    expectedBand: "Fragile",
    expectedReadinessRange: [0, 28],
    expectedContinuityRange: [0, 45],
    expectedRiskRange: [60, 100],
  },
  {
    id: "ops-min-values",
    route: "stabilize-operations",
    constraints: { strictness: 0, budgetGuard: 0, latencyGuard: 0 },
    expectedDecision: "TIGHTEN",
    expectedBand: "Managed",
    expectedReadinessRange: [20, 40],
    expectedContinuityRange: [20, 42],
    expectedRiskRange: [48, 74],
  },
  {
    id: "ops-max-values",
    route: "stabilize-operations",
    constraints: { strictness: 100, budgetGuard: 100, latencyGuard: 100 },
    expectedDecision: "PROCEED",
    expectedBand: "Stable",
    expectedReadinessRange: [58, 84],
    expectedContinuityRange: [46, 72],
    expectedRiskRange: [40, 82],
  },
  {
    id: "throughput-min-values",
    route: "throughput-push",
    constraints: { strictness: 0, budgetGuard: 0, latencyGuard: 0 },
    expectedDecision: "HOLD",
    expectedBand: "Fragile",
    expectedReadinessRange: [30, 56],
    expectedContinuityRange: [10, 34],
    expectedRiskRange: [60, 88],
  },
  {
    id: "throughput-max-values",
    route: "throughput-push",
    constraints: { strictness: 100, budgetGuard: 100, latencyGuard: 100 },
    expectedDecision: "TIGHTEN",
    expectedBand: "Stable",
    expectedReadinessRange: [66, 92],
    expectedContinuityRange: [36, 62],
    expectedRiskRange: [64, 90],
  },
  {
    id: "margin-min-values",
    route: "margin-defense",
    constraints: { strictness: 0, budgetGuard: 0, latencyGuard: 0 },
    expectedDecision: "HOLD",
    expectedBand: "Fragile",
    expectedReadinessRange: [16, 44],
    expectedContinuityRange: [16, 44],
    expectedRiskRange: [54, 80],
  },
  {
    id: "margin-max-values",
    route: "margin-defense",
    constraints: { strictness: 100, budgetGuard: 100, latencyGuard: 100 },
    expectedDecision: "PROCEED",
    expectedBand: "Stable",
    expectedReadinessRange: [56, 84],
    expectedContinuityRange: [48, 76],
    expectedRiskRange: [50, 84],
  },
  {
    id: "quality-min-values",
    route: "quality-ringfence",
    constraints: { strictness: 0, budgetGuard: 0, latencyGuard: 0 },
    expectedDecision: "HOLD",
    expectedBand: "Managed",
    expectedReadinessRange: [12, 36],
    expectedContinuityRange: [28, 54],
    expectedRiskRange: [42, 70],
  },
  {
    id: "quality-max-values",
    route: "quality-ringfence",
    constraints: { strictness: 100, budgetGuard: 100, latencyGuard: 100 },
    expectedDecision: "PROCEED",
    expectedBand: "Stable",
    expectedReadinessRange: [54, 78],
    expectedContinuityRange: [54, 82],
    expectedRiskRange: [40, 76],
  },
];

export const REPLAY_SCENARIOS: ReplayScenario[] = [
  {
    id: "route-plus-three-controls",
    base: {
      route: "stabilize-operations",
      constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
    },
    trace: [
      { seq: 1, kind: "set-route", value: "margin-defense" },
      { seq: 2, kind: "set-strictness", value: 73 },
      { seq: 3, kind: "set-budget", value: 74 },
      { seq: 4, kind: "set-latency", value: 22 },
    ],
    expected: {
      route: "margin-defense",
      constraints: { strictness: 73, budgetGuard: 74, latencyGuard: 22 },
      decision: "PROCEED",
      band: "Stable",
    },
  },
  {
    id: "reset-after-tightening",
    base: {
      route: "throughput-push",
      constraints: { strictness: 42, budgetGuard: 64, latencyGuard: 48 },
    },
    trace: [
      { seq: 1, kind: "set-budget", value: 18 },
      { seq: 2, kind: "set-latency", value: 90 },
      { seq: 3, kind: "reset-constraints", value: null },
    ],
    expected: {
      route: "throughput-push",
      constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
      decision: "PROCEED",
      band: "Stable",
    },
  },
  {
    id: "multi-route-handoffs",
    base: {
      route: "quality-ringfence",
      constraints: { strictness: 68, budgetGuard: 60, latencyGuard: 32 },
    },
    trace: [
      { seq: 1, kind: "set-route", value: "throughput-push" },
      { seq: 2, kind: "set-route", value: "margin-defense" },
      { seq: 3, kind: "set-route", value: "quality-ringfence" },
      { seq: 4, kind: "set-strictness", value: 88 },
      { seq: 5, kind: "set-budget", value: 70 },
      { seq: 6, kind: "set-latency", value: 16 },
    ],
    expected: {
      route: "quality-ringfence",
      constraints: { strictness: 88, budgetGuard: 70, latencyGuard: 16 },
      decision: "PROCEED",
      band: "Stable",
    },
  },
  {
    id: "clamp-out-of-range-values",
    base: {
      route: "stabilize-operations",
      constraints: { strictness: 50, budgetGuard: 50, latencyGuard: 50 },
    },
    trace: [
      { seq: 1, kind: "set-strictness", value: 1000 },
      { seq: 2, kind: "set-budget", value: -500 },
      { seq: 3, kind: "set-latency", value: 300 },
    ],
    expected: {
      route: "stabilize-operations",
      constraints: { strictness: 100, budgetGuard: 0, latencyGuard: 100 },
      decision: "HOLD",
      band: "Fragile",
    },
  },
  {
    id: "route-alias-resolution",
    base: {
      route: "throughput-push",
      constraints: { strictness: 40, budgetGuard: 70, latencyGuard: 20 },
    },
    trace: [
      { seq: 1, kind: "set-route", value: "margin-defense" },
      { seq: 2, kind: "set-route", value: "quality-ringfence" },
    ],
    expected: {
      route: "quality-ringfence",
      constraints: { strictness: 40, budgetGuard: 70, latencyGuard: 20 },
      decision: "PROCEED",
      band: "Stable",
    },
  },
];
```

### FILE: components\slides\slide02-ui\core\fsm.spec.ts
```
import { strict as assert } from "node:assert";
import { createInitialSlide02State, reduceSlide02State, slide02MachineSnapshot } from "./fsm";
import { SLIDE02_DEFAULT_CONSTRAINTS, normalizeRoute } from "./model";
import { createReplayPayload, serializeReplayPayload } from "./replay";
import { runSuite, expectNonEmpty } from "./test-utils";

function createState() {
  return createInitialSlide02State({
    route: "stabilize-operations",
    routeSource: "default",
    constraints: { ...SLIDE02_DEFAULT_CONSTRAINTS },
  });
}

function test_initial_state_shape() {
  const state = createState();

  assert.equal(state.status, "BOOTSTRAPPED");
  assert.equal(state.route, "stabilize-operations");
  assert.deepEqual(state.constraints, SLIDE02_DEFAULT_CONSTRAINTS);
  assert.equal(state.trace.length, 1);
  assert.equal(state.trace[0].action, "boot");
  assert.equal(state.sequence, 1);
  assert.equal(state.hudOpen, false);
  expectNonEmpty(state.response.signature, "initial signature");
}

function test_set_route_transition() {
  const state = createState();
  const next = reduceSlide02State(state, { type: "SET_ROUTE", route: "throughput-push" });

  assert.equal(next.status, "INTERACTIVE");
  assert.equal(next.route, "throughput-push");
  assert.equal(next.trace.length, 2);
  assert.equal(next.trace[1].action, "set-route");
  assert.equal(next.sequence, 2);
  assert.notEqual(next.response.signature, state.response.signature);
}

function test_set_route_noop_for_same_route() {
  const state = createState();
  const next = reduceSlide02State(state, { type: "SET_ROUTE", route: "stabilize-operations" });

  assert.deepEqual(next, state);
}

function test_set_strictness_transition() {
  const state = createState();
  const next = reduceSlide02State(state, { type: "SET_STRICTNESS", value: 78 });

  assert.equal(next.status, "INTERACTIVE");
  assert.equal(next.constraints.strictness, 78);
  assert.equal(next.trace.length, 2);
  assert.equal(next.trace[1].action, "set-strictness");
  assert.equal(next.sequence, 2);
}

function test_set_budget_transition() {
  const state = createState();
  const next = reduceSlide02State(state, { type: "SET_BUDGET_GUARD", value: 12 });

  assert.equal(next.status, "INTERACTIVE");
  assert.equal(next.constraints.budgetGuard, 12);
  assert.equal(next.trace.length, 2);
  assert.equal(next.trace[1].action, "set-budget");
}

function test_set_latency_transition() {
  const state = createState();
  const next = reduceSlide02State(state, { type: "SET_LATENCY_GUARD", value: 64 });

  assert.equal(next.status, "INTERACTIVE");
  assert.equal(next.constraints.latencyGuard, 64);
  assert.equal(next.trace.length, 2);
  assert.equal(next.trace[1].action, "set-latency");
}

function test_constraint_clamping_in_reducer() {
  const state = createState();

  const strict = reduceSlide02State(state, { type: "SET_STRICTNESS", value: 1200 });
  assert.equal(strict.constraints.strictness, 100);

  const budget = reduceSlide02State(state, { type: "SET_BUDGET_GUARD", value: -999 });
  assert.equal(budget.constraints.budgetGuard, 0);

  const latency = reduceSlide02State(state, { type: "SET_LATENCY_GUARD", value: 42.6 });
  assert.equal(latency.constraints.latencyGuard, 43);
}

function test_reset_constraints_transition() {
  const state = createState();

  const changed = reduceSlide02State(
    reduceSlide02State(state, { type: "SET_STRICTNESS", value: 88 }),
    { type: "SET_BUDGET_GUARD", value: 10 }
  );

  assert.notDeepEqual(changed.constraints, SLIDE02_DEFAULT_CONSTRAINTS);

  const reset = reduceSlide02State(changed, { type: "RESET_CONSTRAINTS" });

  assert.deepEqual(reset.constraints, SLIDE02_DEFAULT_CONSTRAINTS);
  assert.equal(reset.status, "INTERACTIVE");
  assert.equal(reset.trace[reset.trace.length - 1].action, "reset-constraints");
}

function test_reset_constraints_noop_when_defaults() {
  const state = createState();
  const next = reduceSlide02State(state, { type: "RESET_CONSTRAINTS" });
  assert.deepEqual(next, state);
}

function test_toggle_hud() {
  const state = createState();
  const open = reduceSlide02State(state, { type: "TOGGLE_HUD" });
  assert.equal(open.hudOpen, true);

  const close = reduceSlide02State(open, { type: "TOGGLE_HUD" });
  assert.equal(close.hudOpen, false);
}

function test_replay_stage_invalid_json() {
  const state = createState();

  const staged = reduceSlide02State(state, {
    type: "REPLAY_STAGE_JSON",
    json: "not-json",
  });

  assert.equal(staged.status, "REPLAY_ERROR");
  assert.equal(staged.replay.stagedPayload, null);
  expectNonEmpty(staged.replay.stagedError ?? "", "replay error message");
}

function test_replay_stage_missing_version() {
  const state = createState();

  const bad = JSON.stringify({
    base: {
      route: "stabilize-operations",
      constraints: SLIDE02_DEFAULT_CONSTRAINTS,
    },
    trace: [],
    meta: { createdBy: "x", createdAt: "x", signature: "x" },
  });

  const staged = reduceSlide02State(state, {
    type: "REPLAY_STAGE_JSON",
    json: bad,
  });

  assert.equal(staged.status, "REPLAY_ERROR");
  assert.equal(staged.replay.stagedPayload, null);
}

function test_replay_stage_and_apply() {
  const state = createState();

  const payload = createReplayPayload(
    "stabilize-operations",
    SLIDE02_DEFAULT_CONSTRAINTS,
    [
      { seq: 1, kind: "set-route", value: "margin-defense" },
      { seq: 2, kind: "set-strictness", value: 79 },
      { seq: 3, kind: "set-budget", value: 78 },
      { seq: 4, kind: "set-latency", value: 18 },
    ],
    state.response.signature
  );

  const staged = reduceSlide02State(state, {
    type: "REPLAY_STAGE_JSON",
    json: serializeReplayPayload(payload),
  });

  assert.equal(staged.status, "REPLAY_READY");
  assert.notEqual(staged.replay.stagedPayload, null);

  const applied = reduceSlide02State(staged, { type: "REPLAY_APPLY_STAGED" });

  assert.equal(applied.status, "REPLAY_APPLIED");
  assert.equal(applied.route, "margin-defense");
  assert.equal(applied.constraints.strictness, 79);
  assert.equal(applied.constraints.budgetGuard, 78);
  assert.equal(applied.constraints.latencyGuard, 18);
  assert.equal(applied.trace[applied.trace.length - 1].action, "replay-applied");
  assert.equal(applied.replay.lastAppliedSignature, applied.response.signature);
}

function test_replay_apply_without_payload_is_noop() {
  const state = createState();
  const applied = reduceSlide02State(state, { type: "REPLAY_APPLY_STAGED" });
  assert.deepEqual(applied, state);
}

function test_replay_clear_from_error() {
  const state = createState();
  const errorState = reduceSlide02State(state, {
    type: "REPLAY_STAGE_JSON",
    json: "broken-json",
  });

  assert.equal(errorState.status, "REPLAY_ERROR");

  const cleared = reduceSlide02State(errorState, { type: "REPLAY_CLEAR" });
  assert.equal(cleared.status, "BOOTSTRAPPED");
  assert.equal(cleared.replay.stagedError, null);
  assert.equal(cleared.replay.stagedJson, "");
}

function test_replay_clear_preserves_interactive_status() {
  const state = createState();
  const edited = reduceSlide02State(state, { type: "SET_BUDGET_GUARD", value: 74 });

  const errored = reduceSlide02State(edited, {
    type: "REPLAY_STAGE_JSON",
    json: "bad",
  });

  const cleared = reduceSlide02State(errored, { type: "REPLAY_CLEAR" });
  assert.equal(cleared.status, "INTERACTIVE");
}

function test_boot_action_reinitializes_state() {
  const state = createState();
  const edited = reduceSlide02State(state, { type: "SET_ROUTE", route: "throughput-push" });
  assert.equal(edited.route, "throughput-push");

  const rebooted = reduceSlide02State(edited, {
    type: "BOOT",
    seed: {
      route: "quality-ringfence",
      routeSource: "external-payload",
      constraints: {
        strictness: 88,
        budgetGuard: 75,
        latencyGuard: 24,
      },
    },
  });

  assert.equal(rebooted.status, "BOOTSTRAPPED");
  assert.equal(rebooted.route, "quality-ringfence");
  assert.equal(rebooted.trace.length, 1);
  assert.equal(rebooted.sequence, 1);
}

function test_sequence_is_monotonic() {
  const state = createState();

  const transitions = [
    { type: "SET_STRICTNESS", value: 60 } as const,
    { type: "SET_BUDGET_GUARD", value: 58 } as const,
    { type: "SET_LATENCY_GUARD", value: 42 } as const,
    { type: "SET_ROUTE", route: "margin-defense" } as const,
    { type: "SET_ROUTE", route: "quality-ringfence" } as const,
    { type: "RESET_CONSTRAINTS" } as const,
  ];

  const final = transitions.reduce((acc, action) => reduceSlide02State(acc, action as never), state);

  const sequences = final.trace.map((entry) => entry.seq);
  const sorted = [...sequences].sort((a, b) => a - b);

  assert.deepEqual(sequences, sorted);

  const unique = new Set(sequences);
  assert.equal(unique.size, sequences.length);
}

function test_trace_before_after_consistency() {
  const state = createState();

  const next = reduceSlide02State(state, { type: "SET_ROUTE", route: "margin-defense" });
  const entry = next.trace[next.trace.length - 1];

  assert.equal(entry.before.route, "stabilize-operations");
  assert.equal(entry.after.route, "margin-defense");

  assert.equal(entry.before.signature, state.response.signature);
  assert.equal(entry.after.signature, next.response.signature);
}

function test_machine_snapshot_string() {
  const state = createState();
  const snapshot = slide02MachineSnapshot(state);

  expectNonEmpty(snapshot, "snapshot string");
  assert.equal(snapshot.includes("status:BOOTSTRAPPED"), true);
  assert.equal(snapshot.includes("route:stabilize-operations"), true);
}

function test_status_evolution_with_mixed_actions() {
  const state = createState();

  const withRoute = reduceSlide02State(state, { type: "SET_ROUTE", route: "throughput-push" });
  assert.equal(withRoute.status, "INTERACTIVE");

  const invalidReplay = reduceSlide02State(withRoute, {
    type: "REPLAY_STAGE_JSON",
    json: "broken",
  });
  assert.equal(invalidReplay.status, "REPLAY_ERROR");

  const cleared = reduceSlide02State(invalidReplay, { type: "REPLAY_CLEAR" });
  assert.equal(cleared.status, "INTERACTIVE");
}

function test_route_normalization_inside_reducer() {
  const state = createState();
  const next = reduceSlide02State(state, { type: "SET_ROUTE", route: "speed" });
  assert.equal(next.route, normalizeRoute("speed"));
}

function test_replay_apply_updates_seed_from_payload_base() {
  const state = createState();

  const payload = createReplayPayload(
    "quality-ringfence",
    { strictness: 61, budgetGuard: 66, latencyGuard: 29 },
    [{ seq: 1, kind: "set-route", value: "margin-defense" }],
    state.response.signature
  );

  const staged = reduceSlide02State(state, {
    type: "REPLAY_STAGE_JSON",
    json: serializeReplayPayload(payload),
  });

  const applied = reduceSlide02State(staged, { type: "REPLAY_APPLY_STAGED" });

  assert.equal(applied.seed.route, "quality-ringfence");
  assert.equal(applied.seed.constraints.strictness, 61);
  assert.equal(applied.seed.routeSource, "external-payload");
}

export function runSlide02FsmSpecs() {
  const result = runSuite("slide02-fsm", [
    { id: "initial_state_shape", run: test_initial_state_shape },
    { id: "set_route_transition", run: test_set_route_transition },
    { id: "set_route_noop_for_same_route", run: test_set_route_noop_for_same_route },
    { id: "set_strictness_transition", run: test_set_strictness_transition },
    { id: "set_budget_transition", run: test_set_budget_transition },
    { id: "set_latency_transition", run: test_set_latency_transition },
    { id: "constraint_clamping_in_reducer", run: test_constraint_clamping_in_reducer },
    { id: "reset_constraints_transition", run: test_reset_constraints_transition },
    { id: "reset_constraints_noop_when_defaults", run: test_reset_constraints_noop_when_defaults },
    { id: "toggle_hud", run: test_toggle_hud },
    { id: "replay_stage_invalid_json", run: test_replay_stage_invalid_json },
    { id: "replay_stage_missing_version", run: test_replay_stage_missing_version },
    { id: "replay_stage_and_apply", run: test_replay_stage_and_apply },
    { id: "replay_apply_without_payload_is_noop", run: test_replay_apply_without_payload_is_noop },
    { id: "replay_clear_from_error", run: test_replay_clear_from_error },
    { id: "replay_clear_preserves_interactive_status", run: test_replay_clear_preserves_interactive_status },
    { id: "boot_action_reinitializes_state", run: test_boot_action_reinitializes_state },
    { id: "sequence_is_monotonic", run: test_sequence_is_monotonic },
    { id: "trace_before_after_consistency", run: test_trace_before_after_consistency },
    { id: "machine_snapshot_string", run: test_machine_snapshot_string },
    { id: "status_evolution_with_mixed_actions", run: test_status_evolution_with_mixed_actions },
    { id: "route_normalization_inside_reducer", run: test_route_normalization_inside_reducer },
    { id: "replay_apply_updates_seed_from_payload_base", run: test_replay_apply_updates_seed_from_payload_base },
  ]);

  return result;
}
```

### FILE: components\slides\slide02-ui\core\fsm.ts
```
import {
  ConstraintValues,
  Slide02MachineAction,
  Slide02MachineState,
  Slide02SeedContext,
  Slide02TraceEntry,
} from "./types";
import {
  SLIDE02_DEFAULT_CONSTRAINTS,
  computeSystemResponse,
  createDefaultSeedContext,
  normalizeRoute,
  sanitizeConstraints,
} from "./model";
import { parseReplayPayload, applyReplayPayload } from "./replay";

function copyConstraints(values: ConstraintValues): ConstraintValues {
  return {
    strictness: values.strictness,
    budgetGuard: values.budgetGuard,
    latencyGuard: values.latencyGuard,
  };
}

function materializeSeed(input?: Partial<Slide02SeedContext> | null): Slide02SeedContext {
  const defaults = createDefaultSeedContext();

  if (!input) {
    return defaults;
  }

  const route = normalizeRoute(input.route ?? defaults.route);
  const constraints = sanitizeConstraints(input.constraints ?? defaults.constraints);

  return {
    route,
    routeSource: input.routeSource ?? defaults.routeSource,
    constraints,
    rawRouteInput: input.rawRouteInput ?? defaults.rawRouteInput,
  };
}

function createBootTraceEntry(
  seed: Slide02SeedContext,
  signature: string,
  seq: number
): Slide02TraceEntry {
  const constraints = copyConstraints(seed.constraints);

  return {
    seq,
    action: "boot",
    before: {
      route: seed.route,
      constraints,
      signature,
    },
    after: {
      route: seed.route,
      constraints,
      signature,
    },
  };
}

function createTraceEntry(
  state: Slide02MachineState,
  action: Slide02TraceEntry["action"],
  nextRoute: Slide02MachineState["route"],
  nextConstraints: Slide02MachineState["constraints"],
  nextSignature: string
): Slide02TraceEntry {
  return {
    seq: state.sequence + 1,
    action,
    before: {
      route: state.route,
      constraints: copyConstraints(state.constraints),
      signature: state.response.signature,
    },
    after: {
      route: nextRoute,
      constraints: copyConstraints(nextConstraints),
      signature: nextSignature,
    },
  };
}

function updateInteractiveState(
  state: Slide02MachineState,
  actionLabel: Slide02TraceEntry["action"],
  nextRoute: Slide02MachineState["route"],
  nextConstraints: Slide02MachineState["constraints"]
): Slide02MachineState {
  const response = computeSystemResponse(nextRoute, nextConstraints, state.seed.routeSource);

  const traceEntry = createTraceEntry(
    state,
    actionLabel,
    nextRoute,
    nextConstraints,
    response.signature
  );

  return {
    ...state,
    status: "INTERACTIVE",
    route: nextRoute,
    constraints: nextConstraints,
    response,
    trace: [...state.trace, traceEntry],
    sequence: traceEntry.seq,
    replay: {
      ...state.replay,
      stagedError: null,
      lastAppliedSignature:
        actionLabel === "replay-applied"
          ? response.signature
          : state.replay.lastAppliedSignature,
    },
  };
}

function hasInteractiveTrace(state: Slide02MachineState): boolean {
  return state.trace.some((entry) => entry.action !== "boot");
}

export function createInitialSlide02State(seed?: Partial<Slide02SeedContext> | null): Slide02MachineState {
  const materializedSeed = materializeSeed(seed);
  const response = computeSystemResponse(
    materializedSeed.route,
    materializedSeed.constraints,
    materializedSeed.routeSource
  );

  const bootTrace = createBootTraceEntry(materializedSeed, response.signature, 1);

  return {
    status: "BOOTSTRAPPED",
    seed: materializedSeed,
    route: materializedSeed.route,
    constraints: copyConstraints(materializedSeed.constraints),
    response,
    trace: [bootTrace],
    hudOpen: false,
    replay: {
      stagedJson: "",
      stagedPayload: null,
      stagedError: null,
      lastAppliedSignature: null,
    },
    sequence: 1,
  };
}

function reduceSetRoute(state: Slide02MachineState, routeInput: string): Slide02MachineState {
  const route = normalizeRoute(routeInput);

  if (route === state.route) {
    return state;
  }

  return updateInteractiveState(state, "set-route", route, copyConstraints(state.constraints));
}

function reduceSetStrictness(state: Slide02MachineState, value: number): Slide02MachineState {
  const constraints = sanitizeConstraints({
    ...state.constraints,
    strictness: value,
  });

  if (constraints.strictness === state.constraints.strictness) {
    return state;
  }

  return updateInteractiveState(state, "set-strictness", state.route, constraints);
}

function reduceSetBudget(state: Slide02MachineState, value: number): Slide02MachineState {
  const constraints = sanitizeConstraints({
    ...state.constraints,
    budgetGuard: value,
  });

  if (constraints.budgetGuard === state.constraints.budgetGuard) {
    return state;
  }

  return updateInteractiveState(state, "set-budget", state.route, constraints);
}

function reduceSetLatency(state: Slide02MachineState, value: number): Slide02MachineState {
  const constraints = sanitizeConstraints({
    ...state.constraints,
    latencyGuard: value,
  });

  if (constraints.latencyGuard === state.constraints.latencyGuard) {
    return state;
  }

  return updateInteractiveState(state, "set-latency", state.route, constraints);
}

function reduceResetConstraints(state: Slide02MachineState): Slide02MachineState {
  const defaults = copyConstraints(SLIDE02_DEFAULT_CONSTRAINTS);

  if (
    state.constraints.strictness === defaults.strictness &&
    state.constraints.budgetGuard === defaults.budgetGuard &&
    state.constraints.latencyGuard === defaults.latencyGuard
  ) {
    return state;
  }

  return updateInteractiveState(state, "reset-constraints", state.route, defaults);
}

function reduceReplayStageJson(state: Slide02MachineState, json: string): Slide02MachineState {
  const parsed = parseReplayPayload(json);

  if (!parsed.ok || !parsed.payload) {
    return {
      ...state,
      status: "REPLAY_ERROR",
      replay: {
        ...state.replay,
        stagedJson: json,
        stagedPayload: null,
        stagedError: parsed.error ?? "Replay payload is invalid.",
      },
    };
  }

  return {
    ...state,
    status: "REPLAY_READY",
    replay: {
      ...state.replay,
      stagedJson: json,
      stagedPayload: parsed.payload,
      stagedError: null,
    },
  };
}

function reduceReplayApply(state: Slide02MachineState): Slide02MachineState {
  const payload = state.replay.stagedPayload;

  if (!payload) {
    return state;
  }

  const applied = applyReplayPayload(payload);

  const traceEntry = createTraceEntry(
    state,
    "replay-applied",
    applied.route,
    applied.constraints,
    applied.response.signature
  );

  return {
    ...state,
    status: "REPLAY_APPLIED",
    seed: {
      route: payload.base.route,
      routeSource: "external-payload",
      constraints: copyConstraints(payload.base.constraints),
      rawRouteInput: payload.base.route,
    },
    route: applied.route,
    constraints: copyConstraints(applied.constraints),
    response: applied.response,
    trace: [...state.trace, traceEntry],
    sequence: traceEntry.seq,
    replay: {
      ...state.replay,
      stagedError: null,
      lastAppliedSignature: applied.response.signature,
    },
  };
}

function reduceReplayClear(state: Slide02MachineState): Slide02MachineState {
  return {
    ...state,
    status: hasInteractiveTrace(state) ? "INTERACTIVE" : "BOOTSTRAPPED",
    replay: {
      ...state.replay,
      stagedJson: "",
      stagedPayload: null,
      stagedError: null,
    },
  };
}

export function reduceSlide02State(
  state: Slide02MachineState,
  action: Slide02MachineAction
): Slide02MachineState {
  switch (action.type) {
    case "BOOT": {
      return createInitialSlide02State(action.seed ?? state.seed);
    }

    case "SET_ROUTE": {
      return reduceSetRoute(state, action.route);
    }

    case "SET_STRICTNESS": {
      return reduceSetStrictness(state, action.value);
    }

    case "SET_BUDGET_GUARD": {
      return reduceSetBudget(state, action.value);
    }

    case "SET_LATENCY_GUARD": {
      return reduceSetLatency(state, action.value);
    }

    case "RESET_CONSTRAINTS": {
      return reduceResetConstraints(state);
    }

    case "TOGGLE_HUD": {
      return {
        ...state,
        hudOpen: !state.hudOpen,
      };
    }

    case "REPLAY_STAGE_JSON": {
      return reduceReplayStageJson(state, action.json);
    }

    case "REPLAY_APPLY_STAGED": {
      return reduceReplayApply(state);
    }

    case "REPLAY_CLEAR": {
      return reduceReplayClear(state);
    }

    default: {
      return state;
    }
  }
}

export function createSlide02ReplayInputTemplate(state: Slide02MachineState): string {
  const payload = {
    version: "slide02.replay.v1",
    base: {
      route: state.route,
      constraints: state.constraints,
    },
    trace: [],
    meta: {
      createdBy: "slide02-ui",
      createdAt: "deterministic-local",
      signature: state.response.signature,
    },
  };

  return JSON.stringify(payload, null, 2);
}

export function slide02MachineSnapshot(state: Slide02MachineState): string {
  return [
    `status:${state.status}`,
    `route:${state.route}`,
    `strictness:${state.constraints.strictness}`,
    `budget:${state.constraints.budgetGuard}`,
    `latency:${state.constraints.latencyGuard}`,
    `signature:${state.response.signature}`,
    `trace:${state.trace.length}`,
    `hud:${state.hudOpen ? "on" : "off"}`,
  ].join("|");
}
```

### FILE: components\slides\slide02-ui\core\index.ts
```
export * from "./model";
export * from "./fsm";
export * from "./replay";
export * from "./context";
export * from "./selectors";
export * from "./types";
export * from "./useSlide02Machine";
```

### FILE: components\slides\slide02-ui\core\model.spec.ts
```
import { strict as assert } from "node:assert";
import {
  SLIDE02_DEFAULT_CONSTRAINTS,
  SLIDE02_DEFAULT_ROUTE,
  SLIDE02_ROUTE_OPTIONS,
  buildSignature,
  computeSystemResponse,
  createDefaultSeedContext,
  describeConstraints,
  formatConstraintSummary,
  formatReadableDecision,
  getRouteOption,
  isConstraintEqual,
  isKnownRoute,
  normalizeRoute,
  sanitizeConstraints,
} from "./model";
import { MODEL_SCENARIOS } from "./fixtures";
import { expectNonEmpty, expectWithinRange, runSuite } from "./test-utils";
import { Slide02RouteId } from "./types";

function test_route_option_catalog() {
  assert.equal(Array.isArray(SLIDE02_ROUTE_OPTIONS), true);
  assert.equal(SLIDE02_ROUTE_OPTIONS.length, 4);

  const routeIds = SLIDE02_ROUTE_OPTIONS.map((route) => route.id);
  assert.deepEqual(routeIds.sort(), [
    "margin-defense",
    "quality-ringfence",
    "stabilize-operations",
    "throughput-push",
  ]);

  SLIDE02_ROUTE_OPTIONS.forEach((route) => {
    expectNonEmpty(route.label, `route ${route.id} label`);
    expectNonEmpty(route.synopsis, `route ${route.id} synopsis`);
    expectNonEmpty(route.rationale, `route ${route.id} rationale`);
  });
}

function test_route_normalization_aliases() {
  const aliasCases: Array<{ raw: unknown; expected: Slide02RouteId }> = [
    { raw: "stabilize", expected: "stabilize-operations" },
    { raw: "ops", expected: "stabilize-operations" },
    { raw: "operations", expected: "stabilize-operations" },
    { raw: "throughput", expected: "throughput-push" },
    { raw: "speed", expected: "throughput-push" },
    { raw: "flow", expected: "throughput-push" },
    { raw: "margin", expected: "margin-defense" },
    { raw: "cost", expected: "margin-defense" },
    { raw: "defense", expected: "margin-defense" },
    { raw: "quality", expected: "quality-ringfence" },
    { raw: "qa", expected: "quality-ringfence" },
    { raw: "ringfence", expected: "quality-ringfence" },
    { raw: "unknown-route", expected: "stabilize-operations" },
    { raw: "", expected: "stabilize-operations" },
    { raw: null, expected: "stabilize-operations" },
    { raw: undefined, expected: "stabilize-operations" },
    { raw: 14, expected: "stabilize-operations" },
  ];

  aliasCases.forEach((item) => {
    assert.equal(normalizeRoute(item.raw), item.expected, `route alias failed for ${String(item.raw)}`);
  });

  assert.equal(isKnownRoute("stabilize-operations"), true);
  assert.equal(isKnownRoute("bad-route"), false);
}

function test_constraints_sanitization() {
  const sanitized = sanitizeConstraints({
    strictness: 200,
    budgetGuard: -40,
    latencyGuard: 43.7,
  });

  assert.deepEqual(sanitized, {
    strictness: 100,
    budgetGuard: 0,
    latencyGuard: 44,
  });

  const fallback = sanitizeConstraints({
    strictness: Number.NaN,
    budgetGuard: Number.POSITIVE_INFINITY,
    latencyGuard: Number.NEGATIVE_INFINITY,
  });

  assert.deepEqual(fallback, SLIDE02_DEFAULT_CONSTRAINTS);

  const same = isConstraintEqual(
    { strictness: 10, budgetGuard: 20, latencyGuard: 30 },
    { strictness: 10, budgetGuard: 20, latencyGuard: 30 }
  );

  assert.equal(same, true);

  const notSame = isConstraintEqual(
    { strictness: 10, budgetGuard: 20, latencyGuard: 30 },
    { strictness: 11, budgetGuard: 20, latencyGuard: 30 }
  );

  assert.equal(notSame, false);
}

function test_default_seed_context() {
  const seed = createDefaultSeedContext();
  assert.equal(seed.route, SLIDE02_DEFAULT_ROUTE);
  assert.equal(seed.routeSource, "default");
  assert.deepEqual(seed.constraints, SLIDE02_DEFAULT_CONSTRAINTS);
}

function test_get_route_option() {
  const route = getRouteOption("throughput-push");
  assert.equal(route.routeCode, "THR");

  const fallback = getRouteOption("stabilize-operations");
  assert.equal(fallback.routeCode, "OPS");
}

function test_signature_builder() {
  const signature = buildSignature(
    "margin-defense",
    78,
    64,
    22,
    "PROCEED+",
    "Hardened"
  );

  assert.equal(signature, "S2|MRG|78|64|22|PP|H");
}

function test_constraint_narratives() {
  const narratives = [
    describeConstraints({ strictness: 10, budgetGuard: 15, latencyGuard: 15 }),
    describeConstraints({ strictness: 40, budgetGuard: 40, latencyGuard: 40 }),
    describeConstraints({ strictness: 60, budgetGuard: 70, latencyGuard: 70 }),
    describeConstraints({ strictness: 90, budgetGuard: 90, latencyGuard: 20 }),
  ];

  assert.equal(narratives[0].tightnessLabel, "Loose Window");
  assert.equal(narratives[1].tightnessLabel, "Guided");
  assert.equal(narratives[2].tightnessLabel, "Tightened");
  assert.equal(narratives[3].tightnessLabel, "Hard Lock");

  assert.equal(narratives[0].budgetPosture, "Constrained");
  assert.equal(narratives[1].budgetPosture, "Balanced");
  assert.equal(narratives[2].budgetPosture, "Funded");

  assert.equal(narratives[0].latencyPosture, "Low latency tolerance");
  assert.equal(narratives[1].latencyPosture, "Moderate latency tolerance");
  assert.equal(narratives[2].latencyPosture, "High latency tolerance");

  narratives.forEach((narrative) => {
    expectNonEmpty(narrative.summary, "constraint summary should not be empty");
  });
}

function test_format_helpers() {
  const constraints = { strictness: 50, budgetGuard: 70, latencyGuard: 30 };
  const summary = formatConstraintSummary(constraints);
  assert.equal(summary, "strictness:50|budget:70|latency:30");

  const response = computeSystemResponse("quality-ringfence", constraints, "default");
  const readable = formatReadableDecision(response);
  assert.equal(readable, `${response.decision} · ${response.operabilityBand}`);
}

function test_model_scenarios_expected_ranges() {
  MODEL_SCENARIOS.forEach((scenario) => {
    const response = computeSystemResponse(
      scenario.route,
      scenario.constraints,
      "default"
    );

    expectWithinRange(
      response.executionReadiness,
      scenario.expectedReadinessRange,
      `${scenario.id} readiness`
    );

    expectWithinRange(
      response.continuityIndex,
      scenario.expectedContinuityRange,
      `${scenario.id} continuity`
    );

    expectWithinRange(
      response.riskPressure,
      scenario.expectedRiskRange,
      `${scenario.id} risk`
    );

    assert.equal(
      response.decision,
      scenario.expectedDecision,
      `${scenario.id} decision mismatch`
    );

    assert.equal(
      response.operabilityBand,
      scenario.expectedBand,
      `${scenario.id} band mismatch`
    );

    expectNonEmpty(response.signature, `${scenario.id} signature`);
    assert.equal(response.signature.startsWith("S2|"), true, `${scenario.id} signature prefix`);

    assert.equal(response.evidenceRows.length, 5, `${scenario.id} evidence row count`);
  });
}

function test_deterministic_repeatability() {
  const route: Slide02RouteId = "throughput-push";
  const constraints = { strictness: 64, budgetGuard: 72, latencyGuard: 32 };

  const first = computeSystemResponse(route, constraints, "default");
  const second = computeSystemResponse(route, constraints, "default");
  const third = computeSystemResponse(route, constraints, "default");

  assert.deepEqual(first, second);
  assert.deepEqual(second, third);
}

function test_evidence_structure() {
  const response = computeSystemResponse(
    "margin-defense",
    { strictness: 72, budgetGuard: 70, latencyGuard: 24 },
    "query"
  );

  const keys = response.evidenceRows.map((row) => row.key);
  assert.deepEqual(keys, ["route", "fit", "capacity", "latency", "verdict"]);

  response.evidenceRows.forEach((row) => {
    expectNonEmpty(row.label, `row ${row.key} label`);
    expectNonEmpty(row.value, `row ${row.key} value`);
    expectNonEmpty(row.rationale, `row ${row.key} rationale`);
    assert.equal(["good", "watch", "risk"].includes(row.status), true);
  });

  expectNonEmpty(response.narrative, "response narrative");
  expectNonEmpty(response.narrativeByAxis.readiness, "axis readiness");
  expectNonEmpty(response.narrativeByAxis.continuity, "axis continuity");
  expectNonEmpty(response.narrativeByAxis.risk, "axis risk");
}

function test_decision_progression_monotonicity() {
  const route: Slide02RouteId = "quality-ringfence";

  const low = computeSystemResponse(route, { strictness: 40, budgetGuard: 30, latencyGuard: 78 }, "default");
  const medium = computeSystemResponse(route, { strictness: 60, budgetGuard: 50, latencyGuard: 50 }, "default");
  const high = computeSystemResponse(route, { strictness: 84, budgetGuard: 76, latencyGuard: 20 }, "default");

  assert.equal(low.executionReadiness <= medium.executionReadiness, true);
  assert.equal(medium.executionReadiness <= high.executionReadiness, true);

  assert.equal(low.continuityIndex <= medium.continuityIndex, true);
  assert.equal(medium.continuityIndex <= high.continuityIndex, true);

  assert.equal(low.riskPressure >= medium.riskPressure, true);
  assert.equal(medium.riskPressure >= high.riskPressure, true);
}

function test_route_bias_impact() {
  const baselineConstraints = { strictness: 58, budgetGuard: 64, latencyGuard: 32 };

  const ops = computeSystemResponse("stabilize-operations", baselineConstraints, "default");
  const thr = computeSystemResponse("throughput-push", baselineConstraints, "default");
  const mrg = computeSystemResponse("margin-defense", baselineConstraints, "default");
  const qlt = computeSystemResponse("quality-ringfence", baselineConstraints, "default");

  assert.equal(thr.executionReadiness >= ops.executionReadiness, true);
  assert.equal(qlt.continuityIndex >= thr.continuityIndex, true);
  assert.equal(qlt.riskPressure <= thr.riskPressure, true);
  assert.equal(mrg.riskPressure <= thr.riskPressure, true);
}

function test_signature_uniqueness_on_changes() {
  const base = computeSystemResponse(
    "stabilize-operations",
    { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
    "default"
  );

  const routeChange = computeSystemResponse(
    "throughput-push",
    { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
    "default"
  );

  const strictnessChange = computeSystemResponse(
    "stabilize-operations",
    { strictness: 70, budgetGuard: 62, latencyGuard: 38 },
    "default"
  );

  const budgetChange = computeSystemResponse(
    "stabilize-operations",
    { strictness: 56, budgetGuard: 76, latencyGuard: 38 },
    "default"
  );

  const latencyChange = computeSystemResponse(
    "stabilize-operations",
    { strictness: 56, budgetGuard: 62, latencyGuard: 62 },
    "default"
  );

  assert.notEqual(base.signature, routeChange.signature);
  assert.notEqual(base.signature, strictnessChange.signature);
  assert.notEqual(base.signature, budgetChange.signature);
  assert.notEqual(base.signature, latencyChange.signature);
}

export function runSlide02ModelSpecs() {
  const result = runSuite("slide02-model", [
    { id: "route_option_catalog", run: test_route_option_catalog },
    { id: "route_normalization_aliases", run: test_route_normalization_aliases },
    { id: "constraints_sanitization", run: test_constraints_sanitization },
    { id: "default_seed_context", run: test_default_seed_context },
    { id: "get_route_option", run: test_get_route_option },
    { id: "signature_builder", run: test_signature_builder },
    { id: "constraint_narratives", run: test_constraint_narratives },
    { id: "format_helpers", run: test_format_helpers },
    { id: "model_scenarios_expected_ranges", run: test_model_scenarios_expected_ranges },
    { id: "deterministic_repeatability", run: test_deterministic_repeatability },
    { id: "evidence_structure", run: test_evidence_structure },
    { id: "decision_progression_monotonicity", run: test_decision_progression_monotonicity },
    { id: "route_bias_impact", run: test_route_bias_impact },
    { id: "signature_uniqueness_on_changes", run: test_signature_uniqueness_on_changes },
  ]);

  return result;
}
```

### FILE: components\slides\slide02-ui\core\model.ts
```
import {
  ConstraintNarrative,
  ConstraintValues,
  DecisionCode,
  OperabilityBand,
  ReplayBase,
  RouteOption,
  RouteSourceKind,
  Slide02RouteId,
  Slide02SeedContext,
  SystemEvidenceRow,
  SystemResponse,
} from "./types";

export const SLIDE02_REPLAY_VERSION = "slide02.replay.v1" as const;

export const SLIDE02_DEFAULT_ROUTE: Slide02RouteId = "stabilize-operations";

export const SLIDE02_DEFAULT_CONSTRAINTS: ConstraintValues = {
  strictness: 56,
  budgetGuard: 62,
  latencyGuard: 38,
};

export const SLIDE02_MIN_CONSTRAINT = 0;
export const SLIDE02_MAX_CONSTRAINT = 100;

export const SLIDE02_ROUTE_OPTIONS: RouteOption[] = [
  {
    id: "stabilize-operations",
    label: "Stabilize Operations",
    synopsis: "Tighten fundamentals before scaling commitments.",
    rationale:
      "Designed for continuity-first transitions where avoiding execution shocks is the primary objective.",
    routeCode: "OPS",
    modelBias: {
      readiness: 6,
      continuity: 10,
      risk: -8,
    },
  },
  {
    id: "throughput-push",
    label: "Throughput Push",
    synopsis: "Favor velocity with bounded risk windows.",
    rationale:
      "Optimized for growth in flow, while preserving enough guardrails to avoid avoidable disruption.",
    routeCode: "THR",
    modelBias: {
      readiness: 14,
      continuity: -4,
      risk: 10,
    },
  },
  {
    id: "margin-defense",
    label: "Margin Defense",
    synopsis: "Protect unit economics under pressure.",
    rationale:
      "Prioritizes cost discipline and execution precision when capital efficiency is under scrutiny.",
    routeCode: "MRG",
    modelBias: {
      readiness: 2,
      continuity: 2,
      risk: -2,
    },
  },
  {
    id: "quality-ringfence",
    label: "Quality Ringfence",
    synopsis: "Preserve trust-critical quality thresholds.",
    rationale:
      "Suitable for reliability-led operations where defects and variance carry strategic downside.",
    routeCode: "QLT",
    modelBias: {
      readiness: -2,
      continuity: 12,
      risk: -12,
    },
  },
];

const ROUTE_ALIAS_TABLE: Array<{ alias: string; id: Slide02RouteId }> = [
  { alias: "stabilize-operations", id: "stabilize-operations" },
  { alias: "stabilize", id: "stabilize-operations" },
  { alias: "stability", id: "stabilize-operations" },
  { alias: "ops", id: "stabilize-operations" },
  { alias: "operations", id: "stabilize-operations" },
  { alias: "throughput-push", id: "throughput-push" },
  { alias: "throughput", id: "throughput-push" },
  { alias: "speed", id: "throughput-push" },
  { alias: "flow", id: "throughput-push" },
  { alias: "margin-defense", id: "margin-defense" },
  { alias: "margin", id: "margin-defense" },
  { alias: "cost", id: "margin-defense" },
  { alias: "defense", id: "margin-defense" },
  { alias: "quality-ringfence", id: "quality-ringfence" },
  { alias: "quality", id: "quality-ringfence" },
  { alias: "qa", id: "quality-ringfence" },
  { alias: "ringfence", id: "quality-ringfence" },
];

function clampConstraint(value: number, fallback: number): number {
  if (!Number.isFinite(value)) {
    return fallback;
  }
  return Math.max(SLIDE02_MIN_CONSTRAINT, Math.min(SLIDE02_MAX_CONSTRAINT, Math.round(value)));
}

function clampScore(value: number): number {
  if (!Number.isFinite(value)) return 0;
  return Math.max(0, Math.min(100, Math.round(value)));
}

function normalizeRouteInput(input: unknown): string {
  if (typeof input !== "string") return "";
  return input.trim().toLowerCase();
}

export function isKnownRoute(input: unknown): input is Slide02RouteId {
  return SLIDE02_ROUTE_OPTIONS.some((route) => route.id === input);
}

export function normalizeRoute(input: unknown): Slide02RouteId {
  const normalized = normalizeRouteInput(input);
  const matched = ROUTE_ALIAS_TABLE.find((entry) => entry.alias === normalized);
  if (matched) return matched.id;
  return SLIDE02_DEFAULT_ROUTE;
}

export function getRouteOption(route: Slide02RouteId): RouteOption {
  const found = SLIDE02_ROUTE_OPTIONS.find((item) => item.id === route);
  return found ?? SLIDE02_ROUTE_OPTIONS[0];
}

export function sanitizeConstraints(input: Partial<ConstraintValues> | null | undefined): ConstraintValues {
  return {
    strictness: clampConstraint(input?.strictness ?? SLIDE02_DEFAULT_CONSTRAINTS.strictness, SLIDE02_DEFAULT_CONSTRAINTS.strictness),
    budgetGuard: clampConstraint(input?.budgetGuard ?? SLIDE02_DEFAULT_CONSTRAINTS.budgetGuard, SLIDE02_DEFAULT_CONSTRAINTS.budgetGuard),
    latencyGuard: clampConstraint(input?.latencyGuard ?? SLIDE02_DEFAULT_CONSTRAINTS.latencyGuard, SLIDE02_DEFAULT_CONSTRAINTS.latencyGuard),
  };
}

export function createDefaultSeedContext(): Slide02SeedContext {
  return {
    route: SLIDE02_DEFAULT_ROUTE,
    routeSource: "default",
    constraints: { ...SLIDE02_DEFAULT_CONSTRAINTS },
    rawRouteInput: undefined,
  };
}

export function createSeedContextFromBase(
  base: Partial<ReplayBase> | null | undefined,
  source: RouteSourceKind = "external-payload"
): Slide02SeedContext {
  const route = normalizeRoute(base?.route);
  const constraints = sanitizeConstraints(base?.constraints ?? undefined);
  return {
    route,
    routeSource: source,
    constraints,
    rawRouteInput: typeof base?.route === "string" ? base.route : undefined,
  };
}

function tightnessLabel(strictness: number): string {
  if (strictness <= 24) return "Loose Window";
  if (strictness <= 49) return "Guided";
  if (strictness <= 74) return "Tightened";
  return "Hard Lock";
}

function budgetPosture(budgetGuard: number): string {
  if (budgetGuard <= 29) return "Constrained";
  if (budgetGuard <= 59) return "Balanced";
  return "Funded";
}

function latencyPosture(latencyGuard: number): string {
  if (latencyGuard <= 29) return "Low latency tolerance";
  if (latencyGuard <= 59) return "Moderate latency tolerance";
  return "High latency tolerance";
}

export function describeConstraints(constraints: ConstraintValues): ConstraintNarrative {
  const strictnessLabel = tightnessLabel(constraints.strictness);
  const budgetLabel = budgetPosture(constraints.budgetGuard);
  const latencyLabel = latencyPosture(constraints.latencyGuard);

  const summary = [
    `strictness ${constraints.strictness} (${strictnessLabel})`,
    `budget ${constraints.budgetGuard} (${budgetLabel})`,
    `latency ${constraints.latencyGuard} (${latencyLabel})`,
  ].join(" | ");

  return {
    tightnessLabel: strictnessLabel,
    budgetPosture: budgetLabel,
    latencyPosture: latencyLabel,
    summary,
  };
}

function classifyBand(readiness: number, continuity: number, risk: number): OperabilityBand {
  const confidence = readiness * 0.46 + continuity * 0.34 + (100 - risk) * 0.2;

  if (confidence < 38) return "Fragile";
  if (confidence < 56) return "Managed";
  if (confidence < 74) return "Stable";
  return "Hardened";
}

function classifyDecision(
  readiness: number,
  continuity: number,
  risk: number,
  band: OperabilityBand
): DecisionCode {
  if (readiness < 36 || risk > 78) {
    return "HOLD";
  }

  if (band === "Fragile") {
    return "HOLD";
  }

  if (risk > 64 || continuity < 42) {
    return "TIGHTEN";
  }

  if (band === "Hardened" && readiness > 74 && risk < 42) {
    return "PROCEED+";
  }

  return "PROCEED";
}

function decisionNarrative(decision: DecisionCode): string {
  switch (decision) {
    case "HOLD":
      return "Execution window is too weak. Stabilize constraints before proceeding.";
    case "TIGHTEN":
      return "The route remains viable but constraints need tighter control first.";
    case "PROCEED":
      return "System posture supports controlled execution with active monitoring.";
    case "PROCEED+":
      return "Signal is strong enough for an accelerated but disciplined execution path.";
    default:
      return "Deterministic decision unavailable.";
  }
}

function axisNarrativeReadiness(score: number): string {
  if (score <= 30) return "Readiness is weak and sequencing risk is elevated.";
  if (score <= 50) return "Readiness is partial; execution can stall under variance.";
  if (score <= 70) return "Readiness is serviceable with expected operational friction.";
  if (score <= 85) return "Readiness is strong and supports deliberate scaling.";
  return "Readiness is very strong and can absorb controlled acceleration.";
}

function axisNarrativeContinuity(score: number): string {
  if (score <= 30) return "Continuity is unstable; handoff points are brittle.";
  if (score <= 50) return "Continuity is moderate; process gaps remain visible.";
  if (score <= 70) return "Continuity is coherent and failures are contained.";
  if (score <= 85) return "Continuity is robust and rollback exposure is low.";
  return "Continuity is hardened with high operational resilience.";
}

function axisNarrativeRisk(score: number): string {
  if (score <= 25) return "Risk pressure is low and manageable.";
  if (score <= 45) return "Risk pressure is moderate with clear controls.";
  if (score <= 65) return "Risk pressure is elevated and should stay monitored.";
  if (score <= 80) return "Risk pressure is high and can degrade delivery confidence.";
  return "Risk pressure is critical and likely to disrupt commitments.";
}

function evidenceStatusFromScore(score: number, higherIsBetter: boolean): "good" | "watch" | "risk" {
  const normalized = higherIsBetter ? score : 100 - score;
  if (normalized >= 70) return "good";
  if (normalized >= 45) return "watch";
  return "risk";
}

function formatPercent(value: number): string {
  return `${value}%`;
}

function decisionCode(decision: DecisionCode): "H" | "T" | "P" | "PP" {
  if (decision === "HOLD") return "H";
  if (decision === "TIGHTEN") return "T";
  if (decision === "PROCEED") return "P";
  return "PP";
}

function bandCode(band: OperabilityBand): "F" | "M" | "S" | "H" {
  if (band === "Fragile") return "F";
  if (band === "Managed") return "M";
  if (band === "Stable") return "S";
  return "H";
}

export function buildSignature(
  route: Slide02RouteId,
  readiness: number,
  continuity: number,
  risk: number,
  decision: DecisionCode,
  band: OperabilityBand
): string {
  const routeCode = getRouteOption(route).routeCode;
  return `S2|${routeCode}|${readiness}|${continuity}|${risk}|${decisionCode(decision)}|${bandCode(band)}`;
}

function buildEvidenceRows(
  route: Slide02RouteId,
  sourceKind: RouteSourceKind,
  constraints: ConstraintValues,
  response: Pick<SystemResponse, "executionReadiness" | "continuityIndex" | "riskPressure" | "decision" | "operabilityBand">
): SystemEvidenceRow[] {
  const routeOption = getRouteOption(route);
  const narratives = describeConstraints(constraints);

  const routeValue = `${routeOption.label} (${routeOption.routeCode})`;
  const routeRationale =
    sourceKind === "default"
      ? "No prior route detected. Default route loaded for continuity."
      : `Route source: ${sourceKind}. ${routeOption.rationale}`;

  const fitValue = `${narratives.tightnessLabel} | ${narratives.summary}`;
  const fitScore = Math.round((constraints.strictness * 0.58 + constraints.budgetGuard * 0.42) * 0.5);

  const capacityValue = `${formatPercent(response.executionReadiness)} readiness`;
  const latencyValue = `${formatPercent(response.riskPressure)} pressure`;
  const verdictValue = `${response.decision} · ${response.operabilityBand}`;

  return [
    {
      key: "route",
      label: "Route Signal",
      value: routeValue,
      status: evidenceStatusFromScore(response.continuityIndex, true),
      rationale: routeRationale,
    },
    {
      key: "fit",
      label: "Constraint Fit",
      value: fitValue,
      status: evidenceStatusFromScore(fitScore, true),
      rationale: "Tightness blends strictness and budget to represent governance fit.",
    },
    {
      key: "capacity",
      label: "Execution Capacity",
      value: capacityValue,
      status: evidenceStatusFromScore(response.executionReadiness, true),
      rationale: "Capacity rises with budget posture and route readiness bias.",
    },
    {
      key: "latency",
      label: "Latency Exposure",
      value: latencyValue,
      status: evidenceStatusFromScore(response.riskPressure, false),
      rationale:
        "Latency tolerance increases risk pressure when strictness and funding cannot absorb response delays.",
    },
    {
      key: "verdict",
      label: "Bridge Verdict",
      value: verdictValue,
      status: response.decision === "HOLD" ? "risk" : response.decision === "TIGHTEN" ? "watch" : "good",
      rationale: decisionNarrative(response.decision),
    },
  ];
}

export function computeSystemResponse(
  route: Slide02RouteId,
  constraints: ConstraintValues,
  sourceKind: RouteSourceKind
): SystemResponse {
  const routeOption = getRouteOption(route);

  const strictness = clampConstraint(constraints.strictness, SLIDE02_DEFAULT_CONSTRAINTS.strictness);
  const budget = clampConstraint(constraints.budgetGuard, SLIDE02_DEFAULT_CONSTRAINTS.budgetGuard);
  const latency = clampConstraint(constraints.latencyGuard, SLIDE02_DEFAULT_CONSTRAINTS.latencyGuard);

  const readinessRaw =
    34 +
    budget * 0.44 +
    strictness * 0.08 -
    latency * 0.26 +
    routeOption.modelBias.readiness;

  const continuityRaw =
    30 +
    strictness * 0.31 +
    budget * 0.24 -
    latency * 0.27 +
    routeOption.modelBias.continuity;

  const riskRaw =
    62 +
    latency * 0.37 -
    strictness * 0.22 -
    budget * 0.21 +
    routeOption.modelBias.risk;

  const executionReadiness = clampScore(readinessRaw);
  const continuityIndex = clampScore(continuityRaw);
  const riskPressure = clampScore(riskRaw);

  const operabilityBand = classifyBand(executionReadiness, continuityIndex, riskPressure);
  const decision = classifyDecision(executionReadiness, continuityIndex, riskPressure, operabilityBand);
  const signature = buildSignature(
    route,
    executionReadiness,
    continuityIndex,
    riskPressure,
    decision,
    operabilityBand
  );

  const narrativeByAxis = {
    readiness: axisNarrativeReadiness(executionReadiness),
    continuity: axisNarrativeContinuity(continuityIndex),
    risk: axisNarrativeRisk(riskPressure),
  };

  const narrative = [
    decisionNarrative(decision),
    `Readiness ${executionReadiness}, continuity ${continuityIndex}, risk ${riskPressure}.`,
  ].join(" ");

  const evidenceRows = buildEvidenceRows(
    route,
    sourceKind,
    { strictness, budgetGuard: budget, latencyGuard: latency },
    { executionReadiness, continuityIndex, riskPressure, decision, operabilityBand }
  );

  return {
    executionReadiness,
    continuityIndex,
    riskPressure,
    operabilityBand,
    decision,
    signature,
    narrative,
    evidenceRows,
    narrativeByAxis,
  };
}

export function createResponseFromSeed(seed: Slide02SeedContext): SystemResponse {
  const route = normalizeRoute(seed.route);
  const constraints = sanitizeConstraints(seed.constraints);
  return computeSystemResponse(route, constraints, seed.routeSource);
}

export function isConstraintEqual(left: ConstraintValues, right: ConstraintValues): boolean {
  return (
    left.strictness === right.strictness &&
    left.budgetGuard === right.budgetGuard &&
    left.latencyGuard === right.latencyGuard
  );
}

export function formatConstraintSummary(constraints: ConstraintValues): string {
  return `strictness:${constraints.strictness}|budget:${constraints.budgetGuard}|latency:${constraints.latencyGuard}`;
}

export function formatReadableDecision(response: SystemResponse): string {
  return `${response.decision} · ${response.operabilityBand}`;
}
```

### FILE: components\slides\slide02-ui\core\replay.spec.ts
```
import { strict as assert } from "node:assert";
import {
  applyReplayPayload,
  createEmptyReplayPayload,
  createReplayPayload,
  createReplayPayloadFromMachine,
  createReplaySummary,
  ensureReplayVersion,
  isReplayEventKind,
  parseReplayPayload,
  repairReplayJson,
  replayEventsFromTrace,
  serializeReplayPayload,
} from "./replay";
import { REPLAY_SCENARIOS } from "./fixtures";
import { runSuite, expectNonEmpty, expectStringContains } from "./test-utils";

function test_create_empty_payload() {
  const payload = createEmptyReplayPayload();

  assert.equal(payload.version, "slide02.replay.v1");
  assert.equal(payload.base.route, "stabilize-operations");
  assert.equal(Array.isArray(payload.trace), true);
  assert.equal(payload.trace.length, 0);
  expectNonEmpty(payload.meta.signature, "empty payload signature");
}

function test_create_payload_and_serialize() {
  const payload = createReplayPayload(
    "margin-defense",
    { strictness: 70, budgetGuard: 75, latencyGuard: 20 },
    [
      { seq: 1, kind: "set-route", value: "quality-ringfence" },
      { seq: 2, kind: "set-strictness", value: 82 },
      { seq: 3, kind: "set-budget", value: 68 },
      { seq: 4, kind: "set-latency", value: 28 },
    ],
    "S2|MRG|70|65|20|P|S"
  );

  const serialized = serializeReplayPayload(payload);
  expectStringContains(serialized, '"version": "slide02.replay.v1"', "serialized version");
  expectStringContains(serialized, '"trace"', "serialized trace");

  const parsed = parseReplayPayload(serialized);
  assert.equal(parsed.ok, true);
  assert.notEqual(parsed.payload, null);

  if (!parsed.payload) {
    throw new Error("parsed payload missing");
  }

  assert.equal(parsed.payload.base.route, "margin-defense");
  assert.equal(parsed.payload.trace.length, 4);
}

function test_parse_invalid_json() {
  const invalidJson = parseReplayPayload("{{bad-json}}");
  assert.equal(invalidJson.ok, false);
  expectNonEmpty(invalidJson.error ?? "", "invalid json error message");
}

function test_parse_missing_version() {
  const json = JSON.stringify({
    base: {
      route: "stabilize-operations",
      constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
    },
    trace: [],
    meta: { createdBy: "x", createdAt: "x", signature: "x" },
  });

  const parsed = parseReplayPayload(json);
  assert.equal(parsed.ok, false);
  expectStringContains(parsed.error ?? "", "version", "missing version error");
}

function test_parse_empty_string() {
  const parsed = parseReplayPayload("   ");
  assert.equal(parsed.ok, false);
  expectStringContains(parsed.error ?? "", "empty", "empty replay message");
}

function test_parse_unordered_trace_sanitizes_sequence() {
  const json = JSON.stringify({
    version: "slide02.replay.v1",
    base: {
      route: "throughput-push",
      constraints: { strictness: 40, budgetGuard: 70, latencyGuard: 28 },
    },
    trace: [
      { seq: 90, kind: "set-budget", value: 60 },
      { seq: 1, kind: "set-route", value: "margin-defense" },
      { seq: 1, kind: "set-latency", value: 22 },
      { seq: 45, kind: "set-strictness", value: 77 },
    ],
    meta: {
      createdBy: "test",
      createdAt: "today",
      signature: "sig",
    },
  });

  const parsed = parseReplayPayload(json);
  assert.equal(parsed.ok, true);

  if (!parsed.payload) {
    throw new Error("payload missing");
  }

  const seqs = parsed.payload.trace.map((event) => event.seq);
  assert.deepEqual(seqs, [1, 2, 3, 4]);
}

function test_parse_unknown_trace_kinds_are_ignored() {
  const json = JSON.stringify({
    version: "slide02.replay.v1",
    base: {
      route: "stabilize-operations",
      constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
    },
    trace: [
      { seq: 1, kind: "set-route", value: "margin-defense" },
      { seq: 2, kind: "unsupported-kind", value: "x" },
      { seq: 3, kind: "set-budget", value: 80 },
      { seq: 4, kind: "another-unsupported", value: 42 },
    ],
    meta: {
      createdBy: "test",
      createdAt: "today",
      signature: "sig",
    },
  });

  const parsed = parseReplayPayload(json);
  assert.equal(parsed.ok, true);

  if (!parsed.payload) {
    throw new Error("payload missing");
  }

  assert.equal(parsed.payload.trace.length, 2);
  assert.deepEqual(
    parsed.payload.trace.map((event) => event.kind),
    ["set-route", "set-budget"]
  );
}

function test_apply_replay_scenarios() {
  REPLAY_SCENARIOS.forEach((scenario) => {
    const payload = createReplayPayload(
      scenario.base.route,
      scenario.base.constraints,
      scenario.trace,
      "sig"
    );

    const result = applyReplayPayload(payload);

    assert.equal(result.route, scenario.expected.route, `${scenario.id} route`);
    assert.deepEqual(result.constraints, scenario.expected.constraints, `${scenario.id} constraints`);
    assert.equal(result.response.decision, scenario.expected.decision, `${scenario.id} decision`);
    assert.equal(result.response.operabilityBand, scenario.expected.band, `${scenario.id} band`);
    expectNonEmpty(result.response.signature, `${scenario.id} signature`);
  });
}

function test_apply_replay_is_deterministic() {
  const payload = createReplayPayload(
    "stabilize-operations",
    { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
    [
      { seq: 1, kind: "set-route", value: "throughput-push" },
      { seq: 2, kind: "set-budget", value: 74 },
      { seq: 3, kind: "set-latency", value: 30 },
      { seq: 4, kind: "set-strictness", value: 64 },
    ],
    "sig"
  );

  const first = applyReplayPayload(payload);
  const second = applyReplayPayload(payload);
  const third = applyReplayPayload(payload);

  assert.deepEqual(first, second);
  assert.deepEqual(second, third);
}

function test_replay_events_from_machine_trace() {
  const machineTrace = [
    {
      seq: 1,
      action: "boot",
      before: {
        route: "stabilize-operations",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-1",
      },
      after: {
        route: "stabilize-operations",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-1",
      },
    },
    {
      seq: 2,
      action: "set-route",
      before: {
        route: "stabilize-operations",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-1",
      },
      after: {
        route: "margin-defense",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-2",
      },
    },
    {
      seq: 3,
      action: "set-strictness",
      before: {
        route: "margin-defense",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-2",
      },
      after: {
        route: "margin-defense",
        constraints: { strictness: 74, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-3",
      },
    },
    {
      seq: 4,
      action: "set-budget",
      before: {
        route: "margin-defense",
        constraints: { strictness: 74, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-3",
      },
      after: {
        route: "margin-defense",
        constraints: { strictness: 74, budgetGuard: 77, latencyGuard: 38 },
        signature: "sig-4",
      },
    },
    {
      seq: 5,
      action: "set-latency",
      before: {
        route: "margin-defense",
        constraints: { strictness: 74, budgetGuard: 77, latencyGuard: 38 },
        signature: "sig-4",
      },
      after: {
        route: "margin-defense",
        constraints: { strictness: 74, budgetGuard: 77, latencyGuard: 20 },
        signature: "sig-5",
      },
    },
    {
      seq: 6,
      action: "reset-constraints",
      before: {
        route: "margin-defense",
        constraints: { strictness: 74, budgetGuard: 77, latencyGuard: 20 },
        signature: "sig-5",
      },
      after: {
        route: "margin-defense",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-6",
      },
    },
    {
      seq: 7,
      action: "replay-applied",
      before: {
        route: "margin-defense",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-6",
      },
      after: {
        route: "quality-ringfence",
        constraints: { strictness: 88, budgetGuard: 70, latencyGuard: 15 },
        signature: "sig-7",
      },
    },
  ] as any;

  const events = replayEventsFromTrace(machineTrace);

  assert.deepEqual(events, [
    { seq: 1, kind: "set-route", value: "margin-defense" },
    { seq: 2, kind: "set-strictness", value: 74 },
    { seq: 3, kind: "set-budget", value: 77 },
    { seq: 4, kind: "set-latency", value: 20 },
    { seq: 5, kind: "reset-constraints", value: null },
  ]);
}

function test_create_replay_payload_from_machine() {
  const machineTrace = [
    {
      seq: 1,
      action: "boot",
      before: {
        route: "stabilize-operations",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-1",
      },
      after: {
        route: "stabilize-operations",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-1",
      },
    },
    {
      seq: 2,
      action: "set-route",
      before: {
        route: "stabilize-operations",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-1",
      },
      after: {
        route: "throughput-push",
        constraints: { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
        signature: "sig-2",
      },
    },
  ] as any;

  const payload = createReplayPayloadFromMachine(
    "throughput-push",
    { strictness: 56, budgetGuard: 62, latencyGuard: 38 },
    machineTrace,
    "sig-2"
  );

  assert.equal(payload.base.route, "throughput-push");
  assert.equal(payload.trace.length, 1);
  assert.deepEqual(payload.trace[0], {
    seq: 1,
    kind: "set-route",
    value: "throughput-push",
  });
}

function test_repair_replay_json() {
  const repairedFromBad = repairReplayJson("bad-json");
  const parsedBad = parseReplayPayload(repairedFromBad);
  assert.equal(parsedBad.ok, true);

  const source = JSON.stringify({
    version: "slide02.replay.v1",
    base: {
      route: "margin-defense",
      constraints: { strictness: 75, budgetGuard: 72, latencyGuard: 18 },
    },
    trace: [
      { seq: 7, kind: "set-route", value: "quality-ringfence" },
      { seq: 1, kind: "set-budget", value: 80 },
    ],
    meta: {
      createdBy: "unit",
      createdAt: "today",
      signature: "sig",
    },
  });

  const repaired = repairReplayJson(source);
  const parsed = parseReplayPayload(repaired);
  assert.equal(parsed.ok, true);

  if (!parsed.payload) {
    throw new Error("repaired payload missing");
  }

  assert.equal(parsed.payload.trace.length, 2);
  assert.deepEqual(parsed.payload.trace.map((item) => item.seq), [1, 2]);
}

function test_ensure_replay_version() {
  assert.equal(ensureReplayVersion("slide02.replay.v1"), "slide02.replay.v1");
  assert.equal(ensureReplayVersion("other"), "slide02.replay.v1");
  assert.equal(ensureReplayVersion(null), "slide02.replay.v1");
  assert.equal(ensureReplayVersion(undefined), "slide02.replay.v1");
}

function test_replay_event_kind_guard() {
  assert.equal(isReplayEventKind("set-route"), true);
  assert.equal(isReplayEventKind("set-budget"), true);
  assert.equal(isReplayEventKind("bad-kind"), false);
  assert.equal(isReplayEventKind(undefined), false);
}

function test_create_replay_summary() {
  const payload = createReplayPayload(
    "quality-ringfence",
    { strictness: 84, budgetGuard: 72, latencyGuard: 19 },
    [
      { seq: 1, kind: "set-strictness", value: 88 },
      { seq: 2, kind: "set-budget", value: 76 },
    ],
    "S2|QLT|82|90|18|PP|H"
  );

  const summary = createReplaySummary(payload);

  expectStringContains(summary, "version:slide02.replay.v1", "summary version");
  expectStringContains(summary, "base:quality-ringfence", "summary base");
  expectStringContains(summary, "trace:2", "summary trace length");
  expectStringContains(summary, "signature:S2|QLT|82|90|18|PP|H", "summary signature");
}

export function runSlide02ReplaySpecs() {
  const result = runSuite("slide02-replay", [
    { id: "create_empty_payload", run: test_create_empty_payload },
    { id: "create_payload_and_serialize", run: test_create_payload_and_serialize },
    { id: "parse_invalid_json", run: test_parse_invalid_json },
    { id: "parse_missing_version", run: test_parse_missing_version },
    { id: "parse_empty_string", run: test_parse_empty_string },
    { id: "parse_unordered_trace_sanitizes_sequence", run: test_parse_unordered_trace_sanitizes_sequence },
    { id: "parse_unknown_trace_kinds_are_ignored", run: test_parse_unknown_trace_kinds_are_ignored },
    { id: "apply_replay_scenarios", run: test_apply_replay_scenarios },
    { id: "apply_replay_is_deterministic", run: test_apply_replay_is_deterministic },
    { id: "replay_events_from_machine_trace", run: test_replay_events_from_machine_trace },
    { id: "create_replay_payload_from_machine", run: test_create_replay_payload_from_machine },
    { id: "repair_replay_json", run: test_repair_replay_json },
    { id: "ensure_replay_version", run: test_ensure_replay_version },
    { id: "replay_event_kind_guard", run: test_replay_event_kind_guard },
    { id: "create_replay_summary", run: test_create_replay_summary },
  ]);

  return result;
}
```

### FILE: components\slides\slide02-ui\core\replay.ts
```
import {
  ConstraintValues,
  ReplayApplicationResult,
  ReplayEvent,
  ReplayEventKind,
  ReplayMeta,
  ReplayParseResult,
  ReplayPayload,
  Slide02RouteId,
  Slide02TraceEntry,
} from "./types";
import {
  SLIDE02_DEFAULT_CONSTRAINTS,
  SLIDE02_DEFAULT_ROUTE,
  SLIDE02_REPLAY_VERSION,
  computeSystemResponse,
  normalizeRoute,
  sanitizeConstraints,
} from "./model";

const ALLOWED_REPLAY_KINDS: ReplayEventKind[] = [
  "set-route",
  "set-strictness",
  "set-budget",
  "set-latency",
  "reset-constraints",
];

function isAllowedReplayKind(kind: string): kind is ReplayEventKind {
  return ALLOWED_REPLAY_KINDS.includes(kind as ReplayEventKind);
}

function parseSeq(input: unknown, fallback: number): number {
  if (typeof input === "number" && Number.isFinite(input)) {
    return Math.max(1, Math.round(input));
  }

  if (typeof input === "string") {
    const parsed = Number(input.trim());
    if (Number.isFinite(parsed)) {
      return Math.max(1, Math.round(parsed));
    }
  }

  return fallback;
}

function parseReplayValue(kind: ReplayEventKind, raw: unknown): Slide02RouteId | number | null {
  if (kind === "set-route") {
    return normalizeRoute(raw);
  }

  if (kind === "reset-constraints") {
    return null;
  }

  if (typeof raw === "number" && Number.isFinite(raw)) {
    return Math.round(raw);
  }

  if (typeof raw === "string") {
    const parsed = Number(raw.trim());
    if (Number.isFinite(parsed)) {
      return Math.round(parsed);
    }
  }

  return 0;
}

function sanitizeReplayEvent(raw: unknown, fallbackSeq: number): ReplayEvent | null {
  if (!raw || typeof raw !== "object") {
    return null;
  }

  const value = raw as Record<string, unknown>;
  const kindRaw = value.kind;

  if (typeof kindRaw !== "string" || !isAllowedReplayKind(kindRaw)) {
    return null;
  }

  const seq = parseSeq(value.seq, fallbackSeq);

  return {
    seq,
    kind: kindRaw,
    value: parseReplayValue(kindRaw, value.value),
  };
}

function sanitizeReplayTrace(input: unknown): ReplayEvent[] {
  if (!Array.isArray(input)) {
    return [];
  }

  const withIndex = input
    .map((entry, index) => sanitizeReplayEvent(entry, index + 1))
    .filter((entry): entry is ReplayEvent => entry !== null);

  const sorted = [...withIndex].sort((left, right) => left.seq - right.seq);

  return sorted.map((entry, index) => ({ ...entry, seq: index + 1 }));
}

function sanitizeReplayMeta(input: unknown, signature: string): ReplayMeta {
  if (!input || typeof input !== "object") {
    return {
      createdBy: "slide02-ui",
      createdAt: "deterministic-local",
      signature,
    };
  }

  const raw = input as Record<string, unknown>;
  const createdBy = typeof raw.createdBy === "string" && raw.createdBy.trim() ? raw.createdBy : "slide02-ui";
  const createdAt = typeof raw.createdAt === "string" && raw.createdAt.trim() ? raw.createdAt : "deterministic-local";
  const signatureValue = typeof raw.signature === "string" && raw.signature.trim() ? raw.signature : signature;

  return {
    createdBy,
    createdAt,
    signature: signatureValue,
  };
}

function sanitizeReplayBase(input: unknown): { route: Slide02RouteId; constraints: ConstraintValues } | null {
  if (!input || typeof input !== "object") {
    return null;
  }

  const raw = input as Record<string, unknown>;
  const route = normalizeRoute(raw.route);

  const rawConstraints =
    raw.constraints && typeof raw.constraints === "object"
      ? (raw.constraints as Record<string, unknown>)
      : null;

  if (!rawConstraints) {
    return {
      route,
      constraints: { ...SLIDE02_DEFAULT_CONSTRAINTS },
    };
  }

  const constraints = sanitizeConstraints({
    strictness:
      typeof rawConstraints.strictness === "number"
        ? rawConstraints.strictness
        : Number(rawConstraints.strictness),
    budgetGuard:
      typeof rawConstraints.budgetGuard === "number"
        ? rawConstraints.budgetGuard
        : Number(rawConstraints.budgetGuard),
    latencyGuard:
      typeof rawConstraints.latencyGuard === "number"
        ? rawConstraints.latencyGuard
        : Number(rawConstraints.latencyGuard),
  });

  return {
    route,
    constraints,
  };
}

export function createReplayPayload(
  route: Slide02RouteId,
  constraints: ConstraintValues,
  trace: ReplayEvent[],
  signature: string
): ReplayPayload {
  const baseConstraints = sanitizeConstraints(constraints);
  const normalizedTrace = sanitizeReplayTrace(trace);

  return {
    version: SLIDE02_REPLAY_VERSION,
    base: {
      route: normalizeRoute(route),
      constraints: baseConstraints,
    },
    trace: normalizedTrace,
    meta: {
      createdBy: "slide02-ui",
      createdAt: "deterministic-local",
      signature,
    },
  };
}

export function replayEventsFromTrace(trace: Slide02TraceEntry[]): ReplayEvent[] {
  return trace
    .map((entry, index): ReplayEvent | null => {
      if (entry.action === "set-route") {
        return {
          seq: index + 1,
          kind: "set-route",
          value: entry.after.route,
        };
      }

      if (entry.action === "set-strictness") {
        return {
          seq: index + 1,
          kind: "set-strictness",
          value: entry.after.constraints.strictness,
        };
      }

      if (entry.action === "set-budget") {
        return {
          seq: index + 1,
          kind: "set-budget",
          value: entry.after.constraints.budgetGuard,
        };
      }

      if (entry.action === "set-latency") {
        return {
          seq: index + 1,
          kind: "set-latency",
          value: entry.after.constraints.latencyGuard,
        };
      }

      if (entry.action === "reset-constraints") {
        return {
          seq: index + 1,
          kind: "reset-constraints",
          value: null,
        };
      }

      return null;
    })
    .filter((entry): entry is ReplayEvent => entry !== null)
    .map((entry, index) => ({ ...entry, seq: index + 1 }));
}

export function serializeReplayPayload(payload: ReplayPayload): string {
  const normalized = {
    version: payload.version,
    base: {
      route: normalizeRoute(payload.base.route),
      constraints: sanitizeConstraints(payload.base.constraints),
    },
    trace: sanitizeReplayTrace(payload.trace),
    meta: sanitizeReplayMeta(payload.meta, payload.meta.signature),
  };

  return JSON.stringify(normalized, null, 2);
}

export function parseReplayPayload(json: string): ReplayParseResult {
  if (!json || !json.trim()) {
    return {
      ok: false,
      payload: null,
      error: "Replay JSON is empty.",
    };
  }

  let parsed: unknown;
  try {
    parsed = JSON.parse(json);
  } catch {
    return {
      ok: false,
      payload: null,
      error: "Replay JSON could not be parsed.",
    };
  }

  if (!parsed || typeof parsed !== "object") {
    return {
      ok: false,
      payload: null,
      error: "Replay payload must be an object.",
    };
  }

  const raw = parsed as Record<string, unknown>;

  if (raw.version !== SLIDE02_REPLAY_VERSION) {
    return {
      ok: false,
      payload: null,
      error: `Replay version must be ${SLIDE02_REPLAY_VERSION}.`,
    };
  }

  const base = sanitizeReplayBase(raw.base);

  if (!base) {
    return {
      ok: false,
      payload: null,
      error: "Replay base is missing or invalid.",
    };
  }

  const trace = sanitizeReplayTrace(raw.trace);
  const baseResponse = computeSystemResponse(base.route, base.constraints, "external-payload");
  const meta = sanitizeReplayMeta(raw.meta, baseResponse.signature);

  const payload: ReplayPayload = {
    version: SLIDE02_REPLAY_VERSION,
    base,
    trace,
    meta,
  };

  return {
    ok: true,
    payload,
    error: null,
  };
}

export function applyReplayPayload(payload: ReplayPayload): ReplayApplicationResult {
  const route = normalizeRoute(payload.base.route);
  const constraints = sanitizeConstraints(payload.base.constraints);

  const finalState = sanitizeReplayTrace(payload.trace).reduce(
    (acc, event) => {
      if (event.kind === "set-route") {
        return {
          route: normalizeRoute(event.value),
          constraints: acc.constraints,
        };
      }

      if (event.kind === "set-strictness") {
        return {
          route: acc.route,
          constraints: sanitizeConstraints({
            ...acc.constraints,
            strictness: Number(event.value),
          }),
        };
      }

      if (event.kind === "set-budget") {
        return {
          route: acc.route,
          constraints: sanitizeConstraints({
            ...acc.constraints,
            budgetGuard: Number(event.value),
          }),
        };
      }

      if (event.kind === "set-latency") {
        return {
          route: acc.route,
          constraints: sanitizeConstraints({
            ...acc.constraints,
            latencyGuard: Number(event.value),
          }),
        };
      }

      return {
        route: acc.route,
        constraints: { ...SLIDE02_DEFAULT_CONSTRAINTS },
      };
    },
    {
      route,
      constraints,
    }
  );

  const response = computeSystemResponse(
    finalState.route,
    finalState.constraints,
    "external-payload"
  );

  return {
    route: finalState.route,
    constraints: finalState.constraints,
    response,
    trace: sanitizeReplayTrace(payload.trace),
  };
}

export function createReplayPayloadFromMachine(
  route: Slide02RouteId,
  constraints: ConstraintValues,
  machineTrace: Slide02TraceEntry[],
  signature: string
): ReplayPayload {
  const replayTrace = replayEventsFromTrace(machineTrace);
  return createReplayPayload(route, constraints, replayTrace, signature);
}

export function isReplayEventKind(input: unknown): input is ReplayEventKind {
  return typeof input === "string" && isAllowedReplayKind(input);
}

export function createEmptyReplayPayload(): ReplayPayload {
  const response = computeSystemResponse(
    SLIDE02_DEFAULT_ROUTE,
    SLIDE02_DEFAULT_CONSTRAINTS,
    "default"
  );

  return {
    version: SLIDE02_REPLAY_VERSION,
    base: {
      route: SLIDE02_DEFAULT_ROUTE,
      constraints: { ...SLIDE02_DEFAULT_CONSTRAINTS },
    },
    trace: [],
    meta: {
      createdBy: "slide02-ui",
      createdAt: "deterministic-local",
      signature: response.signature,
    },
  };
}

export function repairReplayJson(json: string): string {
  const parsed = parseReplayPayload(json);

  if (!parsed.ok || !parsed.payload) {
    return serializeReplayPayload(createEmptyReplayPayload());
  }

  return serializeReplayPayload(parsed.payload);
}

export function ensureReplayVersion(value: string | null | undefined): string {
  return value === SLIDE02_REPLAY_VERSION ? value : SLIDE02_REPLAY_VERSION;
}

export function createReplaySummary(payload: ReplayPayload): string {
  return [
    `version:${payload.version}`,
    `base:${payload.base.route}`,
    `strictness:${payload.base.constraints.strictness}`,
    `budget:${payload.base.constraints.budgetGuard}`,
    `latency:${payload.base.constraints.latencyGuard}`,
    `trace:${payload.trace.length}`,
    `signature:${payload.meta.signature}`,
  ].join("|");
}
```

### FILE: components\slides\slide02-ui\core\run-slide02-unit.ts
```
import { runSlide02ModelSpecs } from "./model.spec";
import { runSlide02FsmSpecs } from "./fsm.spec";
import { runSlide02ReplaySpecs } from "./replay.spec";
import { runSlide02ContextSpecs } from "./context.spec";
import { assertAllPass, printSuiteResult } from "./test-utils";

const results = [
  runSlide02ModelSpecs(),
  runSlide02FsmSpecs(),
  runSlide02ReplaySpecs(),
  runSlide02ContextSpecs(),
];

results.forEach((result) => printSuiteResult(result));
assertAllPass(results);

console.log("[slide02-unit] PASS");
```

### FILE: components\slides\slide02-ui\core\selectors.ts
```
import {
  DecisionCode,
  EvidenceStatus,
  OperabilityBand,
  Slide02MachineState,
  SystemEvidenceRow,
} from "./types";
import { describeConstraints, getRouteOption } from "./model";
import { routeIdToHuman, routeSourceLabel } from "./context";

export interface Slide02ScoreCard {
  key: "readiness" | "continuity" | "risk";
  label: string;
  value: number;
  tone: "good" | "watch" | "risk";
  detail: string;
}

export interface Slide02StatusBadge {
  label: string;
  tone: "neutral" | "good" | "warning" | "risk";
}

export interface Slide02EvidenceViewModel {
  rows: SystemEvidenceRow[];
  decisionBadge: Slide02StatusBadge;
  bandBadge: Slide02StatusBadge;
  cards: Slide02ScoreCard[];
}

export interface Slide02HudSummary {
  route: string;
  routeSource: string;
  status: string;
  constraints: string;
  signature: string;
  traceLength: number;
}

export function statusTone(status: Slide02MachineState["status"]): "neutral" | "good" | "warning" | "risk" {
  if (status === "REPLAY_APPLIED") return "good";
  if (status === "REPLAY_ERROR") return "risk";
  if (status === "REPLAY_READY") return "warning";
  return "neutral";
}

export function evidenceTone(status: EvidenceStatus): "good" | "watch" | "risk" {
  if (status === "good") return "good";
  if (status === "watch") return "watch";
  return "risk";
}

export function decisionTone(decision: DecisionCode): "good" | "warning" | "risk" {
  if (decision === "PROCEED+" || decision === "PROCEED") return "good";
  if (decision === "TIGHTEN") return "warning";
  return "risk";
}

export function bandTone(band: OperabilityBand): "good" | "warning" | "risk" {
  if (band === "Hardened" || band === "Stable") return "good";
  if (band === "Managed") return "warning";
  return "risk";
}

export function findEvidenceRow(
  state: Slide02MachineState,
  key: SystemEvidenceRow["key"]
): SystemEvidenceRow | null {
  return state.response.evidenceRows.find((row) => row.key === key) ?? null;
}

export function buildScoreCards(state: Slide02MachineState): Slide02ScoreCard[] {
  const response = state.response;

  const readinessTone: Slide02ScoreCard["tone"] =
    response.executionReadiness >= 70
      ? "good"
      : response.executionReadiness >= 45
      ? "watch"
      : "risk";

  const continuityTone: Slide02ScoreCard["tone"] =
    response.continuityIndex >= 70
      ? "good"
      : response.continuityIndex >= 45
      ? "watch"
      : "risk";

  const riskTone: Slide02ScoreCard["tone"] =
    response.riskPressure <= 35
      ? "good"
      : response.riskPressure <= 60
      ? "watch"
      : "risk";

  return [
    {
      key: "readiness",
      label: "Execution Readiness",
      value: response.executionReadiness,
      tone: readinessTone,
      detail: response.narrativeByAxis.readiness,
    },
    {
      key: "continuity",
      label: "Continuity Index",
      value: response.continuityIndex,
      tone: continuityTone,
      detail: response.narrativeByAxis.continuity,
    },
    {
      key: "risk",
      label: "Risk Pressure",
      value: response.riskPressure,
      tone: riskTone,
      detail: response.narrativeByAxis.risk,
    },
  ];
}

export function buildEvidenceViewModel(state: Slide02MachineState): Slide02EvidenceViewModel {
  const cards = buildScoreCards(state);

  return {
    rows: state.response.evidenceRows,
    decisionBadge: {
      label: state.response.decision,
      tone: decisionTone(state.response.decision) === "good"
        ? "good"
        : decisionTone(state.response.decision) === "warning"
        ? "warning"
        : "risk",
    },
    bandBadge: {
      label: state.response.operabilityBand,
      tone: bandTone(state.response.operabilityBand) === "good"
        ? "good"
        : bandTone(state.response.operabilityBand) === "warning"
        ? "warning"
        : "risk",
    },
    cards,
  };
}

export function buildHudSummary(state: Slide02MachineState): Slide02HudSummary {
  const routeInfo = getRouteOption(state.route);
  const constraints = describeConstraints(state.constraints);

  return {
    route: `${routeInfo.label} (${routeInfo.routeCode})`,
    routeSource: routeSourceLabel(state.seed.routeSource),
    status: state.status,
    constraints: constraints.summary,
    signature: state.response.signature,
    traceLength: state.trace.length,
  };
}

export function statusLabel(status: Slide02MachineState["status"]): string {
  if (status === "BOOTSTRAPPED") return "Bootstrapped";
  if (status === "INTERACTIVE") return "Interactive";
  if (status === "REPLAY_READY") return "Replay Ready";
  if (status === "REPLAY_APPLIED") return "Replay Applied";
  return "Replay Error";
}

export function controlTone(
  value: number,
  axis: "strictness" | "budget" | "latency"
): "good" | "watch" | "risk" {
  if (axis === "strictness") {
    if (value >= 70) return "good";
    if (value >= 40) return "watch";
    return "risk";
  }

  if (axis === "budget") {
    if (value >= 65) return "good";
    if (value >= 35) return "watch";
    return "risk";
  }

  if (value <= 35) return "good";
  if (value <= 65) return "watch";
  return "risk";
}

export function toneClass(tone: "neutral" | "good" | "warning" | "risk" | "watch"): string {
  if (tone === "good") return "slide02-tone-good";
  if (tone === "warning" || tone === "watch") return "slide02-tone-watch";
  if (tone === "risk") return "slide02-tone-risk";
  return "slide02-tone-neutral";
}

export function traceRows(state: Slide02MachineState): string[] {
  return state.trace.map((entry) => {
    return [
      `#${entry.seq}`,
      entry.action,
      `${entry.before.signature} -> ${entry.after.signature}`,
    ].join(" | ");
  });
}

export function routeLabel(route: Slide02MachineState["route"]): string {
  return routeIdToHuman(route);
}

export function flattenEvidenceSummary(state: Slide02MachineState): string {
  return state.response.evidenceRows
    .map((row) => `${row.label}:${row.status}:${row.value}`)
    .join(" || ");
}
```

### FILE: components\slides\slide02-ui\core\test-utils.ts
```
import { strict as assert } from "node:assert";

export type TestCase = {
  id: string;
  run: () => void;
};

export interface TestSuiteResult {
  suite: string;
  passed: number;
  failed: number;
  failures: Array<{ id: string; error: string }>;
}

export function expectWithinRange(value: number, range: [number, number], message: string): void {
  const [min, max] = range;
  assert.equal(Number.isFinite(value), true, `${message}: value is not finite`);
  assert.equal(value >= min, true, `${message}: ${value} < ${min}`);
  assert.equal(value <= max, true, `${message}: ${value} > ${max}`);
}

export function expectStringContains(value: string, expected: string, message: string): void {
  assert.equal(value.includes(expected), true, `${message}: expected "${expected}" in "${value}"`);
}

export function expectNonEmpty(value: string, message: string): void {
  assert.equal(typeof value, "string", `${message}: value is not a string`);
  assert.equal(value.trim().length > 0, true, `${message}: value is empty`);
}

export function runSuite(suiteName: string, cases: TestCase[]): TestSuiteResult {
  const failures: Array<{ id: string; error: string }> = [];

  cases.forEach((item) => {
    try {
      item.run();
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      failures.push({ id: item.id, error: message });
    }
  });

  return {
    suite: suiteName,
    passed: cases.length - failures.length,
    failed: failures.length,
    failures,
  };
}

export function printSuiteResult(result: TestSuiteResult): void {
  const status = result.failed === 0 ? "PASS" : "FAIL";
  console.log(`[slide02-unit] ${status} ${result.suite} passed=${result.passed} failed=${result.failed}`);

  if (result.failed > 0) {
    result.failures.forEach((failure) => {
      console.log(`[slide02-unit]   ${failure.id} :: ${failure.error}`);
    });
  }
}

export function assertAllPass(results: TestSuiteResult[]): void {
  const failed = results.filter((result) => result.failed > 0);
  if (failed.length === 0) {
    return;
  }

  const summary = failed
    .map((result) => `${result.suite} failed=${result.failed}`)
    .join(", ");

  throw new Error(`Slide02 unit suite failed: ${summary}`);
}

export function deepClone<T>(value: T): T {
  return JSON.parse(JSON.stringify(value)) as T;
}
```

### FILE: components\slides\slide02-ui\core\types.ts
```
export type Slide02RouteId =
  | "stabilize-operations"
  | "throughput-push"
  | "margin-defense"
  | "quality-ringfence";

export type RouteSourceKind =
  | "default"
  | "query"
  | "history"
  | "local-storage"
  | "external-payload";

export type OperabilityBand = "Fragile" | "Managed" | "Stable" | "Hardened";

export type DecisionCode = "HOLD" | "TIGHTEN" | "PROCEED" | "PROCEED+";

export type EvidenceStatus = "good" | "watch" | "risk";

export type Slide02Status =
  | "BOOTSTRAPPED"
  | "INTERACTIVE"
  | "REPLAY_READY"
  | "REPLAY_APPLIED"
  | "REPLAY_ERROR";

export type ReplayEventKind =
  | "set-route"
  | "set-strictness"
  | "set-budget"
  | "set-latency"
  | "reset-constraints";

export interface RouteOption {
  id: Slide02RouteId;
  label: string;
  synopsis: string;
  rationale: string;
  routeCode: "OPS" | "THR" | "MRG" | "QLT";
  modelBias: {
    readiness: number;
    continuity: number;
    risk: number;
  };
}

export interface ConstraintValues {
  strictness: number;
  budgetGuard: number;
  latencyGuard: number;
}

export interface ConstraintNarrative {
  tightnessLabel: string;
  budgetPosture: string;
  latencyPosture: string;
  summary: string;
}

export interface SystemEvidenceRow {
  key: "route" | "fit" | "capacity" | "latency" | "verdict";
  label: string;
  value: string;
  status: EvidenceStatus;
  rationale: string;
}

export interface SystemResponse {
  executionReadiness: number;
  continuityIndex: number;
  riskPressure: number;
  operabilityBand: OperabilityBand;
  decision: DecisionCode;
  signature: string;
  narrative: string;
  evidenceRows: SystemEvidenceRow[];
  narrativeByAxis: {
    readiness: string;
    continuity: string;
    risk: string;
  };
}

export interface Slide02SeedContext {
  route: Slide02RouteId;
  routeSource: RouteSourceKind;
  constraints: ConstraintValues;
  rawRouteInput?: string;
}

export interface ReplayEvent {
  seq: number;
  kind: ReplayEventKind;
  value?: Slide02RouteId | number | null;
}

export interface ReplayBase {
  route: Slide02RouteId;
  constraints: ConstraintValues;
}

export interface ReplayMeta {
  createdBy: string;
  createdAt: string;
  signature: string;
}

export interface ReplayPayload {
  version: "slide02.replay.v1";
  base: ReplayBase;
  trace: ReplayEvent[];
  meta: ReplayMeta;
}

export interface ReplayParseResult {
  ok: boolean;
  payload: ReplayPayload | null;
  error: string | null;
}

export interface Slide02ReplayState {
  stagedJson: string;
  stagedPayload: ReplayPayload | null;
  stagedError: string | null;
  lastAppliedSignature: string | null;
}

export interface Slide02TraceEntry {
  seq: number;
  action:
    | "boot"
    | "set-route"
    | "set-strictness"
    | "set-budget"
    | "set-latency"
    | "reset-constraints"
    | "replay-applied";
  before: {
    route: Slide02RouteId;
    constraints: ConstraintValues;
    signature: string;
  };
  after: {
    route: Slide02RouteId;
    constraints: ConstraintValues;
    signature: string;
  };
}

export interface Slide02MachineState {
  status: Slide02Status;
  seed: Slide02SeedContext;
  route: Slide02RouteId;
  constraints: ConstraintValues;
  response: SystemResponse;
  trace: Slide02TraceEntry[];
  hudOpen: boolean;
  replay: Slide02ReplayState;
  sequence: number;
}

export type Slide02MachineAction =
  | { type: "BOOT"; seed?: Partial<Slide02SeedContext> | null }
  | { type: "SET_ROUTE"; route: string }
  | { type: "SET_STRICTNESS"; value: number }
  | { type: "SET_BUDGET_GUARD"; value: number }
  | { type: "SET_LATENCY_GUARD"; value: number }
  | { type: "RESET_CONSTRAINTS" }
  | { type: "TOGGLE_HUD" }
  | { type: "REPLAY_STAGE_JSON"; json: string }
  | { type: "REPLAY_APPLY_STAGED" }
  | { type: "REPLAY_CLEAR" };

export interface ReplayApplicationResult {
  route: Slide02RouteId;
  constraints: ConstraintValues;
  response: SystemResponse;
  trace: ReplayEvent[];
}

export interface Slide02UiStrings {
  heading: string;
  subheading: string;
  hint: string;
  replayHint: string;
}

export interface Slide02SceneProps {
  uiStrings?: Partial<Slide02UiStrings>;
}
```

### FILE: components\slides\slide02-ui\core\useSlide02Machine.ts
```
import { useCallback, useMemo, useReducer } from "react";
import { createInitialSlide02State, reduceSlide02State } from "./fsm";
import {
  createReplayPayloadFromMachine,
  serializeReplayPayload,
} from "./replay";
import { resolveSlide02SeedContext, Slide02ContextInput } from "./context";
import { Slide02MachineState } from "./types";

function initState(seed: ReturnType<typeof resolveSlide02SeedContext>): Slide02MachineState {
  return createInitialSlide02State(seed);
}

export interface UseSlide02MachineApi {
  state: Slide02MachineState;
  setRoute: (route: string) => void;
  setStrictness: (value: number) => void;
  setBudgetGuard: (value: number) => void;
  setLatencyGuard: (value: number) => void;
  resetConstraints: () => void;
  toggleHud: () => void;
  stageReplay: (json: string) => void;
  applyReplay: () => void;
  clearReplay: () => void;
  exportReplayJson: () => string;
}

export function useSlide02Machine(seedInput?: Partial<Slide02ContextInput> | null): UseSlide02MachineApi {
  const seed = useMemo(() => resolveSlide02SeedContext(seedInput), [seedInput]);
  const [state, dispatch] = useReducer(reduceSlide02State, seed, initState);

  const setRoute = useCallback(
    (route: string) => {
      dispatch({ type: "SET_ROUTE", route });
    },
    [dispatch]
  );

  const setStrictness = useCallback(
    (value: number) => {
      dispatch({ type: "SET_STRICTNESS", value });
    },
    [dispatch]
  );

  const setBudgetGuard = useCallback(
    (value: number) => {
      dispatch({ type: "SET_BUDGET_GUARD", value });
    },
    [dispatch]
  );

  const setLatencyGuard = useCallback(
    (value: number) => {
      dispatch({ type: "SET_LATENCY_GUARD", value });
    },
    [dispatch]
  );

  const resetConstraints = useCallback(() => {
    dispatch({ type: "RESET_CONSTRAINTS" });
  }, [dispatch]);

  const toggleHud = useCallback(() => {
    dispatch({ type: "TOGGLE_HUD" });
  }, [dispatch]);

  const stageReplay = useCallback(
    (json: string) => {
      dispatch({ type: "REPLAY_STAGE_JSON", json });
    },
    [dispatch]
  );

  const applyReplay = useCallback(() => {
    dispatch({ type: "REPLAY_APPLY_STAGED" });
  }, [dispatch]);

  const clearReplay = useCallback(() => {
    dispatch({ type: "REPLAY_CLEAR" });
  }, [dispatch]);

  const exportReplayJson = useCallback(() => {
    const payload = createReplayPayloadFromMachine(
      state.route,
      state.constraints,
      state.trace,
      state.response.signature
    );

    return serializeReplayPayload(payload);
  }, [state.route, state.constraints, state.trace, state.response.signature]);

  return {
    state,
    setRoute,
    setStrictness,
    setBudgetGuard,
    setLatencyGuard,
    resetConstraints,
    toggleHud,
    stageReplay,
    applyReplay,
    clearReplay,
    exportReplayJson,
  };
}
```

### FILE: components\slides\slide02-ui\index.ts
```
export * from "./core";
export * from "./ui";
```

### FILE: components\slides\slide02-ui\styles.css
```
.slide02-root {
  position: relative;
  width: 100%;
  height: calc(100% - 86px);
  min-height: 520px;
  padding: 8px 44px 20px;
  box-sizing: border-box;
}

.slide02-scene {
  --s2-bg-0: #061116;
  --s2-bg-1: #0a1f28;
  --s2-bg-2: #112d36;
  --s2-cyan: #54e7ff;
  --s2-green: #73f1b3;
  --s2-warn: #ffd37a;
  --s2-risk: #ff8c7a;
  --s2-text: rgba(233, 244, 248, 0.94);
  --s2-text-dim: rgba(175, 207, 220, 0.76);
  --s2-border: rgba(110, 196, 224, 0.28);
  --s2-border-strong: rgba(110, 196, 224, 0.44);
  --s2-shadow: 0 18px 58px rgba(1, 9, 14, 0.64);

  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 22px;
  border: 1px solid rgba(126, 201, 227, 0.2);
  background:
    radial-gradient(900px 420px at 8% 8%, rgba(84, 231, 255, 0.18), rgba(0, 0, 0, 0) 72%),
    radial-gradient(860px 420px at 93% 96%, rgba(28, 149, 178, 0.24), rgba(0, 0, 0, 0) 76%),
    linear-gradient(142deg, var(--s2-bg-0), var(--s2-bg-1) 44%, var(--s2-bg-2));
  box-shadow: inset 0 0 0 1px rgba(132, 203, 228, 0.08), var(--s2-shadow);
  overflow: hidden;
  display: grid;
  grid-template-rows: auto auto auto 1fr auto;
  gap: 12px;
  padding: 18px 18px 16px;
}

.slide02-scene::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  background:
    linear-gradient(to right, rgba(190, 219, 232, 0.08) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(190, 219, 232, 0.08) 1px, transparent 1px);
  background-size: 34px 34px;
  opacity: 0.08;
}

.slide02-scene > * {
  position: relative;
  z-index: 1;
}

.slide02-top {
  display: grid;
  grid-template-columns: minmax(0, 1.3fr) minmax(0, 1fr);
  gap: 14px;
  align-items: start;
}

.slide02-top__heading-block {
  border-radius: 14px;
  border: 1px solid var(--s2-border);
  background: rgba(6, 22, 30, 0.68);
  padding: 12px 14px;
}

.slide02-top__title {
  margin: 0;
  font-size: clamp(20px, 1.8vw, 28px);
  line-height: 1.12;
  letter-spacing: 0.01em;
  color: var(--s2-text);
  font-weight: 700;
}

.slide02-top__subtitle {
  margin: 6px 0 0;
  font-size: 13px;
  line-height: 1.45;
  color: var(--s2-text-dim);
}

.slide02-top__hint {
  margin: 6px 0 0;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 11px;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: rgba(170, 224, 244, 0.86);
}

.slide02-top__meta {
  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;
}

.slide02-meta-pill {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 14px;
  border-radius: 12px;
  border: 1px solid var(--s2-border);
  background: rgba(6, 18, 24, 0.72);
  padding: 8px 10px;
}

.slide02-meta-pill__k {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: rgba(176, 214, 228, 0.68);
}

.slide02-meta-pill__v {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 11px;
  letter-spacing: 0.06em;
  color: rgba(222, 242, 250, 0.94);
  text-align: right;
}

.slide02-hud-toggle-wrap {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.slide02-status-pill {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border-radius: 999px;
  border: 1px solid var(--s2-border);
  background: rgba(5, 15, 20, 0.74);
  padding: 6px 10px;
}

.slide02-status-pill__label {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  color: rgba(167, 208, 225, 0.75);
}

.slide02-status-pill__value {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 11px;
  letter-spacing: 0.08em;
  color: rgba(233, 247, 253, 0.95);
}

.slide02-hud {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 8px;
  border-radius: 14px;
  border: 1px solid var(--s2-border-strong);
  background: rgba(5, 16, 22, 0.78);
  padding: 10px;
}

.slide02-hud__row {
  display: flex;
  align-items: baseline;
  gap: 8px;
  min-width: 0;
}

.slide02-hud__k {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  color: rgba(164, 207, 224, 0.72);
}

.slide02-hud__v {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 11px;
  letter-spacing: 0.03em;
  color: rgba(226, 243, 250, 0.96);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.slide02-grid {
  display: grid;
  grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
  gap: 12px;
  min-height: 0;
}

.slide02-panel {
  min-height: 0;
  border-radius: 16px;
  border: 1px solid var(--s2-border);
  background: rgba(5, 16, 22, 0.72);
  backdrop-filter: blur(9px) saturate(1.15);
  -webkit-backdrop-filter: blur(9px) saturate(1.15);
  box-shadow: inset 0 0 0 1px rgba(156, 218, 236, 0.06);
  padding: 12px;
}

.slide02-panel--controls {
  display: grid;
  grid-template-rows: auto auto auto auto auto auto;
  gap: 10px;
}

.slide02-panel--evidence {
  display: grid;
  grid-template-rows: auto auto 1fr auto;
  gap: 10px;
}

.slide02-panel--replay {
  display: grid;
  grid-template-rows: auto auto auto 1fr auto;
  gap: 10px;
}

.slide02-panel__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.slide02-panel__header--stack {
  align-items: flex-start;
  flex-direction: column;
}

.slide02-panel__title {
  margin: 0;
  font-size: 14px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: rgba(236, 248, 253, 0.97);
}

.slide02-panel__subtitle {
  margin: 4px 0 0;
  font-size: 12px;
  color: rgba(178, 211, 223, 0.82);
  line-height: 1.45;
}

.slide02-control-row {
  display: grid;
  grid-template-rows: auto auto auto;
  gap: 6px;
}

.slide02-control-row__head {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.slide02-control-label {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  color: rgba(174, 213, 228, 0.86);
}

.slide02-control-value {
  border-radius: 999px;
  border: 1px solid rgba(131, 200, 224, 0.38);
  padding: 3px 8px;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 11px;
  letter-spacing: 0.08em;
  color: rgba(237, 248, 253, 0.95);
}

.slide02-range {
  width: 100%;
  appearance: none;
  height: 5px;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(88, 228, 255, 0.65), rgba(133, 243, 199, 0.56));
  outline: none;
}

.slide02-range::-webkit-slider-thumb {
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 1px solid rgba(12, 42, 50, 0.96);
  background: #e7fbff;
  box-shadow: 0 0 0 6px rgba(84, 231, 255, 0.2), 0 4px 10px rgba(0, 0, 0, 0.35);
  cursor: pointer;
}

.slide02-range::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 1px solid rgba(12, 42, 50, 0.96);
  background: #e7fbff;
  box-shadow: 0 0 0 6px rgba(84, 231, 255, 0.2), 0 4px 10px rgba(0, 0, 0, 0.35);
  cursor: pointer;
}

.slide02-control-helper {
  margin: 0;
  font-size: 11px;
  color: rgba(163, 204, 220, 0.8);
  line-height: 1.4;
}

.slide02-select {
  width: 100%;
  border-radius: 10px;
  border: 1px solid rgba(128, 199, 224, 0.42);
  background: rgba(6, 19, 26, 0.84);
  color: rgba(229, 246, 252, 0.96);
  padding: 8px 10px;
  font-size: 13px;
}

.slide02-select:focus {
  outline: 1px solid rgba(100, 224, 255, 0.66);
}

.slide02-inline-summary {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}

.slide02-inline-summary__chip {
  border-radius: 999px;
  border: 1px solid rgba(128, 201, 224, 0.4);
  background: rgba(7, 23, 30, 0.7);
  padding: 4px 8px;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  color: rgba(202, 232, 243, 0.88);
}

.slide02-chip-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.slide02-chip {
  border-radius: 999px;
  border: 1px solid rgba(125, 196, 221, 0.38);
  padding: 4px 9px;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.14em;
  text-transform: uppercase;
}

.slide02-score-grid {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px;
}

.slide02-score-card {
  border-radius: 12px;
  border: 1px solid rgba(127, 199, 224, 0.34);
  background: rgba(7, 20, 27, 0.76);
  padding: 8px;
}

.slide02-score-card__label {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: rgba(164, 209, 226, 0.79);
}

.slide02-score-card__value {
  margin-top: 4px;
  font-size: 24px;
  letter-spacing: -0.01em;
  line-height: 1;
  color: rgba(236, 248, 253, 0.96);
  font-weight: 700;
}

.slide02-score-card__detail {
  margin-top: 6px;
  font-size: 11px;
  line-height: 1.4;
  color: rgba(174, 211, 224, 0.8);
}

.slide02-evidence-table {
  overflow: auto;
  min-height: 0;
  display: grid;
  gap: 8px;
  padding-right: 2px;
}

.slide02-evidence-row {
  border-radius: 12px;
  border: 1px solid rgba(127, 198, 223, 0.33);
  background: rgba(7, 20, 26, 0.75);
  padding: 8px;
}

.slide02-evidence-row__top {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
}

.slide02-evidence-row__label {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  color: rgba(172, 213, 229, 0.82);
}

.slide02-evidence-row__value {
  font-size: 12px;
  line-height: 1.3;
  color: rgba(232, 246, 252, 0.95);
  text-align: right;
}

.slide02-evidence-row__rationale {
  margin: 5px 0 0;
  font-size: 11px;
  line-height: 1.4;
  color: rgba(173, 210, 224, 0.78);
}

.slide02-signature-line {
  display: flex;
  align-items: baseline;
  gap: 8px;
  border-top: 1px dashed rgba(124, 194, 220, 0.35);
  padding-top: 8px;
}

.slide02-signature-line__label {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  color: rgba(167, 209, 223, 0.8);
}

.slide02-signature-line__value {
  font-family: "Consolas", "Courier New", monospace;
  font-size: 12px;
  letter-spacing: 0.05em;
  color: rgba(226, 243, 250, 0.98);
}

.slide02-replay-wrap {
  display: grid;
  grid-template-columns: minmax(0, 1fr) minmax(220px, 300px);
  gap: 10px;
}

.slide02-replay-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.slide02-replay-textarea {
  width: 100%;
  min-height: 146px;
  resize: vertical;
  border-radius: 11px;
  border: 1px solid rgba(123, 196, 220, 0.4);
  background: rgba(5, 17, 23, 0.86);
  color: rgba(225, 243, 250, 0.95);
  padding: 10px;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 11px;
  line-height: 1.38;
}

.slide02-replay-textarea:focus {
  outline: 1px solid rgba(95, 224, 255, 0.67);
}

.slide02-replay-error {
  border-radius: 10px;
  border: 1px solid rgba(255, 143, 122, 0.64);
  background: rgba(80, 24, 18, 0.62);
  color: rgba(255, 210, 200, 0.95);
  padding: 8px;
  font-size: 12px;
  line-height: 1.4;
}

.slide02-replay-note {
  border-radius: 14px;
  border: 1px solid rgba(126, 199, 224, 0.34);
  background: rgba(7, 21, 28, 0.76);
  color: rgba(181, 217, 230, 0.84);
  font-size: 12px;
  line-height: 1.5;
  padding: 10px;
}

.slide02-btn {
  border-radius: 10px;
  border: 1px solid rgba(123, 195, 220, 0.42);
  background: rgba(8, 23, 31, 0.7);
  color: rgba(230, 245, 251, 0.95);
  font-family: "Consolas", "Courier New", monospace;
  font-size: 10px;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  padding: 7px 10px;
  transition: border-color 0.18s ease, background-color 0.18s ease, transform 0.18s ease;
}

.slide02-btn:hover:not(:disabled) {
  border-color: rgba(141, 225, 255, 0.72);
  background: rgba(9, 31, 41, 0.8);
  transform: translateY(-1px);
}

.slide02-btn:disabled {
  opacity: 0.46;
  cursor: default;
}

.slide02-btn--primary {
  border-color: rgba(111, 239, 179, 0.62);
  background: rgba(13, 47, 37, 0.76);
}

.slide02-btn--ghost {
  border-color: rgba(107, 209, 238, 0.58);
  background: rgba(9, 30, 39, 0.68);
}

.slide02-btn--subtle {
  border-color: rgba(120, 177, 197, 0.4);
  background: rgba(8, 21, 28, 0.66);
}

.slide02-tone-good {
  border-color: rgba(116, 241, 181, 0.55) !important;
  color: rgba(195, 255, 226, 0.97) !important;
  background: rgba(10, 56, 40, 0.5) !important;
}

.slide02-tone-watch {
  border-color: rgba(255, 206, 116, 0.55) !important;
  color: rgba(255, 236, 186, 0.98) !important;
  background: rgba(64, 44, 10, 0.45) !important;
}

.slide02-tone-risk {
  border-color: rgba(255, 141, 121, 0.58) !important;
  color: rgba(255, 214, 204, 0.98) !important;
  background: rgba(73, 26, 20, 0.48) !important;
}

.slide02-tone-neutral {
  border-color: rgba(124, 195, 221, 0.4) !important;
  color: rgba(220, 241, 249, 0.92) !important;
  background: rgba(7, 22, 30, 0.66) !important;
}

@media (max-width: 1200px) {
  .slide02-root {
    padding-left: 20px;
    padding-right: 20px;
  }

  .slide02-grid {
    grid-template-columns: 1fr;
  }

  .slide02-score-grid {
    grid-template-columns: 1fr 1fr 1fr;
  }

  .slide02-replay-wrap {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 920px) {
  .slide02-root {
    padding: 6px 12px 18px;
    min-height: 560px;
  }

  .slide02-scene {
    grid-template-rows: auto auto auto auto 1fr auto;
    gap: 10px;
    padding: 14px;
    border-radius: 18px;
  }

  .slide02-top {
    grid-template-columns: 1fr;
    gap: 10px;
  }

  .slide02-hud {
    grid-template-columns: 1fr;
  }

  .slide02-score-grid {
    grid-template-columns: 1fr;
  }

  .slide02-btn {
    letter-spacing: 0.1em;
  }
}

@media (max-width: 680px) {
  .slide02-root {
    min-height: 620px;
    padding: 4px 8px 16px;
  }

  .slide02-scene {
    padding: 10px;
    border-radius: 14px;
    gap: 8px;
  }

  .slide02-top__title {
    font-size: 18px;
  }

  .slide02-top__subtitle {
    font-size: 12px;
  }

  .slide02-top__hint {
    font-size: 10px;
    letter-spacing: 0.07em;
  }

  .slide02-panel {
    border-radius: 12px;
    padding: 9px;
  }

  .slide02-panel__title {
    font-size: 12px;
  }

  .slide02-panel__subtitle {
    font-size: 11px;
  }

  .slide02-replay-textarea {
    min-height: 120px;
    font-size: 10px;
  }

  .slide02-chip {
    font-size: 9px;
  }
}
```

### FILE: components\slides\slide02-ui\ui\ControlsPanel.tsx
```
import React from "react";
import { ConstraintNarrative, ConstraintValues, RouteOption, Slide02RouteId } from "../core/types";
import { controlTone } from "../core/selectors";

type SliderControlProps = {
  id: string;
  testId: string;
  label: string;
  value: number;
  onChange: (nextValue: number) => void;
  valueTestId: string;
  helper: string;
  tone: "good" | "watch" | "risk";
};

const SliderControl: React.FC<SliderControlProps> = ({
  id,
  testId,
  label,
  value,
  onChange,
  valueTestId,
  helper,
  tone,
}) => {
  return (
    <div className="slide02-control-row">
      <div className="slide02-control-row__head">
        <label className="slide02-control-label" htmlFor={id}>
          {label}
        </label>
        <span
          data-testid={valueTestId}
          className={`slide02-control-value slide02-tone-${tone}`}
        >
          {value}
        </span>
      </div>

      <input
        id={id}
        data-testid={testId}
        className="slide02-range"
        type="range"
        min={0}
        max={100}
        step={1}
        value={value}
        onChange={(event) => onChange(Number(event.currentTarget.value))}
      />

      <p className="slide02-control-helper">{helper}</p>
    </div>
  );
};

type ControlsPanelProps = {
  route: Slide02RouteId;
  routeOptions: RouteOption[];
  constraints: ConstraintValues;
  narrative: ConstraintNarrative;
  onRouteChange: (route: string) => void;
  onStrictnessChange: (value: number) => void;
  onBudgetChange: (value: number) => void;
  onLatencyChange: (value: number) => void;
  onReset: () => void;
};

export const ControlsPanel: React.FC<ControlsPanelProps> = ({
  route,
  routeOptions,
  constraints,
  narrative,
  onRouteChange,
  onStrictnessChange,
  onBudgetChange,
  onLatencyChange,
  onReset,
}) => {
  const strictnessTone = controlTone(constraints.strictness, "strictness");
  const budgetTone = controlTone(constraints.budgetGuard, "budget");
  const latencyTone = controlTone(constraints.latencyGuard, "latency");

  return (
    <section data-testid="slide02-controls-panel" className="slide02-panel slide02-panel--controls">
      <div className="slide02-panel__header">
        <h3 className="slide02-panel__title">Constraint Tightening</h3>
        <button
          type="button"
          className="slide02-btn slide02-btn--subtle"
          data-testid="slide02-reset-constraints"
          onClick={onReset}
        >
          Reset Defaults
        </button>
      </div>

      <div className="slide02-control-row">
        <div className="slide02-control-row__head">
          <label htmlFor="slide02-route-select" className="slide02-control-label">
            Route Focus
          </label>
        </div>

        <select
          id="slide02-route-select"
          data-testid="slide02-route-select"
          className="slide02-select"
          value={route}
          onChange={(event) => onRouteChange(event.currentTarget.value)}
        >
          {routeOptions.map((option) => (
            <option key={option.id} value={option.id}>
              {option.label}
            </option>
          ))}
        </select>

        <p className="slide02-control-helper">
          Route selection anchors continuity for the next slides.
        </p>
      </div>

      <SliderControl
        id="slide02-strictness"
        testId="slide02-strictness-slider"
        label="Strictness"
        value={constraints.strictness}
        onChange={onStrictnessChange}
        valueTestId="slide02-strictness-value"
        helper="Governance depth and enforcement rigor across the route."
        tone={strictnessTone}
      />

      <SliderControl
        id="slide02-budget"
        testId="slide02-budget-slider"
        label="Budget Guard"
        value={constraints.budgetGuard}
        onChange={onBudgetChange}
        valueTestId="slide02-budget-value"
        helper="Execution headroom available for route delivery capacity."
        tone={budgetTone}
      />

      <SliderControl
        id="slide02-latency"
        testId="slide02-latency-slider"
        label="Latency Guard"
        value={constraints.latencyGuard}
        onChange={onLatencyChange}
        valueTestId="slide02-latency-value"
        helper="Tolerance for delayed response across handoffs and control loops."
        tone={latencyTone}
      />

      <div className="slide02-inline-summary">
        <span className="slide02-inline-summary__chip" data-testid="slide02-tightness-label">
          {narrative.tightnessLabel}
        </span>
        <span className="slide02-inline-summary__chip">{narrative.budgetPosture}</span>
        <span className="slide02-inline-summary__chip">{narrative.latencyPosture}</span>
      </div>
    </section>
  );
};
```

### FILE: components\slides\slide02-ui\ui\EvidencePanel.tsx
```
import React from "react";
import {
  Slide02EvidenceViewModel,
  statusLabel,
  toneClass,
} from "../core/selectors";
import { Slide02MachineState } from "../core/types";

type EvidencePanelProps = {
  evidence: Slide02EvidenceViewModel;
  signature: string;
  status: Slide02MachineState["status"];
};

const rowTestIdMap: Record<string, string> = {
  route: "slide02-evidence-row-route",
  fit: "slide02-evidence-row-fit",
  capacity: "slide02-evidence-row-capacity",
  latency: "slide02-evidence-row-latency",
  verdict: "slide02-evidence-row-verdict",
};

export const EvidencePanel: React.FC<EvidencePanelProps> = ({ evidence, signature, status }) => {
  return (
    <section data-testid="slide02-evidence-panel" className="slide02-panel slide02-panel--evidence">
      <div className="slide02-panel__header slide02-panel__header--stack">
        <div>
          <h3 className="slide02-panel__title">System Response</h3>
          <p className="slide02-panel__subtitle">
            Deterministic outputs computed directly from route + constraints.
          </p>
        </div>

        <div className="slide02-chip-row">
          <span
            data-testid="slide02-decision-chip"
            className={`slide02-chip ${toneClass(evidence.decisionBadge.tone)}`}
          >
            {evidence.decisionBadge.label}
          </span>
          <span
            data-testid="slide02-operability-band"
            className={`slide02-chip ${toneClass(evidence.bandBadge.tone)}`}
          >
            {evidence.bandBadge.label}
          </span>
          <span className="slide02-chip slide02-tone-neutral">{statusLabel(status)}</span>
        </div>
      </div>

      <div className="slide02-score-grid">
        {evidence.cards.map((card) => {
          const valueTestId =
            card.key === "readiness"
              ? "slide02-readiness-value"
              : card.key === "continuity"
              ? "slide02-continuity-value"
              : "slide02-risk-value";

          return (
            <article key={card.key} className={`slide02-score-card ${toneClass(card.tone)}`}>
              <div className="slide02-score-card__label">{card.label}</div>
              <div data-testid={valueTestId} className="slide02-score-card__value">
                {card.value}
              </div>
              <div className="slide02-score-card__detail">{card.detail}</div>
            </article>
          );
        })}
      </div>

      <div className="slide02-evidence-table">
        {evidence.rows.map((row) => (
          <article
            key={row.key}
            data-testid={rowTestIdMap[row.key]}
            className={`slide02-evidence-row ${toneClass(row.status)}`}
          >
            <div className="slide02-evidence-row__top">
              <div className="slide02-evidence-row__label">{row.label}</div>
              <div className="slide02-evidence-row__value">{row.value}</div>
            </div>
            <p className="slide02-evidence-row__rationale">{row.rationale}</p>
          </article>
        ))}
      </div>

      <div className="slide02-signature-line">
        <span className="slide02-signature-line__label">signature</span>
        <span data-testid="slide02-response-signature" className="slide02-signature-line__value">
          {signature}
        </span>
      </div>
    </section>
  );
};
```

### FILE: components\slides\slide02-ui\ui\HudToggle.tsx
```
import React from "react";

type HudToggleProps = {
  hudOpen: boolean;
  onToggle: () => void;
  statusValue: string;
  traceLength: number;
};

export const HudToggle: React.FC<HudToggleProps> = ({
  hudOpen,
  onToggle,
  statusValue,
  traceLength,
}) => {
  return (
    <div className="slide02-hud-toggle-wrap">
      <button
        type="button"
        onClick={onToggle}
        data-testid="slide02-hud-toggle"
        className="slide02-btn slide02-btn--ghost"
        aria-expanded={hudOpen}
      >
        {hudOpen ? "Hide HUD" : "Show HUD"}
      </button>
      <div data-testid="slide02-status" className="slide02-status-pill">
        <span className="slide02-status-pill__label">status</span>
        <span data-testid="slide02-status-value" className="slide02-status-pill__value">
          {statusValue}
        </span>
      </div>
      <div className="slide02-status-pill">
        <span className="slide02-status-pill__label">trace</span>
        <span data-testid="slide02-trace-length" className="slide02-status-pill__value">
          {traceLength}
        </span>
      </div>
    </div>
  );
};
```

### FILE: components\slides\slide02-ui\ui\index.ts
```
export * from "./ControlsPanel";
export * from "./EvidencePanel";
export * from "./HudToggle";
export * from "./ReplayPanel";
export * from "./Scene";
```

### FILE: components\slides\slide02-ui\ui\ReplayPanel.tsx
```
import React from "react";

type ReplayPanelProps = {
  replayJson: string;
  replayError: string | null;
  canApply: boolean;
  onReplayJsonChange: (value: string) => void;
  onExportReplay: () => void;
  onStageReplay: () => void;
  onApplyReplay: () => void;
  onClearReplay: () => void;
};

export const ReplayPanel: React.FC<ReplayPanelProps> = ({
  replayJson,
  replayError,
  canApply,
  onReplayJsonChange,
  onExportReplay,
  onStageReplay,
  onApplyReplay,
  onClearReplay,
}) => {
  return (
    <section data-testid="slide02-replay-panel" className="slide02-panel slide02-panel--replay">
      <div className="slide02-panel__header slide02-panel__header--stack">
        <div>
          <h3 className="slide02-panel__title">Replay Capture</h3>
          <p className="slide02-panel__subtitle">
            Capture deterministic route/constraint changes, stage JSON, and replay outputs.
          </p>
        </div>
      </div>

      <div className="slide02-replay-actions">
        <button
          type="button"
          className="slide02-btn slide02-btn--ghost"
          data-testid="slide02-replay-export"
          onClick={onExportReplay}
        >
          Export Replay JSON
        </button>

        <button
          type="button"
          className="slide02-btn slide02-btn--subtle"
          data-testid="slide02-replay-stage"
          onClick={onStageReplay}
        >
          Stage JSON
        </button>

        <button
          type="button"
          className="slide02-btn slide02-btn--primary"
          data-testid="slide02-replay-apply"
          onClick={onApplyReplay}
          disabled={!canApply}
        >
          Apply Replay
        </button>

        <button
          type="button"
          className="slide02-btn slide02-btn--subtle"
          data-testid="slide02-replay-clear"
          onClick={onClearReplay}
        >
          Clear Replay
        </button>
      </div>

      <label className="slide02-control-label" htmlFor="slide02-replay-textarea-input">
        Replay JSON
      </label>

      <textarea
        id="slide02-replay-textarea-input"
        data-testid="slide02-replay-textarea"
        className="slide02-replay-textarea"
        value={replayJson}
        onChange={(event) => onReplayJsonChange(event.currentTarget.value)}
        placeholder='{"version":"slide02.replay.v1", ...}'
      />

      {replayError ? (
        <div data-testid="slide02-replay-error" className="slide02-replay-error">
          {replayError}
        </div>
      ) : null}
    </section>
  );
};
```

### FILE: components\slides\slide02-ui\ui\Scene.tsx
```
import React, { useMemo, useState } from "react";
import { describeConstraints, getRouteOption, SLIDE02_ROUTE_OPTIONS } from "../core/model";
import { statusLabel, buildEvidenceViewModel, buildHudSummary } from "../core/selectors";
import { useSlide02Machine } from "../core/useSlide02Machine";
import { Slide02SceneProps } from "../core/types";
import { routeSourceLabel } from "../core/context";
import { ControlsPanel } from "./ControlsPanel";
import { EvidencePanel } from "./EvidencePanel";
import { HudToggle } from "./HudToggle";
import { ReplayPanel } from "./ReplayPanel";
import "../styles.css";

const DEFAULT_UI_STRINGS = {
  heading: "Bridge: Constraint Tightening",
  subheading:
    "Slide02 closes the gap between route selection and execution confidence.",
  hint:
    "Adjust 2-3 controls to tighten the operating window. Evidence updates deterministically.",
  replayHint:
    "Replay is deterministic: same payload always yields the same signature.",
};

export const Scene: React.FC<Slide02SceneProps> = ({ uiStrings }) => {
  const mergedStrings = {
    ...DEFAULT_UI_STRINGS,
    ...(uiStrings ?? {}),
  };

  const machine = useSlide02Machine();
  const { state } = machine;

  const [replayDraft, setReplayDraft] = useState("");

  const narrative = useMemo(() => describeConstraints(state.constraints), [state.constraints]);
  const evidence = useMemo(() => buildEvidenceViewModel(state), [state]);
  const hudSummary = useMemo(() => buildHudSummary(state), [state]);
  const routeOption = useMemo(() => getRouteOption(state.route), [state.route]);

  const onExportReplay = () => {
    const nextJson = machine.exportReplayJson();
    setReplayDraft(nextJson);
  };

  const onStageReplay = () => {
    machine.stageReplay(replayDraft);
  };

  const onApplyReplay = () => {
    machine.applyReplay();
  };

  const onClearReplay = () => {
    setReplayDraft("");
    machine.clearReplay();
  };

  return (
    <section data-testid="slide02-root" className="slide02-root">
      <div data-testid="slide02-scene" className="slide02-scene">
        <header className="slide02-top">
          <div className="slide02-top__heading-block">
            <h3 className="slide02-top__title">{mergedStrings.heading}</h3>
            <p className="slide02-top__subtitle">{mergedStrings.subheading}</p>
            <p className="slide02-top__hint">{mergedStrings.hint}</p>
          </div>

          <div className="slide02-top__meta">
            <div className="slide02-meta-pill">
              <span className="slide02-meta-pill__k">route source</span>
              <span data-testid="slide02-route-source" className="slide02-meta-pill__v">
                {routeSourceLabel(state.seed.routeSource)}
              </span>
            </div>
            <div className="slide02-meta-pill">
              <span className="slide02-meta-pill__k">seed route</span>
              <span data-testid="slide02-seed-route" className="slide02-meta-pill__v">
                {state.seed.route}
              </span>
            </div>
            <div className="slide02-meta-pill">
              <span className="slide02-meta-pill__k">active route</span>
              <span className="slide02-meta-pill__v">{routeOption.label}</span>
            </div>
          </div>
        </header>

        <HudToggle
          hudOpen={state.hudOpen}
          onToggle={machine.toggleHud}
          statusValue={statusLabel(state.status)}
          traceLength={state.trace.length}
        />

        {state.hudOpen ? (
          <aside data-testid="slide02-hud" className="slide02-hud">
            <div className="slide02-hud__row">
              <span className="slide02-hud__k">Route</span>
              <span data-testid="slide02-hud-route" className="slide02-hud__v">
                {hudSummary.route}
              </span>
            </div>
            <div className="slide02-hud__row">
              <span className="slide02-hud__k">Constraints</span>
              <span data-testid="slide02-hud-constraints" className="slide02-hud__v">
                {hudSummary.constraints}
              </span>
            </div>
            <div className="slide02-hud__row">
              <span className="slide02-hud__k">Status</span>
              <span data-testid="slide02-hud-status" className="slide02-hud__v">
                {hudSummary.status}
              </span>
            </div>
            <div className="slide02-hud__row">
              <span className="slide02-hud__k">Signature</span>
              <span data-testid="slide02-hud-signature" className="slide02-hud__v">
                {hudSummary.signature}
              </span>
            </div>
          </aside>
        ) : null}

        <div className="slide02-grid">
          <ControlsPanel
            route={state.route}
            routeOptions={SLIDE02_ROUTE_OPTIONS}
            constraints={state.constraints}
            narrative={narrative}
            onRouteChange={machine.setRoute}
            onStrictnessChange={machine.setStrictness}
            onBudgetChange={machine.setBudgetGuard}
            onLatencyChange={machine.setLatencyGuard}
            onReset={machine.resetConstraints}
          />

          <EvidencePanel
            evidence={evidence}
            signature={state.response.signature}
            status={state.status}
          />
        </div>

        <div className="slide02-replay-wrap">
          <ReplayPanel
            replayJson={replayDraft}
            replayError={state.replay.stagedError}
            canApply={Boolean(state.replay.stagedPayload)}
            onReplayJsonChange={setReplayDraft}
            onExportReplay={onExportReplay}
            onStageReplay={onStageReplay}
            onApplyReplay={onApplyReplay}
            onClearReplay={onClearReplay}
          />

          <div className="slide02-replay-note">{mergedStrings.replayHint}</div>
        </div>
      </div>
    </section>
  );
};
```

### FILE: docs\slide02\00-contract.md
```
# Slide02 Contract

Version: `slide02-contract.v1`

Date: `2026-02-10`

Scope:
- `components/slides/Slide02.tsx`
- `components/slides/slide02-ui/**`
- `tests/e2e/slide02-bridge-smoke.e2e.spec.ts`

## 1) Product Intent

Slide02 is the bridge between problem framing and execution proof.
It must feel continuous, deterministic, and never block progression.
The slide tightens system constraints from an incoming route signal and responds live with deterministic evidence.

Core promise:
- If prior slides provide no context, Slide02 still renders a valid route + constraints model.
- Any control change updates deterministic response panels immediately.
- Replay capture and playback reproduce the same output signature without randomness.

## 2) Hard Constraints

- No autoplay logic in Slide02.
- No timer-driven transitions.
- No randomization.
- No polling loops.
- Reducer and model are pure and deterministic.
- `Slide02.tsx` remains thin and delegates to `slide02-ui` modules.
- HUD is off by default.

## 3) Canonical Domain Model

### 3.1 Route IDs

Allowed route IDs:
- `stabilize-operations`
- `throughput-push`
- `margin-defense`
- `quality-ringfence`

Default route:
- `stabilize-operations`

### 3.2 Constraints

Each constraint is integer `0..100`.

- `strictness`:
  - Meaning: policy rigor and enforcement depth.
  - Higher value increases compliance confidence and coordination overhead.

- `budgetGuard`:
  - Meaning: financial headroom available to execute route.
  - Higher value improves implementation capacity.

- `latencyGuard`:
  - Meaning: tolerance for operational response latency.
  - Higher value means slower response tolerated.

Default constraints:
- `strictness = 56`
- `budgetGuard = 62`
- `latencyGuard = 38`

### 3.3 System Response

Outputs are deterministic from route + constraints:

- `executionReadiness` (0..100)
- `continuityIndex` (0..100)
- `riskPressure` (0..100)
- `operabilityBand` (`Fragile` | `Managed` | `Stable` | `Hardened`)
- `decision` (`HOLD` | `TIGHTEN` | `PROCEED` | `PROCEED+`)
- `signature` (stable string hash for replay and smoke assertions)

### 3.4 Evidence Rows

Evidence panel shows deterministic rows:
- `Route Signal` (source + normalized route)
- `Constraint Fit` (tightness interpretation)
- `Execution Capacity` (budget and strictness relation)
- `Latency Exposure` (latency risk view)
- `Bridge Verdict` (deterministic decision)

Each row has:
- label
- value
- status (`good` | `watch` | `risk`)
- rationale text

## 4) State Machine Contract

### 4.1 State Shape

`Slide02MachineState` includes:
- `status`
- `seed`
- `route`
- `constraints`
- `response`
- `trace`
- `hud`
- `replay`

### 4.2 Status Enum

- `BOOTSTRAPPED`: initial model is available.
- `INTERACTIVE`: user has made at least one deterministic change.
- `REPLAY_READY`: JSON replay parsed and staged.
- `REPLAY_APPLIED`: staged replay applied; outputs recomputed.
- `REPLAY_ERROR`: invalid replay payload or parse issue.

### 4.3 Actions

- `BOOT`
- `SET_ROUTE`
- `SET_STRICTNESS`
- `SET_BUDGET_GUARD`
- `SET_LATENCY_GUARD`
- `RESET_CONSTRAINTS`
- `TOGGLE_HUD`
- `REPLAY_STAGE_JSON`
- `REPLAY_APPLY_STAGED`
- `REPLAY_CLEAR`

### 4.4 Transition Rules

1. `BOOT -> BOOTSTRAPPED`
2. Control actions from `BOOTSTRAPPED|INTERACTIVE|REPLAY_APPLIED` -> `INTERACTIVE`
3. `REPLAY_STAGE_JSON` with valid payload -> `REPLAY_READY`
4. `REPLAY_STAGE_JSON` with invalid payload -> `REPLAY_ERROR`
5. `REPLAY_APPLY_STAGED` from `REPLAY_READY` -> `REPLAY_APPLIED`
6. `REPLAY_CLEAR` always clears staged replay and returns:
   - `INTERACTIVE` if trace not empty
   - else `BOOTSTRAPPED`

### 4.5 Determinism Rule

For fixed input tuple `(route, strictness, budgetGuard, latencyGuard)`, output tuple `(executionReadiness, continuityIndex, riskPressure, operabilityBand, decision, signature)` must always match.

## 5) Defensive Defaults Contract

Slide02 must never throw when prior context is absent or malformed.

Seed context resolution order:
1. URL query (`?route=...`)
2. `window.history.state.route` if available
3. `localStorage` keys:
   - `inversion.selectedRoute`
   - `inversion.route`
   - `hitech.selectedRoute`
   - `hitech.route`
4. Fallback default route

Constraint seeds use parser + clamp + integer rounding.

Malformed values are ignored and replaced by defaults.

## 6) Replay Contract

### 6.1 Replay JSON Envelope

```json
{
  "version": "slide02.replay.v1",
  "base": {
    "route": "stabilize-operations",
    "constraints": {
      "strictness": 56,
      "budgetGuard": 62,
      "latencyGuard": 38
    }
  },
  "trace": [
    {
      "seq": 1,
      "kind": "set-route",
      "value": "margin-defense"
    },
    {
      "seq": 2,
      "kind": "set-strictness",
      "value": 71
    }
  ],
  "meta": {
    "createdBy": "slide02-ui",
    "createdAt": "deterministic-local",
    "signature": "sig-example"
  }
}
```

### 6.2 Replay Validation

A replay is valid if:
- `version === "slide02.replay.v1"`
- `base.route` is known route
- base constraints are finite numbers
- `trace` is an array of known event kinds
- `seq` values are positive integers and strictly increasing after sanitization

### 6.3 Replay Application

Replay apply algorithm:
1. Build base state from `base` payload.
2. Apply trace events in sequence order.
3. Recompute response via model per event.
4. Final state gets `REPLAY_APPLIED`.
5. Final signature must equal deterministic model output.

## 7) Test IDs Contract

All listed test IDs must exist.

### 7.1 Root & Status

- `slide02-root`
- `slide02-scene`
- `slide02-status`
- `slide02-status-value`
- `slide02-route-source`
- `slide02-seed-route`
- `slide02-trace-length`
- `slide02-response-signature`

### 7.2 Controls Panel

- `slide02-controls-panel`
- `slide02-route-select`
- `slide02-strictness-slider`
- `slide02-budget-slider`
- `slide02-latency-slider`
- `slide02-reset-constraints`

### 7.3 Constraint Readouts

- `slide02-strictness-value`
- `slide02-budget-value`
- `slide02-latency-value`
- `slide02-tightness-label`

### 7.4 Evidence Panel

- `slide02-evidence-panel`
- `slide02-evidence-row-route`
- `slide02-evidence-row-fit`
- `slide02-evidence-row-capacity`
- `slide02-evidence-row-latency`
- `slide02-evidence-row-verdict`
- `slide02-decision-chip`
- `slide02-operability-band`
- `slide02-readiness-value`
- `slide02-continuity-value`
- `slide02-risk-value`

### 7.5 Replay Panel

- `slide02-replay-panel`
- `slide02-replay-export`
- `slide02-replay-textarea`
- `slide02-replay-stage`
- `slide02-replay-apply`
- `slide02-replay-clear`
- `slide02-replay-error`

### 7.6 HUD

- `slide02-hud-toggle`
- `slide02-hud`
- `slide02-hud-route`
- `slide02-hud-constraints`
- `slide02-hud-status`
- `slide02-hud-signature`

## 8) UX Contract

### 8.1 First Paint

On first render Slide02 shows:
- One valid route selected.
- Sliders set to defaults or sanitized seeds.
- Evidence panel with deterministic outputs.
- HUD hidden.

### 8.2 Interaction

When user changes controls:
- UI updates immediately.
- Trace length increments for effective changes.
- Response signature updates deterministically.

### 8.3 Replay

Replay flow:
1. Export current replay JSON.
2. Paste JSON in textarea.
3. Stage JSON.
4. Apply replay.
5. Evidence outputs match deterministic replay result.

## 9) E2E Smoke Assertions

The smoke test must prove:
- Navigation can reach Slide02.
- Slide02 renders baseline outputs.
- Two controls change outputs (signature changes).
- Replay stage/apply path is valid.
- Final state remains deterministic and stable.

## 10) Unit Spec Contract

Required unit coverage:
- Model formulas and band classification.
- Reducer transitions and defensive clamps.
- Replay parse/sanitize/apply determinism.

## 11) Reducer Invariants

Invariant list:
1. Route is always a known route.
2. Constraint values always stay integer `0..100`.
3. Response signature always non-empty.
4. Trace events sequence values strictly increase.
5. `REPLAY_APPLY_STAGED` without staged payload is no-op.
6. `REPLAY_CLEAR` removes replay errors.
7. `RESET_CONSTRAINTS` keeps route and source.

## 12) Replay Invariants

1. Re-exporting replay after apply must produce a valid payload.
2. Parsing invalid JSON never throws past parser boundary.
3. Unknown trace kinds are ignored during sanitization.
4. Duplicate seq values are normalized during sanitization.
5. Missing meta object is auto-filled.

## 13) Accessibility Contract

- Every slider has visible label.
- Every slider has deterministic `data-testid`.
- Route selector is keyboard accessible.
- Replay textarea has accessible label text.
- Buttons are keyboard reachable in source order.

## 14) Failure Semantics

Failures are explicit and non-fatal:
- Invalid replay text -> `REPLAY_ERROR`, message shown in panel.
- Missing staged replay on apply -> state unchanged.
- Malformed seed context -> fallback defaults + continue.

## 15) Route Normalization Rules

Accepted aliases map to canonical route IDs:
- `stabilize`, `ops`, `stability` -> `stabilize-operations`
- `throughput`, `speed`, `flow` -> `throughput-push`
- `margin`, `cost`, `defense` -> `margin-defense`
- `quality`, `qa`, `ringfence` -> `quality-ringfence`

Unknown routes resolve to default route.

## 16) Constraint Narratives

Tightness labels:
- `0..24` => `Loose Window`
- `25..49` => `Guided`
- `50..74` => `Tightened`
- `75..100` => `Hard Lock`

Budget posture labels:
- `0..29` => `Constrained`.
- `30..59` => `Balanced`.
- `60..100` => `Funded`.

Latency exposure labels:
- `0..29` => `Low latency tolerance`.
- `30..59` => `Moderate latency tolerance`.
- `60..100` => `High latency tolerance`.

## 17) Deterministic Signature Contract

Signature format:
- `S2|{routeCode}|{readiness}|{continuity}|{risk}|{decisionCode}|{bandCode}`

Route codes:
- `OPS`
- `THR`
- `MRG`
- `QLT`

Decision codes:
- `H`
- `T`
- `P`
- `PP`

Band codes:
- `F`
- `M`
- `S`
- `H`

## 18) Model Scenario Matrix (Reference)

This matrix is normative for unit specs.

| Scenario | Route | strictness | budget | latency | Expected decision | Expected band |
|---|---|---:|---:|---:|---|---|
| baseline default | stabilize-operations | 56 | 62 | 38 | PROCEED | Stable |
| budget collapse | stabilize-operations | 56 | 10 | 38 | PROCEED | Managed |
| strict heavy funded | margin-defense | 78 | 80 | 22 | PROCEED | Stable |
| latency loose | throughput-push | 44 | 71 | 84 | TIGHTEN | Managed |
| quality hard lock | quality-ringfence | 90 | 64 | 12 | PROCEED | Stable |
| low strictness low budget | throughput-push | 20 | 20 | 50 | HOLD | Fragile |
| high strictness low budget | margin-defense | 88 | 28 | 30 | PROCEED | Managed |
| medium balanced | stabilize-operations | 50 | 50 | 50 | PROCEED | Managed |
| low latency high budget | throughput-push | 40 | 76 | 18 | PROCEED | Stable |
| extreme latency + low budget | throughput-push | 48 | 22 | 92 | HOLD | Fragile |

## 19) Replay Scenario Matrix

| Scenario | Replay Valid | Result Status |
|---|---|---|
| Valid payload, ordered seq | yes | REPLAY_APPLIED |
| Valid payload, unordered seq | yes (sanitized) | REPLAY_APPLIED |
| Unknown route alias in base | yes (normalized) | REPLAY_APPLIED |
| Unknown event kind | yes (ignored) | REPLAY_APPLIED |
| Invalid JSON text | no | REPLAY_ERROR |
| Missing version | no | REPLAY_ERROR |
| Missing base constraints | no | REPLAY_ERROR |

## 20) Coverage Map

Files expected:
- `components/slides/slide02-ui/core/model.ts`
- `components/slides/slide02-ui/core/fsm.ts`
- `components/slides/slide02-ui/core/replay.ts`
- `components/slides/slide02-ui/core/context.ts`
- `components/slides/slide02-ui/ui/ControlsPanel.tsx`
- `components/slides/slide02-ui/ui/EvidencePanel.tsx`
- `components/slides/slide02-ui/ui/HudToggle.tsx`
- `components/slides/slide02-ui/ui/Scene.tsx`
- `components/slides/slide02-ui/ui/ReplayPanel.tsx`

## 21) Non-goals

Out of scope for this iteration:
- Cross-slide global store refactors.
- Async backend calls.
- New keyboard shortcuts.
- New autoplay behavior.

## 22) Acceptance Checklist

- [ ] Slide02 renders with no upstream context.
- [ ] Control changes are deterministic.
- [ ] Replay export works.
- [ ] Replay stage/apply works.
- [ ] HUD defaults to hidden.
- [ ] Documented IDs exist in rendered UI.
- [ ] Smoke e2e passes.
- [ ] Unit specs pass for model/fsm/replay.

## 23) Maintenance Notes

- Keep route aliases centralized in model.
- Keep replay schema versioned.
- Keep reducer pure and side-effect free.
- Keep `Slide02.tsx` thin; feature logic belongs in `slide02-ui`.

## 24) Review Gate

Before merge, reviewer should validate:
1. No timer APIs introduced.
2. No randomness APIs introduced.
3. No hidden state outside reducer for core logic.
4. No non-deterministic replay operations.

## 25) Appendix: Control Semantics

### Route selector

Changing route updates:
- route label
- route evidence row
- response metrics
- signature
- trace length

### Strictness slider

Increasing strictness generally:
- improves compliance confidence
- can reduce agility when budget is low
- often lowers risk when budget is moderate/high

### Budget slider

Increasing budget generally:
- increases readiness and continuity
- reduces risk pressure
- improves decision tendency toward proceed

### Latency slider

Increasing latency tolerance generally:
- increases risk pressure
- can downgrade decision
- can reduce continuity when strictness is low

## 26) Appendix: Glossary

- Bridge: The continuity layer between diagnostic problem framing and traction evidence.
- Constraint Tightening: Operator-driven narrowing of acceptable execution window.
- Signature: Deterministic compressed state marker used for replay equality checks.
- Operability Band: Human-readable operating confidence zone derived from metrics.

## 27) Appendix: Deterministic Design Notes

Design principles used:
- No hidden mutable global state.
- No elapsed-time branching.
- No random seeds.
- Pure computation path from state to response.

## 28) Appendix: Test Author Notes

When extending tests:
- Prefer explicit numeric fixtures over generated data.
- Assert both semantic outputs and signature.
- Cover invalid replay payloads and malformed seed inputs.
- Keep smoke test path compact and deterministic.
```

### FILE: docs\slide02\REPORT.md
```
# Slide02 Implementation Report

Date: `2026-02-10`

Owner: `Codex Agent #2`

Scope:
- `components/slides/Slide02.tsx`
- `components/slides/slide02-ui/**`
- `tests/e2e/slide02-bridge-smoke.e2e.spec.ts`
- `docs/slide02/00-contract.md`
- `docs/slide02/REPORT.md`

## 1) Executive Summary

Slide02 was rebuilt as a deterministic bridge layer with a thin entry slide and modular `slide02-ui` runtime.

Delivered outcomes:
- Deterministic reducer/FSM for route + constraints with defensive defaults.
- Compact controls panel with 3 constraints and route selector.
- Live evidence panel driven only by reducer/model outputs.
- Replay capture (export JSON) and replay stage/apply path.
- Dev HUD toggle (default OFF) exposing runtime internals.
- Unit suite for model, reducer, replay, and context resolution.
- One Playwright smoke spec authored for Slide02.

Important environment note:
- Two Playwright attempts were executed and both aborted pre-test due occupied `http://127.0.0.1:3200` (existing process outside this run).
- E2E run cap reached (`2/2`) without test body execution.

## 2) Scope Compliance

### Allowed-path compliance

Edits were constrained to:
- `components/slides/slide02-ui/**`
- `components/slides/Slide02.tsx`
- `tests/e2e/**` (Slide02 file only)
- `docs/slide02/**`

### Additive-only

No unrelated slide modules were refactored.
No public APIs were renamed.
No autoplay/timer/random branches were introduced.

## 3) Architecture

## 3.1 Thin slide wrapper

`components/slides/Slide02.tsx` now:
- renders shell (`SlideContainer`, `Header`, `NavArea`)
- renders `Scene` from `slide02-ui`
- carries no domain logic

## 3.2 Core modules

`components/slides/slide02-ui/core/types.ts`
- canonical type contracts for model, reducer, replay, UI state

`components/slides/slide02-ui/core/model.ts`
- route catalog
- route alias normalization
- constraint sanitization/clamping
- deterministic scoring + decision + band classification
- signature generation
- evidence row composition

`components/slides/slide02-ui/core/context.ts`
- defensive seed context resolution
- precedence and source labeling
- query/history/storage/external payload normalization

`components/slides/slide02-ui/core/fsm.ts`
- pure reducer and initial state factory
- explicit actions (`SET_ROUTE`, `SET_STRICTNESS`, replay actions, etc.)
- trace sequence invariants
- replay stage/apply/error transitions

`components/slides/slide02-ui/core/replay.ts`
- replay payload schema utilities
- trace sanitization and sequence normalization
- parse/serialize/apply helpers
- deterministic replay application path

`components/slides/slide02-ui/core/selectors.ts`
- view model derivations for evidence cards/badges/HUD

`components/slides/slide02-ui/core/useSlide02Machine.ts`
- thin hook around reducer dispatch + replay export helper

## 3.3 UI modules

`components/slides/slide02-ui/ui/ControlsPanel.tsx`
- route select
- strictness slider
- budget slider
- latency slider
- default reset

`components/slides/slide02-ui/ui/EvidencePanel.tsx`
- decision/band chips
- three score cards
- deterministic evidence rows
- signature display

`components/slides/slide02-ui/ui/ReplayPanel.tsx`
- export/stage/apply/clear replay controls
- replay JSON textarea
- error display

`components/slides/slide02-ui/ui/HudToggle.tsx`
- HUD toggle button
- status + trace summary chips

`components/slides/slide02-ui/ui/Scene.tsx`
- assembles controls/evidence/replay/hud
- binds hook actions
- exposes test ids

`components/slides/slide02-ui/styles.css`
- complete visual styling and responsive behavior

## 4) Deterministic Model Notes

Inputs:
- `route`
- `strictness`
- `budgetGuard`
- `latencyGuard`

Outputs:
- `executionReadiness`
- `continuityIndex`
- `riskPressure`
- `operabilityBand`
- `decision`
- `signature`

Determinism controls:
- integer clamping to `0..100`
- route normalization fallback
- pure function scoring
- no random/timer dependencies

Signature format:
- `S2|{routeCode}|{readiness}|{continuity}|{risk}|{decisionCode}|{bandCode}`

## 5) Reducer/FSM Notes

Statuses:
- `BOOTSTRAPPED`
- `INTERACTIVE`
- `REPLAY_READY`
- `REPLAY_APPLIED`
- `REPLAY_ERROR`

Action families:
- boot/setup: `BOOT`
- control changes: `SET_ROUTE`, `SET_STRICTNESS`, `SET_BUDGET_GUARD`, `SET_LATENCY_GUARD`, `RESET_CONSTRAINTS`
- view: `TOGGLE_HUD`
- replay: `REPLAY_STAGE_JSON`, `REPLAY_APPLY_STAGED`, `REPLAY_CLEAR`

Trace semantics:
- sequence starts at boot event
- each effective change appends trace entry
- before/after snapshots include signature

## 6) Defensive Defaults

If prior slides provide nothing, Slide02 still renders valid output.

Context precedence:
1. manual/external seed
2. URL query
3. `window.history.state`
4. storage keys
5. static default

Storage keys scanned:
- `inversion.selectedRoute`
- `inversion.route`
- `hitech.selectedRoute`
- `hitech.route`
- plus optional slide02 constraint keys

## 7) Replay Contract (MVP)

Supported replay kinds:
- `set-route`
- `set-strictness`
- `set-budget`
- `set-latency`
- `reset-constraints`

Replay flow:
1. export current route/constraints/trace -> JSON
2. paste/edit JSON in textarea
3. stage JSON (parse + validate)
4. apply staged replay
5. deterministic final signature

Error path:
- invalid parse or version -> `REPLAY_ERROR` + message

## 8) Test IDs Delivered

All IDs listed in `docs/slide02/00-contract.md` were implemented.

Highlights:
- root/status/signature
- all controls
- all evidence rows
- replay controls/textarea/error
- HUD internals

## 9) Test Coverage Delivered

## 9.1 Unit suites

Location:
- `components/slides/slide02-ui/core/model.spec.ts`
- `components/slides/slide02-ui/core/fsm.spec.ts`
- `components/slides/slide02-ui/core/replay.spec.ts`
- `components/slides/slide02-ui/core/context.spec.ts`
- runner: `components/slides/slide02-ui/core/run-slide02-unit.ts`

Coverage themes:
- model scenario matrix and signature determinism
- reducer transitions/no-op/invariants
- replay parse/sanitize/apply determinism
- context source precedence and sanitization

## 9.2 Playwright smoke spec

Location:
- `tests/e2e/slide02-bridge-smoke.e2e.spec.ts`

Path asserts:
- navigate to Slide02
- change route + controls
- signature changes deterministically
- export/stage/apply replay
- final signature stability
- HUD reflection

## 10) Validation Commands + Logs

## 10.1 Slide02 unit runner

Command:

```bash
npx tsx components/slides/slide02-ui/core/run-slide02-unit.ts
```

Result:

```text
[slide02-unit] PASS slide02-model passed=14 failed=0
[slide02-unit] PASS slide02-fsm passed=23 failed=0
[slide02-unit] PASS slide02-replay passed=15 failed=0
[slide02-unit] PASS slide02-context passed=16 failed=0
[slide02-unit] PASS
```

## 10.2 Typecheck

Command:

```bash
npm run typecheck
```

Result:

```text
> copy-of-hitech-rts-a---deck-v32@0.0.0 typecheck
> tsc -p tsconfig.verify.json --noEmit
```

## 10.3 Build

Command:

```bash
npm run build
```

Result (excerpt):

```text
[client-boundary] PASS no client exposure findings
[no-rework] PASS
vite v6.4.1 building for production...
✓ 202 modules transformed.
✓ built in 5.98s
```

## 10.4 Playwright smoke (attempt 1/2)

Command:

```bash
npx playwright test tests/e2e/slide02-bridge-smoke.e2e.spec.ts
```

Result:

```text
Error: http://127.0.0.1:3200 is already used, make sure that nothing is running on the port/url or set reuseExistingServer:true in config.webServer.
```

## 10.5 Playwright smoke (attempt 2/2)

Command:

```bash
npx playwright test tests/e2e/slide02-bridge-smoke.e2e.spec.ts
```

Result:

```text
Error: http://127.0.0.1:3200 is already used, make sure that nothing is running on the port/url or set reuseExistingServer:true in config.webServer.
```

## 11) Known Environment Constraints

Observed behavior:
- `http://127.0.0.1:3200` returns live HTML from a pre-existing server process not controlled by this run.
- Playwright config uses `webServer` with `reuseExistingServer: false`, so it fails before test execution when port is already occupied.
- Max e2e run cap reached; no additional Playwright executions were performed.

Impact:
- authored smoke spec is present and syntactically valid.
- runtime smoke execution is blocked by external port ownership in this session.

## 12) Risks / Residuals

- Residual: smoke spec not executed to completion in this environment due pre-existing server conflict.
- Mitigation: unit/model/replay/context coverage is high and build passes.

## 13) File Inventory (new/updated)

Updated:
- `components/slides/Slide02.tsx`
- `docs/slide02/00-contract.md`

New core:
- `components/slides/slide02-ui/core/types.ts`
- `components/slides/slide02-ui/core/model.ts`
- `components/slides/slide02-ui/core/context.ts`
- `components/slides/slide02-ui/core/fsm.ts`
- `components/slides/slide02-ui/core/replay.ts`
- `components/slides/slide02-ui/core/selectors.ts`
- `components/slides/slide02-ui/core/useSlide02Machine.ts`
- `components/slides/slide02-ui/core/fixtures.ts`
- `components/slides/slide02-ui/core/test-utils.ts`
- `components/slides/slide02-ui/core/model.spec.ts`
- `components/slides/slide02-ui/core/fsm.spec.ts`
- `components/slides/slide02-ui/core/replay.spec.ts`
- `components/slides/slide02-ui/core/context.spec.ts`
- `components/slides/slide02-ui/core/run-slide02-unit.ts`
- `components/slides/slide02-ui/core/index.ts`

New UI:
- `components/slides/slide02-ui/ui/ControlsPanel.tsx`
- `components/slides/slide02-ui/ui/EvidencePanel.tsx`
- `components/slides/slide02-ui/ui/HudToggle.tsx`
- `components/slides/slide02-ui/ui/ReplayPanel.tsx`
- `components/slides/slide02-ui/ui/Scene.tsx`
- `components/slides/slide02-ui/ui/index.ts`

New style/export:
- `components/slides/slide02-ui/styles.css`
- `components/slides/slide02-ui/index.ts`

New e2e:
- `tests/e2e/slide02-bridge-smoke.e2e.spec.ts`

New docs:
- `docs/slide02/REPORT.md`

## 14) Completion vs Requested Blocks

Block 1 Recon + Contract: complete
- `docs/slide02/00-contract.md` created.

Block 2 Skeleton: complete
- modular tree created under `slide02-ui`.

Block 3 Model + Reducer: complete
- deterministic model + reducer implemented.

Block 4 UI Wiring: complete
- controls connected to reducer and evidence panel.

Block 5 Defensive Defaults: complete
- robust context fallback implemented.

Block 6 Replay Capture: complete
- export/capture replay JSON implemented.

Block 7 Replay Playback: complete
- parse/stage/apply deterministic replay implemented.

Block 8 Dev HUD: complete
- HUD toggle, default OFF, state trace surfaced.

Block 9 Tests: complete (with environment caveat)
- unit suites pass.
- smoke spec authored; runtime execution blocked by port conflict and e2e cap.

Block 10 Finalize + Output: in progress externally
- report completed.
- additional output artifact handled separately (`CODEX_OUTPUT_Slide02.txt`).
```

### FILE: tests/e2e/slide02-bridge-smoke.e2e.spec.ts
```
import { expect, test } from "@playwright/test";

test("Slide02 bridge smoke: constraint tightening updates deterministic evidence and replay apply is stable", async ({ page }) => {
  const severe: string[] = [];

  page.on("console", (msg) => {
    if (msg.type() !== "error") return;
    const text = msg.text();
    if (/favicon|Failed to load resource/i.test(text)) return;
    severe.push(text);
  });

  await page.goto("/");

  // Navigate from Slide00 -> Slide01 -> Slide02 using deck next controls.
  await page.getByRole("button", { name: /NEXT/i }).click();
  await page.getByRole("button", { name: /NEXT/i }).click();

  await expect(page.getByTestId("slide02-root")).toBeVisible();
  await expect(page.getByTestId("slide02-controls-panel")).toBeVisible();
  await expect(page.getByTestId("slide02-evidence-panel")).toBeVisible();

  const initialSignature = (await page.getByTestId("slide02-response-signature").innerText()).trim();
  await expect(page.getByTestId("slide02-status-value")).toContainText("Bootstrapped");
  await expect(page.getByTestId("slide02-trace-length")).toHaveText("1");

  await page.getByTestId("slide02-route-select").selectOption("margin-defense");
  await page.getByTestId("slide02-strictness-slider").fill("78");
  await page.getByTestId("slide02-budget-slider").fill("75");

  await expect(page.getByTestId("slide02-status-value")).toContainText("Interactive");
  await expect(page.getByTestId("slide02-decision-chip")).toContainText(/PROCEED|PROCEED\+/i);
  await expect(page.getByTestId("slide02-evidence-row-route")).toContainText("Margin Defense");

  const updatedSignature = (await page.getByTestId("slide02-response-signature").innerText()).trim();
  expect(updatedSignature).not.toBe(initialSignature);

  await page.getByTestId("slide02-replay-export").click();

  const replayJson = (await page.getByTestId("slide02-replay-textarea").inputValue()).trim();
  expect(replayJson.length).toBeGreaterThan(20);
  expect(replayJson).toContain("slide02.replay.v1");

  await page.getByTestId("slide02-replay-stage").click();
  await expect(page.getByTestId("slide02-status-value")).toContainText("Replay Ready");

  await page.getByTestId("slide02-replay-apply").click();
  await expect(page.getByTestId("slide02-status-value")).toContainText("Replay Applied");

  const finalSignature = (await page.getByTestId("slide02-response-signature").innerText()).trim();
  expect(finalSignature.length).toBeGreaterThan(0);
  expect(finalSignature).toBe(updatedSignature);

  await page.getByTestId("slide02-hud-toggle").click();
  await expect(page.getByTestId("slide02-hud")).toBeVisible();
  await expect(page.getByTestId("slide02-hud-signature")).toContainText(finalSignature);

  expect(severe).toEqual([]);
});
```
