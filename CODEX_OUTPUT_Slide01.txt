INVERSION - CODEX AGENT #1 - Slide01 Output
Generated: 2026-02-10 15:45:36

================================================================================

SUMMARY

- Modified files: 42
- Scope respected for Slide01 modules/docs/tests.
- Deterministic FSM + scoring + replay harness implemented.
- Unit tests and 1 smoke e2e passed in this workspace.

================================================================================

FILES (CREATED/MODIFIED)

- components/slides/Slide01.tsx
- components/slides/slide01-ui/core/fsm/types.ts
- components/slides/slide01-ui/core/fsm/constants.ts
- components/slides/slide01-ui/core/fsm/math.ts
- components/slides/slide01-ui/core/fsm/gesture.ts
- components/slides/slide01-ui/core/fsm/scoring.ts
- components/slides/slide01-ui/core/fsm/reducer.ts
- components/slides/slide01-ui/core/fsm/actions.ts
- components/slides/slide01-ui/core/fsm/selectors.ts
- components/slides/slide01-ui/core/fsm/index.ts
- components/slides/slide01-ui/core/fsm/slide01-scoring.unit.ts
- components/slides/slide01-ui/core/fsm/slide01-reducer.unit.ts
- components/slides/slide01-ui/core/replay/trace.ts
- components/slides/slide01-ui/core/replay/capture.ts
- components/slides/slide01-ui/core/replay/runner.ts
- components/slides/slide01-ui/core/replay/samples.ts
- components/slides/slide01-ui/core/replay/index.ts
- components/slides/slide01-ui/core/replay/slide01-replay.unit.ts
- components/slides/slide01-ui/core/slide01-unit-runner.ts
- components/slides/slide01-ui/ui/atoms/PanelFrame.tsx
- components/slides/slide01-ui/ui/atoms/ActionButton.tsx
- components/slides/slide01-ui/ui/atoms/PhaseChip.tsx
- components/slides/slide01-ui/ui/atoms/MetricBar.tsx
- components/slides/slide01-ui/ui/atoms/RouteCriterionRow.tsx
- components/slides/slide01-ui/ui/atoms/ScorePill.tsx
- components/slides/slide01-ui/ui/atoms/index.ts
- components/slides/slide01-ui/ui/panels/RoutesPanel.tsx
- components/slides/slide01-ui/ui/panels/WeighPanel.tsx
- components/slides/slide01-ui/ui/panels/OutcomePanel.tsx
- components/slides/slide01-ui/ui/panels/ReplayPanel.tsx
- components/slides/slide01-ui/ui/panels/CriteriaSignalsPanel.tsx
- components/slides/slide01-ui/ui/panels/index.ts
- components/slides/slide01-ui/ui/hud/DevHud.tsx
- components/slides/slide01-ui/ui/hud/index.ts
- components/slides/slide01-ui/ui/scene/Slide01Scene.tsx
- components/slides/slide01-ui/ui/scene/slide01.scene.css
- components/slides/slide01-ui/ui/scene/index.ts
- components/slides/slide01-ui/index.ts
- docs/slide01/00-contract.md
- docs/slide01/REPORT.md
- tests/e2e/slide01-route-selector.e2e.spec.ts
- tests/e2e/slide01.playwright.config.ts

================================================================================

COMMANDS RUN + OUTPUT (ABRIDGED)

1) npm ci
   - added 282 packages
   - audited 283 packages
   - found 0 vulnerabilities

2) npm run typecheck
   > tsc -p tsconfig.verify.json --noEmit
   - PASS

3) npx tsx components/slides/slide01-ui/core/slide01-unit-runner.ts
   - [slide01-unit] PASS

4) Smoke e2e harness (isolated port 3230)
   npx concurrently -k --success first \
     "npx wait-on http://127.0.0.1:3230 --timeout 120000 && npx playwright test --config tests/e2e/slide01.playwright.config.ts" \
     "npx cross-env DEMO_TEST_MODE=true VITE_ENABLE_VOICE=false tsx watch server/index.ts" \
     "npx cross-env DEMO_TEST_MODE=true VITE_ENABLE_VOICE=false vite --port 3230 --host 127.0.0.1 --strictPort"
   - 1 passed (slide01-route-selector.e2e.spec.ts)

================================================================================

GIT STATUS

 M components/slides/Slide01.tsx
?? CODEX_OUTPUT_Slide01.txt
?? CODEX_PROMPT_CURRENT.txt
?? components/slides/slide01-ui/
?? docs/slide01/
?? tests/e2e/slide01-route-selector.e2e.spec.ts
?? tests/e2e/slide01.playwright.config.ts


================================================================================

DIFFS VS REPO STATE (tracked diff output)

diff --git a/components/slides/Slide01.tsx b/components/slides/Slide01.tsx
index 3c0be4a..f5e5e75 100644
--- a/components/slides/Slide01.tsx
+++ b/components/slides/Slide01.tsx
@@ -1,57 +1,18 @@
-import React, { useState } from "react";
-import { SlideContainer, Header, NavArea } from "../SlideRenderer";
-
-export const Slide01: React.FC<{ nextSlide: () => void; prevSlide: () => void }> = ({
-  nextSlide,
-  prevSlide,
-}) => {
-  const alerts = [
-    { id: 1, label: "CRITICAL_ERROR", desc: "Paros no planeados = Pérdida directa de utilidad.", color: "red" },
-    { id: 2, label: "WARNING_OPS", desc: "Bomberazos constantes. Equipo estresado sin rumbo.", color: "orange" },
-    { id: 3, label: "MISSING_DOCS", desc: "Cajas negras. Nadie sabe cómo funciona el equipo.", color: "red" },
-    { id: 4, label: "DEPENDENCY", desc: "Si el técnico se va, la planta se detiene.", color: "red" },
-  ];
-  const [hovered, setHovered] = useState<number | null>(null);
-
-  return (
-    <SlideContainer>
-      <Header title="EL PROBLEMA" breadcrumb="DIAGNÓSTICO" slideNum={2} />
-      <div className="w-full h-full flex gap-8 items-center animate-fade-up">
-        <div className="w-1/2 flex flex-col gap-3 justify-center h-full">
-          {alerts.map((a) => (
-            <div
-              key={a.id}
-              onMouseEnter={() => setHovered(a.id)}
-              onMouseLeave={() => setHovered(null)}
-              className={`
-                p-5 border-l-4 cursor-pointer transition-all duration-300 relative overflow-hidden group rounded-r-lg
-                ${a.color === "red" ? "border-red-600 bg-red-900/10" : "border-orange-500 bg-orange-900/10"}
-                ${hovered === a.id ? "translate-x-4 bg-white/10" : ""}
-              `}
-            >
-              <div className={`font-code text-xl font-bold tracking-widest ${a.color === "red" ? "text-red-500" : "text-orange-500"}`}>
-                [{a.label}]
-              </div>
-            </div>
-          ))}
-        </div>
-
-        <div className="w-1/2 h-full relative flex items-center">
-          <div className="w-full aspect-video border border-white/20 bg-black/60 p-6 flex items-center justify-center text-center rounded-xl">
-            {hovered ? (
-              <div className="animate-fade-up">
-                <div className="text-5xl mb-4">⚠️</div>
-                <h3 className="text-2xl text-white font-bold mb-2">{alerts.find((x) => x.id === hovered)?.label}</h3>
-                <p className="text-xl text-gray-300 leading-relaxed">{alerts.find((x) => x.id === hovered)?.desc}</p>
-              </div>
-            ) : (
-              <div className="text-gray-600 font-code text-lg animate-pulse">HOVER TO SCAN ERROR...</div>
-            )}
-          </div>
-        </div>
-      </div>
-
-      <NavArea prev={prevSlide} next={nextSlide} />
-    </SlideContainer>
-  );
-};
+import React from "react";
+import { Header, NavArea, SlideContainer } from "../SlideRenderer";
+import { Slide01Scene } from "./slide01-ui";
+
+type Slide01Props = {
+  nextSlide: () => void;
+  prevSlide: () => void;
+};
+
+export const Slide01: React.FC<Slide01Props> = ({ nextSlide, prevSlide }) => {
+  return (
+    <SlideContainer>
+      <Header title="ROUTE SELECTOR" breadcrumb="DIAGNOSTIC DECISION" slideNum={2} />
+      <Slide01Scene />
+      <NavArea prev={prevSlide} next={nextSlide} />
+    </SlideContainer>
+  );
+};


================================================================================

FULL CONTENTS OF ALL CREATED/MODIFIED FILES


----- BEGIN FILE: components/slides/Slide01.tsx -----

import React from "react";
import { Header, NavArea, SlideContainer } from "../SlideRenderer";
import { Slide01Scene } from "./slide01-ui";

type Slide01Props = {
  nextSlide: () => void;
  prevSlide: () => void;
};

export const Slide01: React.FC<Slide01Props> = ({ nextSlide, prevSlide }) => {
  return (
    <SlideContainer>
      <Header title="ROUTE SELECTOR" breadcrumb="DIAGNOSTIC DECISION" slideNum={2} />
      <Slide01Scene />
      <NavArea prev={prevSlide} next={nextSlide} />
    </SlideContainer>
  );
};


----- END FILE: components/slides/Slide01.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/types.ts -----

export type Slide01Phase = "idle" | "aiming" | "weighing" | "committed" | "resolved";

export type RouteId = "A" | "B";

export type CriterionId =
  | "deliverySpeed"
  | "operationalRisk"
  | "scalability"
  | "budgetPredictability"
  | "knowledgeRetention";

export type ReplayStatus = "idle" | "ready" | "replayed" | "error";

export type PointerKind = "pointerdown" | "pointermove" | "pointerup";

export type PointerSource = "live" | "replay";

export interface CriterionDefinition {
  id: CriterionId;
  label: string;
  description: string;
  weight: number;
}

export interface RouteDefinition {
  id: RouteId;
  label: string;
  name: string;
  summary: string;
  profiles: Record<CriterionId, number>;
}

export interface PointSample {
  x: number;
  y: number;
}

export interface GestureSample extends PointSample {
  seq: number;
  kind: PointerKind;
  pointerId: number;
  targetId: string;
  button: number;
  dx: number;
  dy: number;
  distance: number;
}

export interface GestureMetrics {
  sampleCount: number;
  totalDistance: number;
  horizontalTravel: number;
  verticalTravel: number;
  meanX: number;
  meanY: number;
  spreadX: number;
  spreadY: number;
  momentum: number;
  stability: number;
  commitment: number;
  urgency: number;
  biasRight: number;
  deliberation: number;
}

export interface CriterionSignal {
  criterionId: CriterionId;
  emphasis: number;
}

export interface CriterionContribution {
  criterionId: CriterionId;
  label: string;
  weight: number;
  emphasis: number;
  routeA: number;
  routeB: number;
  delta: number;
}

export interface ScoreSnapshot {
  routeA: number;
  routeB: number;
  difference: number;
  winner: RouteId;
  tie: boolean;
  signals: CriterionSignal[];
  contributions: CriterionContribution[];
}

export interface RouteDecision {
  winner: RouteId | null;
  headline: string;
  summary: string;
  reasons: string[];
}

export interface ReplayMeta {
  status: ReplayStatus;
  message: string;
  lastEnvelopeHash: string;
}

export interface Slide01PointerTraceEvent {
  kind: PointerKind;
  seq: number;
  x: number;
  y: number;
  pointerId: number;
  button: number;
  targetId: string;
}

export interface Slide01TraceEnvelope {
  version: "slide01.trace.v1";
  source: "Slide01";
  events: Slide01PointerTraceEvent[];
}

export interface Slide01State {
  phase: Slide01Phase;
  phaseHistory: Slide01Phase[];
  transitionCount: number;
  activePointerId: number | null;
  pointerDown: boolean;
  gestureStart: PointSample | null;
  pointerCurrent: PointSample | null;
  gestureSamples: GestureSample[];
  metrics: GestureMetrics;
  score: ScoreSnapshot;
  decision: RouteDecision;
  trace: Slide01PointerTraceEvent[];
  hudVisible: boolean;
  replay: ReplayMeta;
  routes: Record<RouteId, RouteDefinition>;
  criteria: CriterionDefinition[];
}

export type Slide01Action =
  | {
      type: "POINTER_EVENT";
      source: PointerSource;
      event: Slide01PointerTraceEvent;
    }
  | {
      type: "RESOLVE_COMMITTED";
      source: PointerSource;
      reason: "pointer-release" | "replay";
    }
  | {
      type: "RESET";
    }
  | {
      type: "TOGGLE_HUD";
    }
  | {
      type: "REPLAY_APPLY";
      replayedState: Slide01State;
      envelopeHash: string;
    }
  | {
      type: "REPLAY_ERROR";
      message: string;
    }
  | {
      type: "REPLAY_NOTE";
      message: string;
    };

export interface Slide01ReplayResult {
  ok: boolean;
  message: string;
  envelopeHash: string;
  state: Slide01State;
}


----- END FILE: components/slides/slide01-ui/core/fsm/types.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/constants.ts -----

import {
  CriterionDefinition,
  CriterionId,
  GestureMetrics,
  RouteDecision,
  RouteDefinition,
  RouteId,
  ScoreSnapshot,
} from "./types";

export const SLIDE01_TRACE_VERSION = "slide01.trace.v1" as const;
export const SLIDE01_TRACE_SOURCE = "Slide01" as const;
export const SLIDE01_TIE_BREAKER: RouteId = "B";
export const SLIDE01_MOVEMENT_THRESHOLD = 0.045;

export const SLIDE01_CRITERIA: CriterionDefinition[] = [
  {
    id: "deliverySpeed",
    label: "Delivery Speed",
    description: "How quickly the route can stabilize immediate operations.",
    weight: 0.22,
  },
  {
    id: "operationalRisk",
    label: "Operational Risk",
    description: "How strongly the route reduces recurring production risk.",
    weight: 0.24,
  },
  {
    id: "scalability",
    label: "Scalability",
    description: "How well the route supports growth and multi-line deployment.",
    weight: 0.22,
  },
  {
    id: "budgetPredictability",
    label: "Budget Predictability",
    description: "How stable and predictable execution cost remains over time.",
    weight: 0.16,
  },
  {
    id: "knowledgeRetention",
    label: "Knowledge Retention",
    description: "How effectively process knowledge remains inside the organization.",
    weight: 0.16,
  },
];

export const SLIDE01_ROUTES: Record<RouteId, RouteDefinition> = {
  A: {
    id: "A",
    label: "Route A",
    name: "Rapid Stabilization",
    summary: "Fast mitigation to reduce immediate pressure.",
    profiles: {
      deliverySpeed: 0.92,
      operationalRisk: 0.38,
      scalability: 0.34,
      budgetPredictability: 0.45,
      knowledgeRetention: 0.32,
    },
  },
  B: {
    id: "B",
    label: "Route B",
    name: "Standardized Scale Path",
    summary: "Structured rollout with durable controls and evidence.",
    profiles: {
      deliverySpeed: 0.58,
      operationalRisk: 0.9,
      scalability: 0.9,
      budgetPredictability: 0.84,
      knowledgeRetention: 0.9,
    },
  },
};

export const CRITERION_LABELS: Record<CriterionId, string> = {
  deliverySpeed: "Delivery Speed",
  operationalRisk: "Operational Risk",
  scalability: "Scalability",
  budgetPredictability: "Budget Predictability",
  knowledgeRetention: "Knowledge Retention",
};

export const SCORING_EXPLANATION_PRIORITY: CriterionId[] = [
  "operationalRisk",
  "scalability",
  "budgetPredictability",
  "knowledgeRetention",
  "deliverySpeed",
];

export const EMPTY_METRICS: GestureMetrics = {
  sampleCount: 0,
  totalDistance: 0,
  horizontalTravel: 0,
  verticalTravel: 0,
  meanX: 0.5,
  meanY: 0.5,
  spreadX: 0,
  spreadY: 0,
  momentum: 0,
  stability: 1,
  commitment: 0,
  urgency: 0,
  biasRight: 0.5,
  deliberation: 0.5,
};

export const EMPTY_SCORE: ScoreSnapshot = {
  routeA: 50,
  routeB: 50,
  difference: 0,
  winner: SLIDE01_TIE_BREAKER,
  tie: true,
  signals: [],
  contributions: [],
};

export const EMPTY_DECISION: RouteDecision = {
  winner: null,
  headline: "No route selected yet",
  summary: "Start a deliberate drag gesture to weigh criteria.",
  reasons: [
    "Click and drag in the weighing arena to begin.",
    "Release pointer to commit and resolve the deterministic decision.",
  ],
};

export const SLIDE01_TEST_IDS = {
  scene: "slide01-scene",
  title: "slide01-title",
  subtitle: "slide01-subtitle",
  phaseChip: "slide01-phase-chip",
  mainGrid: "slide01-main-grid",
  routesPanel: "slide01-routes-panel",
  routeCardA: "slide01-route-card-A",
  routeCardB: "slide01-route-card-B",
  routeTitleA: "slide01-route-title-A",
  routeTitleB: "slide01-route-title-B",
  routeTagA: "slide01-route-tag-A",
  routeTagB: "slide01-route-tag-B",
  routeScoreA: "slide01-route-score-A",
  routeScoreB: "slide01-route-score-B",
  routeSelectedA: "slide01-route-selected-A",
  routeSelectedB: "slide01-route-selected-B",
  weighPanel: "slide01-weigh-panel",
  weighInstruction: "slide01-weigh-instruction",
  weighArena: "slide01-weigh-arena",
  weighArenaGrid: "slide01-weigh-arena-grid",
  weighAxisX: "slide01-weigh-axis-x",
  weighAxisY: "slide01-weigh-axis-y",
  pointerDot: "slide01-pointer-dot",
  pointerStartDot: "slide01-pointer-start-dot",
  liveBias: "slide01-live-bias",
  liveDeliberation: "slide01-live-deliberation",
  liveUrgency: "slide01-live-urgency",
  liveSamples: "slide01-live-samples",
  outcomePanel: "slide01-outcome-panel",
  outcomeState: "slide01-outcome-state",
  outcomeHeadline: "slide01-outcome-headline",
  outcomeScore: "slide01-outcome-score",
  outcomeBullets: "slide01-outcome-bullets",
  outcomeWinner: "slide01-outcome-winner",
  outcomeReset: "slide01-outcome-reset",
  replayPanel: "slide01-replay-panel",
  traceLength: "slide01-trace-length",
  traceExport: "slide01-trace-export",
  traceCopy: "slide01-trace-copy",
  replayInput: "slide01-replay-input",
  replayLoadSample: "slide01-replay-load-sample",
  replayApply: "slide01-replay-apply",
  replayStatus: "slide01-replay-status",
  hudToggle: "slide01-hud-toggle",
  hudPanel: "slide01-hud-panel",
  hudPhase: "slide01-hud-phase",
  hudScoreA: "slide01-hud-score-A",
  hudScoreB: "slide01-hud-score-B",
  hudDelta: "slide01-hud-delta",
  hudTrace: "slide01-hud-trace",
  hudTransitionCount: "slide01-hud-transition-count",
} as const;

export const SLIDE01_OPTIONAL_CRITERION_SIGNAL_TEST_IDS: Record<CriterionId, string> = {
  deliverySpeed: "slide01-criterion-signal-deliverySpeed",
  operationalRisk: "slide01-criterion-signal-operationalRisk",
  scalability: "slide01-criterion-signal-scalability",
  budgetPredictability: "slide01-criterion-signal-budgetPredictability",
  knowledgeRetention: "slide01-criterion-signal-knowledgeRetention",
};


----- END FILE: components/slides/slide01-ui/core/fsm/constants.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/math.ts -----

export function clamp(value: number, min: number, max: number): number {
  if (value < min) return min;
  if (value > max) return max;
  return value;
}

export function clamp01(value: number): number {
  return clamp(value, 0, 1);
}

export function round(value: number, digits = 4): number {
  const power = 10 ** digits;
  return Math.round(value * power) / power;
}

export function distance(x1: number, y1: number, x2: number, y2: number): number {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

export function average(values: number[]): number {
  if (values.length === 0) return 0;
  let total = 0;
  for (const value of values) total += value;
  return total / values.length;
}

export function stableHash(value: string): string {
  let hash = 2166136261;
  for (let index = 0; index < value.length; index += 1) {
    hash ^= value.charCodeAt(index);
    hash = Math.imul(hash, 16777619);
  }
  return `fnv1a-${(hash >>> 0).toString(16).padStart(8, "0")}`;
}


----- END FILE: components/slides/slide01-ui/core/fsm/math.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/gesture.ts -----

import { EMPTY_METRICS } from "./constants";
import { clamp01, distance, round } from "./math";
import { GestureMetrics, GestureSample, Slide01PointerTraceEvent } from "./types";

export function buildGestureSample(
  event: Slide01PointerTraceEvent,
  previous: GestureSample | null
): GestureSample {
  const prevX = previous?.x ?? event.x;
  const prevY = previous?.y ?? event.y;
  const dx = event.x - prevX;
  const dy = event.y - prevY;
  const stepDistance = distance(prevX, prevY, event.x, event.y);
  return {
    seq: event.seq,
    kind: event.kind,
    x: event.x,
    y: event.y,
    pointerId: event.pointerId,
    targetId: event.targetId,
    button: event.button,
    dx,
    dy,
    distance: stepDistance,
  };
}

export function computeGestureMetrics(samples: GestureSample[]): GestureMetrics {
  if (samples.length === 0) return EMPTY_METRICS;

  let totalDistance = 0;
  let horizontalTravel = 0;
  let verticalTravel = 0;
  let sumX = 0;
  let sumY = 0;
  let minX = 1;
  let maxX = 0;
  let minY = 1;
  let maxY = 0;
  let jitter = 0;

  for (let index = 0; index < samples.length; index += 1) {
    const sample = samples[index];
    totalDistance += sample.distance;
    horizontalTravel += Math.abs(sample.dx);
    verticalTravel += Math.abs(sample.dy);
    sumX += sample.x;
    sumY += sample.y;
    minX = Math.min(minX, sample.x);
    maxX = Math.max(maxX, sample.x);
    minY = Math.min(minY, sample.y);
    maxY = Math.max(maxY, sample.y);

    if (index >= 2) {
      const prev = samples[index - 1];
      jitter += Math.abs(sample.dx - prev.dx) + Math.abs(sample.dy - prev.dy);
    }
  }

  const sampleCount = samples.length;
  const meanX = sumX / sampleCount;
  const meanY = sumY / sampleCount;
  const spreadX = maxX - minX;
  const spreadY = maxY - minY;
  const momentum = clamp01(totalDistance / 2.4);
  const jitterNorm = clamp01(jitter / Math.max(0.25, totalDistance * 4));
  const stability = clamp01(1 - jitterNorm);
  const commitment = clamp01(sampleCount / 45 + totalDistance * 0.15);
  const urgency = clamp01(
    0.42 + (0.5 - meanY) * 0.8 + (1 - commitment) * 0.3 + momentum * 0.2 - stability * 0.12
  );
  const biasRight = clamp01((meanX - 0.5) * 1.8 + 0.5);
  const deliberation = clamp01(stability * 0.55 + commitment * 0.45);

  return {
    sampleCount,
    totalDistance: round(totalDistance),
    horizontalTravel: round(horizontalTravel),
    verticalTravel: round(verticalTravel),
    meanX: round(meanX),
    meanY: round(meanY),
    spreadX: round(spreadX),
    spreadY: round(spreadY),
    momentum: round(momentum),
    stability: round(stability),
    commitment: round(commitment),
    urgency: round(urgency),
    biasRight: round(biasRight),
    deliberation: round(deliberation),
  };
}

export function movementFromStart(
  start: { x: number; y: number } | null,
  current: { x: number; y: number } | null
): number {
  if (!start || !current) return 0;
  return Math.abs(current.x - start.x) + Math.abs(current.y - start.y);
}


----- END FILE: components/slides/slide01-ui/core/fsm/gesture.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/scoring.ts -----

import {
  CRITERION_LABELS,
  SCORING_EXPLANATION_PRIORITY,
  SLIDE01_CRITERIA,
  SLIDE01_ROUTES,
  SLIDE01_TIE_BREAKER,
} from "./constants";
import { clamp01, round } from "./math";
import {
  CriterionContribution,
  CriterionId,
  CriterionSignal,
  GestureMetrics,
  RouteDecision,
  RouteId,
  ScoreSnapshot,
} from "./types";

function compatibility(emphasis: number, profile: number): number {
  return clamp01(1 - Math.abs(emphasis - profile));
}

export function criterionSignalsFromMetrics(metrics: GestureMetrics): CriterionSignal[] {
  const deliverySpeed = clamp01(
    0.25 + metrics.urgency * 0.5 + metrics.momentum * 0.2 - metrics.stability * 0.15
  );
  const operationalRisk = clamp01(
    0.2 + metrics.deliberation * 0.5 + metrics.biasRight * 0.2 + metrics.meanY * 0.1
  );
  const scalability = clamp01(
    0.15 + metrics.biasRight * 0.45 + metrics.spreadX * 0.2 + metrics.commitment * 0.2
  );
  const budgetPredictability = clamp01(
    0.2 +
      metrics.stability * 0.45 +
      metrics.commitment * 0.25 +
      metrics.meanY * 0.1 -
      metrics.urgency * 0.1
  );
  const knowledgeRetention = clamp01(
    0.15 +
      metrics.deliberation * 0.35 +
      metrics.meanY * 0.2 +
      metrics.biasRight * 0.2 +
      metrics.spreadY * 0.1
  );

  return [
    { criterionId: "deliverySpeed", emphasis: round(deliverySpeed) },
    { criterionId: "operationalRisk", emphasis: round(operationalRisk) },
    { criterionId: "scalability", emphasis: round(scalability) },
    { criterionId: "budgetPredictability", emphasis: round(budgetPredictability) },
    { criterionId: "knowledgeRetention", emphasis: round(knowledgeRetention) },
  ];
}

function createContribution(
  criterionId: CriterionId,
  emphasis: number,
  weight: number
): CriterionContribution {
  const profileA = SLIDE01_ROUTES.A.profiles[criterionId];
  const profileB = SLIDE01_ROUTES.B.profiles[criterionId];
  const routeA = weight * compatibility(emphasis, profileA);
  const routeB = weight * compatibility(emphasis, profileB);
  const delta = routeB - routeA;
  return {
    criterionId,
    label: CRITERION_LABELS[criterionId],
    weight: round(weight),
    emphasis: round(emphasis),
    routeA: round(routeA),
    routeB: round(routeB),
    delta: round(delta),
  };
}

export function pickWinnerFromScores(routeA: number, routeB: number): {
  winner: RouteId;
  tie: boolean;
} {
  const difference = routeB - routeA;
  if (Math.abs(difference) <= 0.0001) {
    return { winner: SLIDE01_TIE_BREAKER, tie: true };
  }
  return {
    winner: difference > 0 ? "B" : "A",
    tie: false,
  };
}

function createReasonBullets(
  winner: RouteId,
  tie: boolean,
  contributions: CriterionContribution[],
  metrics: GestureMetrics
): string[] {
  const prioritized = [...contributions].sort((left, right) => {
    const leftPriority = SCORING_EXPLANATION_PRIORITY.indexOf(left.criterionId);
    const rightPriority = SCORING_EXPLANATION_PRIORITY.indexOf(right.criterionId);
    const byMagnitude = Math.abs(right.delta) - Math.abs(left.delta);
    if (Math.abs(byMagnitude) > 0.0001) return byMagnitude;
    return leftPriority - rightPriority;
  });

  const topThree = prioritized.slice(0, 3).map((entry) => {
    if (entry.delta === 0) {
      return `${entry.label}: neutral impact`;
    }
    const favorRoute = entry.delta > 0 ? "Route B" : "Route A";
    const sign = entry.delta > 0 ? "+" : "-";
    return `${entry.label}: ${sign}${Math.abs(entry.delta * 100).toFixed(2)} pts for ${favorRoute}`;
  });

  const certaintyScore =
    metrics.deliberation * 0.5 + metrics.stability * 0.3 + metrics.commitment * 0.2;

  const metricsBullet = `Gesture certainty ${(certaintyScore * 100).toFixed(
    2
  )}% (bias-right ${(metrics.biasRight * 100).toFixed(1)}%, urgency ${(
    metrics.urgency * 100
  ).toFixed(1)}%).`;

  const tieBullet = tie
    ? "Tie detected; deterministic tie-breaker selected Route B."
    : `Winner confidence delta: ${Math.abs(
        contributions.reduce((total, item) => total + item.delta, 0) * 100
      ).toFixed(2)} pts for Route ${winner}.`;

  return [...topThree, metricsBullet, tieBullet];
}

export function scoreFromMetrics(metrics: GestureMetrics): ScoreSnapshot {
  const signals = criterionSignalsFromMetrics(metrics);
  const contributions = SLIDE01_CRITERIA.map((criterion) => {
    const signal = signals.find((entry) => entry.criterionId === criterion.id);
    const emphasis = signal ? signal.emphasis : 0.5;
    return createContribution(criterion.id, emphasis, criterion.weight);
  });

  const routeA = contributions.reduce((total, item) => total + item.routeA, 0) * 100;
  const routeB = contributions.reduce((total, item) => total + item.routeB, 0) * 100;
  const { winner, tie } = pickWinnerFromScores(routeA, routeB);
  return {
    routeA: round(routeA, 4),
    routeB: round(routeB, 4),
    difference: round(routeB - routeA, 4),
    winner,
    tie,
    signals,
    contributions,
  };
}

export function decisionFromScore(score: ScoreSnapshot): RouteDecision {
  const winnerRoute = score.winner;
  const winnerInfo = SLIDE01_ROUTES[winnerRoute];
  const reasons = createReasonBullets(
    winnerRoute,
    score.tie,
    score.contributions,
    summarizeMetrics(score)
  );
  return {
    winner: winnerRoute,
    headline: `${winnerInfo.label} selected`,
    summary: `${winnerInfo.name}: ${winnerInfo.summary}`,
    reasons,
  };
}

function summarizeMetrics(score: ScoreSnapshot): GestureMetrics {
  const byId = (id: CriterionId) => score.signals.find((entry) => entry.criterionId === id)?.emphasis ?? 0.5;
  const spreadX = Math.abs(byId("scalability") - byId("deliverySpeed"));
  const spreadY = Math.abs(byId("operationalRisk") - byId("budgetPredictability"));

  const momentum = clamp01(byId("deliverySpeed") * 0.8 + (1 - byId("knowledgeRetention")) * 0.2);
  const stability = clamp01(byId("budgetPredictability") * 0.7 + byId("operationalRisk") * 0.3);
  const commitment = clamp01(byId("knowledgeRetention") * 0.7 + byId("scalability") * 0.3);
  const urgency = clamp01(byId("deliverySpeed"));
  const biasRight = clamp01(byId("scalability") * 0.65 + byId("operationalRisk") * 0.35);
  const deliberation = clamp01(stability * 0.55 + commitment * 0.45);

  return {
    sampleCount: 0,
    totalDistance: 0,
    horizontalTravel: 0,
    verticalTravel: 0,
    meanX: biasRight,
    meanY: clamp01(byId("operationalRisk") * 0.5 + byId("budgetPredictability") * 0.5),
    spreadX,
    spreadY,
    momentum,
    stability,
    commitment,
    urgency,
    biasRight,
    deliberation,
  };
}


----- END FILE: components/slides/slide01-ui/core/fsm/scoring.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/reducer.ts -----

import {
  EMPTY_DECISION,
  EMPTY_METRICS,
  EMPTY_SCORE,
  SLIDE01_CRITERIA,
  SLIDE01_MOVEMENT_THRESHOLD,
  SLIDE01_ROUTES,
} from "./constants";
import { buildGestureSample, computeGestureMetrics, movementFromStart } from "./gesture";
import { decisionFromScore, scoreFromMetrics } from "./scoring";
import {
  PointSample,
  Slide01Action,
  Slide01Phase,
  Slide01State,
  Slide01PointerTraceEvent,
} from "./types";

function withPhase(state: Slide01State, phase: Slide01Phase): Slide01State {
  if (state.phase === phase) return state;
  return {
    ...state,
    phase,
    phaseHistory: [...state.phaseHistory, phase],
    transitionCount: state.transitionCount + 1,
  };
}

function pointFromEvent(event: Slide01PointerTraceEvent): PointSample {
  return {
    x: event.x,
    y: event.y,
  };
}

function appendTrace(state: Slide01State, event: Slide01PointerTraceEvent): Slide01State {
  return {
    ...state,
    trace: [...state.trace, event],
  };
}

function handlePointerDown(state: Slide01State, event: Slide01PointerTraceEvent): Slide01State {
  const firstSample = buildGestureSample(event, null);
  const samples = [firstSample];
  const metrics = computeGestureMetrics(samples);
  const score = scoreFromMetrics(metrics);

  const next: Slide01State = {
    ...state,
    activePointerId: event.pointerId,
    pointerDown: true,
    gestureStart: pointFromEvent(event),
    pointerCurrent: pointFromEvent(event),
    gestureSamples: samples,
    metrics,
    score,
    decision: EMPTY_DECISION,
    replay: {
      ...state.replay,
      status: "ready",
      message: "Live trace updated.",
    },
  };

  return withPhase(appendTrace(next, event), "aiming");
}

function handlePointerMove(state: Slide01State, event: Slide01PointerTraceEvent): Slide01State {
  if (!state.pointerDown) return state;
  if (state.activePointerId !== event.pointerId) return state;
  if (!(state.phase === "aiming" || state.phase === "weighing")) return state;

  const previous = state.gestureSamples[state.gestureSamples.length - 1] ?? null;
  const sample = buildGestureSample(event, previous);
  const gestureSamples = [...state.gestureSamples, sample];
  const metrics = computeGestureMetrics(gestureSamples);
  const score = scoreFromMetrics(metrics);
  const pointerCurrent = pointFromEvent(event);
  const moved = movementFromStart(state.gestureStart, pointerCurrent);

  const nextPhase: Slide01Phase =
    state.phase === "aiming" && moved >= SLIDE01_MOVEMENT_THRESHOLD ? "weighing" : state.phase;

  const nextState: Slide01State = {
    ...state,
    pointerCurrent,
    gestureSamples,
    metrics,
    score,
    replay: {
      ...state.replay,
      status: "ready",
      message: "Live trace updated.",
    },
  };

  return withPhase(appendTrace(nextState, event), nextPhase);
}

function handlePointerUp(state: Slide01State, event: Slide01PointerTraceEvent): Slide01State {
  if (!state.pointerDown) return state;
  if (state.activePointerId !== event.pointerId) return state;
  if (!(state.phase === "aiming" || state.phase === "weighing")) return state;

  const previous = state.gestureSamples[state.gestureSamples.length - 1] ?? null;
  const sample = buildGestureSample(event, previous);
  const gestureSamples = [...state.gestureSamples, sample];
  const metrics = computeGestureMetrics(gestureSamples);
  const score = scoreFromMetrics(metrics);
  const pointerCurrent = pointFromEvent(event);

  const nextState: Slide01State = {
    ...state,
    activePointerId: null,
    pointerDown: false,
    pointerCurrent,
    gestureSamples,
    metrics,
    score,
    replay: {
      ...state.replay,
      status: "ready",
      message: "Gesture committed. Resolve to finalize.",
    },
  };

  return withPhase(appendTrace(nextState, event), "committed");
}

export function createSlide01InitialState(): Slide01State {
  return {
    phase: "idle",
    phaseHistory: ["idle"],
    transitionCount: 0,
    activePointerId: null,
    pointerDown: false,
    gestureStart: null,
    pointerCurrent: null,
    gestureSamples: [],
    metrics: EMPTY_METRICS,
    score: EMPTY_SCORE,
    decision: EMPTY_DECISION,
    trace: [],
    hudVisible: false,
    replay: {
      status: "idle",
      message: "Replay idle.",
      lastEnvelopeHash: "",
    },
    routes: SLIDE01_ROUTES,
    criteria: SLIDE01_CRITERIA,
  };
}

export function slide01Reducer(state: Slide01State, action: Slide01Action): Slide01State {
  switch (action.type) {
    case "POINTER_EVENT": {
      const event = action.event;
      if (event.kind === "pointerdown") return handlePointerDown(state, event);
      if (event.kind === "pointermove") return handlePointerMove(state, event);
      if (event.kind === "pointerup") return handlePointerUp(state, event);
      return state;
    }
    case "RESOLVE_COMMITTED": {
      if (state.phase !== "committed") return state;
      const decision = decisionFromScore(state.score);
      const nextState: Slide01State = {
        ...state,
        decision,
        replay: {
          ...state.replay,
          status: action.source === "replay" ? "replayed" : "ready",
          message:
            action.source === "replay"
              ? "Replay completed through reducer path."
              : "Route resolved from live gesture.",
        },
      };
      return withPhase(nextState, "resolved");
    }
    case "RESET": {
      const reset = createSlide01InitialState();
      return {
        ...reset,
        hudVisible: state.hudVisible,
        replay: {
          ...reset.replay,
          status: "idle",
          message: "Session reset.",
        },
      };
    }
    case "TOGGLE_HUD": {
      return {
        ...state,
        hudVisible: !state.hudVisible,
      };
    }
    case "REPLAY_APPLY": {
      return {
        ...action.replayedState,
        hudVisible: state.hudVisible,
        replay: {
          ...action.replayedState.replay,
          status: "replayed",
          message: "Replay applied successfully.",
          lastEnvelopeHash: action.envelopeHash,
        },
      };
    }
    case "REPLAY_ERROR": {
      return {
        ...state,
        replay: {
          ...state.replay,
          status: "error",
          message: action.message,
        },
      };
    }
    case "REPLAY_NOTE": {
      return {
        ...state,
        replay: {
          ...state.replay,
          status: state.replay.status === "error" ? "ready" : state.replay.status,
          message: action.message,
        },
      };
    }
    default:
      return state;
  }
}

export function reduceActions(state: Slide01State, actions: Slide01Action[]): Slide01State {
  let current = state;
  for (const action of actions) {
    current = slide01Reducer(current, action);
  }
  return current;
}


----- END FILE: components/slides/slide01-ui/core/fsm/reducer.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/actions.ts -----

import { Slide01Action, Slide01PointerTraceEvent, PointerSource } from "./types";

export function pointerTraceEventToActions(
  event: Slide01PointerTraceEvent,
  source: PointerSource
): Slide01Action[] {
  if (event.kind === "pointerup") {
    return [
      {
        type: "POINTER_EVENT",
        source,
        event,
      },
      {
        type: "RESOLVE_COMMITTED",
        source,
        reason: source === "replay" ? "replay" : "pointer-release",
      },
    ];
  }

  return [
    {
      type: "POINTER_EVENT",
      source,
      event,
    },
  ];
}


----- END FILE: components/slides/slide01-ui/core/fsm/actions.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/selectors.ts -----

import { CriterionId, Slide01State } from "./types";

export function hasResolvedDecision(state: Slide01State): boolean {
  return state.phase === "resolved" && !!state.decision.winner;
}

export function decisionEvidenceLine(state: Slide01State): string {
  return `A: ${state.score.routeA.toFixed(2)} | B: ${state.score.routeB.toFixed(2)} | Delta: ${state.score.difference.toFixed(2)}`;
}

export function selectedRouteId(state: Slide01State): "A" | "B" | null {
  return state.decision.winner;
}

export function criterionContributionById(state: Slide01State, criterionId: CriterionId) {
  return state.score.contributions.find((item) => item.criterionId === criterionId) ?? null;
}

export function criterionSignalPercent(state: Slide01State, criterionId: CriterionId): number {
  const signal = state.score.signals.find((item) => item.criterionId === criterionId);
  return signal ? signal.emphasis * 100 : 50;
}

export function phaseLabel(state: Slide01State): string {
  if (state.phase === "idle") return "idle";
  if (state.phase === "aiming") return "aiming";
  if (state.phase === "weighing") return "weighing";
  if (state.phase === "committed") return "committed";
  return "resolved";
}


----- END FILE: components/slides/slide01-ui/core/fsm/selectors.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/index.ts -----

export * from "./actions";
export * from "./constants";
export * from "./gesture";
export * from "./math";
export * from "./reducer";
export * from "./scoring";
export * from "./selectors";
export * from "./types";


----- END FILE: components/slides/slide01-ui/core/fsm/index.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/slide01-scoring.unit.ts -----

import { strict as assert } from "node:assert";
import { SLIDE01_CRITERIA } from "./constants";
import {
  criterionSignalsFromMetrics,
  decisionFromScore,
  pickWinnerFromScores,
  scoreFromMetrics,
} from "./scoring";
import { GestureMetrics } from "./types";

function buildMetrics(overrides: Partial<GestureMetrics>): GestureMetrics {
  return {
    sampleCount: 18,
    totalDistance: 1.24,
    horizontalTravel: 0.82,
    verticalTravel: 0.42,
    meanX: 0.5,
    meanY: 0.5,
    spreadX: 0.4,
    spreadY: 0.3,
    momentum: 0.52,
    stability: 0.65,
    commitment: 0.58,
    urgency: 0.46,
    biasRight: 0.5,
    deliberation: 0.62,
    ...overrides,
  };
}

function assertBetween(value: number, min: number, max: number, label: string): void {
  assert.ok(
    value >= min && value <= max,
    `${label} expected between ${min} and ${max}, received ${value}`
  );
}

function test_weight_sum_is_one(): void {
  const total = SLIDE01_CRITERIA.reduce((sum, criterion) => sum + criterion.weight, 0);
  assert.equal(total, 1);
}

function test_signal_ranges_are_clamped(): void {
  const extremeCases: GestureMetrics[] = [
    buildMetrics({
      momentum: 2,
      stability: -1,
      commitment: 2,
      urgency: 2,
      meanY: -1,
      spreadX: 2,
      spreadY: 2,
      biasRight: 2,
      deliberation: 2,
    }),
    buildMetrics({
      momentum: -1,
      stability: 2,
      commitment: -1,
      urgency: -1,
      meanY: 2,
      spreadX: -1,
      spreadY: -1,
      biasRight: -1,
      deliberation: -1,
    }),
  ];

  for (const [index, metrics] of extremeCases.entries()) {
    const signals = criterionSignalsFromMetrics(metrics);
    assert.equal(signals.length, 5, `signal count mismatch for case ${index}`);
    for (const signal of signals) {
      assertBetween(signal.emphasis, 0, 1, `signal ${signal.criterionId}`);
    }
  }
}

function test_route_b_favored_by_deliberate_deep_right_bias(): void {
  const metrics = buildMetrics({
    sampleCount: 26,
    totalDistance: 1.46,
    horizontalTravel: 0.86,
    verticalTravel: 0.72,
    meanX: 0.72,
    meanY: 0.68,
    spreadX: 0.56,
    spreadY: 0.44,
    momentum: 0.51,
    stability: 0.86,
    commitment: 0.88,
    urgency: 0.22,
    biasRight: 0.82,
    deliberation: 0.87,
  });
  const score = scoreFromMetrics(metrics);
  assert.equal(score.winner, "B");
  assert.equal(score.tie, false);
  assert.ok(score.routeB > score.routeA);
  assert.ok(score.difference > 0);
  assertBetween(score.routeA, 0, 100, "routeA");
  assertBetween(score.routeB, 0, 100, "routeB");
}

function test_route_a_favored_by_urgent_shallow_left_bias(): void {
  const metrics = buildMetrics({
    sampleCount: 11,
    totalDistance: 1.12,
    horizontalTravel: 0.74,
    verticalTravel: 0.21,
    meanX: 0.24,
    meanY: 0.29,
    spreadX: 0.61,
    spreadY: 0.19,
    momentum: 0.83,
    stability: 0.38,
    commitment: 0.24,
    urgency: 0.91,
    biasRight: 0.18,
    deliberation: 0.31,
  });
  const score = scoreFromMetrics(metrics);
  assert.equal(score.winner, "A");
  assert.equal(score.tie, false);
  assert.ok(score.routeA > score.routeB);
  assert.ok(score.difference < 0);
}

function test_tie_breaker_prefers_route_b(): void {
  const result = pickWinnerFromScores(72.225, 72.225);
  assert.equal(result.tie, true);
  assert.equal(result.winner, "B");
}

function test_decision_shape_contains_expected_headline_and_reasons(): void {
  const metrics = buildMetrics({
    meanX: 0.71,
    meanY: 0.66,
    spreadX: 0.52,
    spreadY: 0.38,
    stability: 0.87,
    commitment: 0.84,
    biasRight: 0.8,
    urgency: 0.24,
    deliberation: 0.85,
  });
  const score = scoreFromMetrics(metrics);
  const decision = decisionFromScore(score);
  assert.ok(decision.headline.startsWith("Route "));
  assert.ok(decision.summary.length > 12);
  assert.ok(decision.reasons.length >= 4);
  assert.ok(decision.reasons.every((line) => line.length > 5));
}

function test_scoring_is_deterministic_for_identical_inputs(): void {
  const metrics = buildMetrics({
    sampleCount: 19,
    totalDistance: 1.11,
    horizontalTravel: 0.7,
    verticalTravel: 0.41,
    meanX: 0.64,
    meanY: 0.57,
    spreadX: 0.49,
    spreadY: 0.27,
    momentum: 0.6,
    stability: 0.73,
    commitment: 0.66,
    urgency: 0.38,
    biasRight: 0.68,
    deliberation: 0.71,
  });

  const first = scoreFromMetrics(metrics);
  const second = scoreFromMetrics(metrics);
  assert.deepEqual(second, first);
}

function test_score_ranges_for_scenario_matrix(): void {
  type Scenario = {
    name: string;
    expectedWinner: "A" | "B";
    metrics: Partial<GestureMetrics>;
  };

  const scenarios: Scenario[] = [
    {
      name: "deep-governed-right",
      expectedWinner: "B",
      metrics: {
        meanX: 0.74,
        meanY: 0.69,
        stability: 0.89,
        commitment: 0.9,
        urgency: 0.21,
        spreadX: 0.58,
        spreadY: 0.46,
        biasRight: 0.84,
        deliberation: 0.89,
      },
    },
    {
      name: "balanced-but-right",
      expectedWinner: "B",
      metrics: {
        meanX: 0.61,
        meanY: 0.58,
        stability: 0.78,
        commitment: 0.73,
        urgency: 0.33,
        spreadX: 0.47,
        spreadY: 0.31,
        biasRight: 0.67,
        deliberation: 0.76,
      },
    },
    {
      name: "urgent-left-sweep",
      expectedWinner: "A",
      metrics: {
        meanX: 0.22,
        meanY: 0.3,
        stability: 0.42,
        commitment: 0.28,
        urgency: 0.9,
        spreadX: 0.64,
        spreadY: 0.22,
        biasRight: 0.17,
        deliberation: 0.33,
      },
    },
    {
      name: "left-with-high-momentum",
      expectedWinner: "A",
      metrics: {
        meanX: 0.28,
        meanY: 0.33,
        momentum: 0.87,
        stability: 0.37,
        commitment: 0.29,
        urgency: 0.86,
        spreadX: 0.6,
        spreadY: 0.25,
        biasRight: 0.2,
        deliberation: 0.32,
      },
    },
    {
      name: "deliberate-neutral-right",
      expectedWinner: "B",
      metrics: {
        meanX: 0.57,
        meanY: 0.55,
        stability: 0.81,
        commitment: 0.77,
        urgency: 0.31,
        spreadX: 0.43,
        spreadY: 0.29,
        biasRight: 0.61,
        deliberation: 0.79,
      },
    },
    {
      name: "high-urgency-without-depth",
      expectedWinner: "A",
      metrics: {
        meanX: 0.35,
        meanY: 0.34,
        stability: 0.51,
        commitment: 0.32,
        urgency: 0.78,
        spreadX: 0.57,
        spreadY: 0.21,
        biasRight: 0.31,
        deliberation: 0.42,
      },
    },
    {
      name: "structured-right-wide-spread",
      expectedWinner: "B",
      metrics: {
        meanX: 0.69,
        meanY: 0.62,
        stability: 0.82,
        commitment: 0.84,
        urgency: 0.28,
        spreadX: 0.68,
        spreadY: 0.44,
        biasRight: 0.78,
        deliberation: 0.83,
      },
    },
    {
      name: "shallow-left-fast",
      expectedWinner: "A",
      metrics: {
        meanX: 0.19,
        meanY: 0.27,
        stability: 0.34,
        commitment: 0.25,
        urgency: 0.93,
        spreadX: 0.62,
        spreadY: 0.17,
        biasRight: 0.13,
        deliberation: 0.28,
      },
    },
    {
      name: "medium-right-medium-urgency",
      expectedWinner: "B",
      metrics: {
        meanX: 0.6,
        meanY: 0.57,
        stability: 0.74,
        commitment: 0.7,
        urgency: 0.4,
        spreadX: 0.5,
        spreadY: 0.33,
        biasRight: 0.64,
        deliberation: 0.72,
      },
    },
    {
      name: "left-biased-high-jitter",
      expectedWinner: "A",
      metrics: {
        meanX: 0.31,
        meanY: 0.36,
        stability: 0.29,
        commitment: 0.34,
        urgency: 0.82,
        spreadX: 0.59,
        spreadY: 0.24,
        biasRight: 0.27,
        deliberation: 0.32,
      },
    },
  ];

  for (const scenario of scenarios) {
    const metrics = buildMetrics(scenario.metrics);
    const score = scoreFromMetrics(metrics);
    assert.equal(score.winner, scenario.expectedWinner, scenario.name);
    assertBetween(score.routeA, 0, 100, `${scenario.name}: routeA`);
    assertBetween(score.routeB, 0, 100, `${scenario.name}: routeB`);
    assert.equal(score.contributions.length, 5, `${scenario.name}: contribution count`);
    assert.equal(score.signals.length, 5, `${scenario.name}: signal count`);
  }
}

function test_decision_bullets_are_stable_for_known_matrix(): void {
  const matrix: Partial<GestureMetrics>[] = [
    {
      meanX: 0.7,
      meanY: 0.67,
      spreadX: 0.55,
      spreadY: 0.44,
      stability: 0.88,
      commitment: 0.86,
      urgency: 0.25,
      biasRight: 0.81,
      deliberation: 0.87,
    },
    {
      meanX: 0.26,
      meanY: 0.29,
      spreadX: 0.63,
      spreadY: 0.2,
      stability: 0.36,
      commitment: 0.24,
      urgency: 0.92,
      biasRight: 0.16,
      deliberation: 0.3,
    },
    {
      meanX: 0.58,
      meanY: 0.55,
      spreadX: 0.45,
      spreadY: 0.3,
      stability: 0.72,
      commitment: 0.69,
      urgency: 0.42,
      biasRight: 0.63,
      deliberation: 0.7,
    },
  ];

  for (const [index, entry] of matrix.entries()) {
    const score = scoreFromMetrics(buildMetrics(entry));
    const decision = decisionFromScore(score);
    assert.ok(
      decision.reasons.some((reason) => reason.includes("Gesture certainty")),
      `matrix ${index} should include certainty bullet`
    );
    assert.ok(
      decision.reasons.some((reason) => reason.includes("Route")),
      `matrix ${index} should include route bullet`
    );
  }
}

export function runSlide01ScoringSpecs(): void {
  test_weight_sum_is_one();
  test_signal_ranges_are_clamped();
  test_route_b_favored_by_deliberate_deep_right_bias();
  test_route_a_favored_by_urgent_shallow_left_bias();
  test_tie_breaker_prefers_route_b();
  test_decision_shape_contains_expected_headline_and_reasons();
  test_scoring_is_deterministic_for_identical_inputs();
  test_score_ranges_for_scenario_matrix();
  test_decision_bullets_are_stable_for_known_matrix();
}


----- END FILE: components/slides/slide01-ui/core/fsm/slide01-scoring.unit.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/fsm/slide01-reducer.unit.ts -----

import { strict as assert } from "node:assert";
import { pointerTraceEventToActions } from "./actions";
import { createSlide01InitialState, reduceActions, slide01Reducer } from "./reducer";
import { Slide01Action, Slide01PointerTraceEvent, Slide01State } from "./types";

function event(
  kind: Slide01PointerTraceEvent["kind"],
  seq: number,
  x: number,
  y: number,
  pointerId = 1
): Slide01PointerTraceEvent {
  return {
    kind,
    seq,
    x,
    y,
    pointerId,
    button: 0,
    targetId: "slide01-weigh-arena",
  };
}

function applyActions(
  state: Slide01State,
  actions: Slide01Action[] | Slide01Action
): Slide01State {
  if (Array.isArray(actions)) {
    return reduceActions(state, actions);
  }
  return slide01Reducer(state, actions);
}

function applyEvent(
  state: Slide01State,
  traceEvent: Slide01PointerTraceEvent,
  source: "live" | "replay" = "live"
): Slide01State {
  const actions = pointerTraceEventToActions(traceEvent, source);
  return applyActions(state, actions);
}

function test_initial_state_shape(): void {
  const state = createSlide01InitialState();
  assert.equal(state.phase, "idle");
  assert.deepEqual(state.phaseHistory, ["idle"]);
  assert.equal(state.pointerDown, false);
  assert.equal(state.trace.length, 0);
  assert.equal(state.metrics.sampleCount, 0);
  assert.equal(state.score.winner, "B");
  assert.equal(state.decision.winner, null);
}

function test_idle_to_aiming_on_pointer_down(): void {
  const state = createSlide01InitialState();
  const next = applyEvent(state, event("pointerdown", 1, 0.2, 0.5));
  assert.equal(next.phase, "aiming");
  assert.equal(next.pointerDown, true);
  assert.equal(next.activePointerId, 1);
  assert.equal(next.trace.length, 1);
  assert.equal(next.gestureSamples.length, 1);
  assert.equal(next.metrics.sampleCount, 1);
}

function test_aiming_stays_aiming_below_threshold(): void {
  const start = applyEvent(createSlide01InitialState(), event("pointerdown", 1, 0.2, 0.5));
  const next = applyEvent(start, event("pointermove", 2, 0.22, 0.51));
  assert.equal(next.phase, "aiming");
  assert.equal(next.trace.length, 2);
}

function test_aiming_to_weighing_after_threshold_crossed(): void {
  const start = applyEvent(createSlide01InitialState(), event("pointerdown", 1, 0.2, 0.5));
  const next = applyEvent(start, event("pointermove", 2, 0.31, 0.62));
  assert.equal(next.phase, "weighing");
  assert.equal(next.trace.length, 2);
  assert.equal(next.gestureSamples.length, 2);
}

function test_weighing_updates_metrics_and_score(): void {
  let state = applyEvent(createSlide01InitialState(), event("pointerdown", 1, 0.2, 0.5));
  state = applyEvent(state, event("pointermove", 2, 0.4, 0.62));
  const next = applyEvent(state, event("pointermove", 3, 0.57, 0.7));
  assert.equal(next.phase, "weighing");
  assert.equal(next.metrics.sampleCount, 3);
  assert.ok(next.score.routeA >= 0);
  assert.ok(next.score.routeB >= 0);
}

function test_pointer_up_commits_then_auto_resolves_via_actions_mapper(): void {
  let state = applyEvent(createSlide01InitialState(), event("pointerdown", 1, 0.2, 0.44));
  state = applyEvent(state, event("pointermove", 2, 0.35, 0.58));
  state = applyEvent(state, event("pointermove", 3, 0.55, 0.67));
  const next = applyEvent(state, event("pointerup", 4, 0.79, 0.74));
  assert.equal(next.phase, "resolved");
  assert.equal(next.pointerDown, false);
  assert.equal(next.activePointerId, null);
  assert.ok(next.decision.headline.startsWith("Route"));
  assert.equal(next.trace.length, 4);
}

function test_resolve_action_is_noop_when_not_committed(): void {
  const state = createSlide01InitialState();
  const next = slide01Reducer(state, {
    type: "RESOLVE_COMMITTED",
    source: "live",
    reason: "pointer-release",
  });
  assert.deepEqual(next, state);
}

function test_pointer_move_without_session_is_ignored(): void {
  const state = createSlide01InitialState();
  const next = applyEvent(state, event("pointermove", 1, 0.4, 0.5));
  assert.equal(next.phase, "idle");
  assert.equal(next.trace.length, 0);
}

function test_pointer_up_without_session_is_ignored(): void {
  const state = createSlide01InitialState();
  const next = applyEvent(state, event("pointerup", 1, 0.4, 0.5));
  assert.equal(next.phase, "idle");
  assert.equal(next.trace.length, 0);
}

function test_mismatched_pointer_id_is_ignored(): void {
  let state = applyEvent(createSlide01InitialState(), event("pointerdown", 1, 0.2, 0.44, 7));
  state = applyEvent(state, event("pointermove", 2, 0.3, 0.5, 8));
  assert.equal(state.trace.length, 1);
  assert.equal(state.phase, "aiming");
}

function test_reset_returns_idle_and_clears_trace(): void {
  let state = applyEvent(createSlide01InitialState(), event("pointerdown", 1, 0.2, 0.44));
  state = applyEvent(state, event("pointermove", 2, 0.36, 0.56));
  state = applyEvent(state, event("pointerup", 3, 0.62, 0.76));
  assert.equal(state.phase, "resolved");
  const reset = slide01Reducer(state, { type: "RESET" });
  assert.equal(reset.phase, "idle");
  assert.equal(reset.trace.length, 0);
  assert.equal(reset.gestureSamples.length, 0);
  assert.equal(reset.decision.winner, null);
}

function test_toggle_hud_flips_flag(): void {
  const state = createSlide01InitialState();
  const on = slide01Reducer(state, { type: "TOGGLE_HUD" });
  const off = slide01Reducer(on, { type: "TOGGLE_HUD" });
  assert.equal(state.hudVisible, false);
  assert.equal(on.hudVisible, true);
  assert.equal(off.hudVisible, false);
}

function test_phase_history_records_transitions(): void {
  let state = createSlide01InitialState();
  state = applyEvent(state, event("pointerdown", 1, 0.2, 0.44));
  state = applyEvent(state, event("pointermove", 2, 0.4, 0.6));
  state = applyEvent(state, event("pointerup", 3, 0.78, 0.79));
  assert.deepEqual(state.phaseHistory, ["idle", "aiming", "weighing", "committed", "resolved"]);
  assert.equal(state.transitionCount, 4);
}

function test_resolved_state_can_start_new_run_without_manual_reset(): void {
  let state = createSlide01InitialState();
  state = applyEvent(state, event("pointerdown", 1, 0.2, 0.44));
  state = applyEvent(state, event("pointermove", 2, 0.4, 0.6));
  state = applyEvent(state, event("pointerup", 3, 0.78, 0.79));
  assert.equal(state.phase, "resolved");

  const next = applyEvent(state, event("pointerdown", 4, 0.7, 0.52));
  assert.equal(next.phase, "aiming");
  assert.equal(next.pointerDown, true);
  assert.equal(next.trace.length, 4);
}

function test_route_b_path_resolves_to_route_b(): void {
  let state = createSlide01InitialState();
  const trace: Slide01PointerTraceEvent[] = [
    event("pointerdown", 1, 0.22, 0.44),
    event("pointermove", 2, 0.34, 0.54),
    event("pointermove", 3, 0.51, 0.64),
    event("pointermove", 4, 0.66, 0.74),
    event("pointerup", 5, 0.82, 0.78),
  ];
  for (const item of trace) {
    state = applyEvent(state, item);
  }
  assert.equal(state.phase, "resolved");
  assert.equal(state.decision.winner, "B");
}

function test_route_a_path_resolves_to_route_a(): void {
  let state = createSlide01InitialState();
  const trace: Slide01PointerTraceEvent[] = [
    event("pointerdown", 1, 0.74, 0.62),
    event("pointermove", 2, 0.58, 0.53),
    event("pointermove", 3, 0.39, 0.41),
    event("pointermove", 4, 0.26, 0.3),
    event("pointerup", 5, 0.12, 0.2),
  ];
  for (const item of trace) {
    state = applyEvent(state, item);
  }
  assert.equal(state.phase, "resolved");
  assert.equal(state.decision.winner, "A");
}

function test_replay_apply_merges_hud_from_current_state(): void {
  let current = createSlide01InitialState();
  current = slide01Reducer(current, { type: "TOGGLE_HUD" });
  assert.equal(current.hudVisible, true);

  let replayed = createSlide01InitialState();
  replayed = applyEvent(replayed, event("pointerdown", 1, 0.22, 0.44), "replay");
  replayed = applyEvent(replayed, event("pointermove", 2, 0.36, 0.56), "replay");
  replayed = applyEvent(replayed, event("pointerup", 3, 0.8, 0.76), "replay");
  assert.equal(replayed.phase, "resolved");

  const merged = slide01Reducer(current, {
    type: "REPLAY_APPLY",
    replayedState: replayed,
    envelopeHash: "abc",
  });
  assert.equal(merged.hudVisible, true);
  assert.equal(merged.phase, "resolved");
  assert.equal(merged.replay.status, "replayed");
  assert.equal(merged.replay.lastEnvelopeHash, "abc");
}

function test_replay_error_sets_status_to_error(): void {
  const state = createSlide01InitialState();
  const next = slide01Reducer(state, {
    type: "REPLAY_ERROR",
    message: "Replay error: invalid JSON.",
  });
  assert.equal(next.replay.status, "error");
  assert.ok(next.replay.message.includes("invalid JSON"));
}

function test_phase_matrix_by_action_sequence(): void {
  type Case = {
    name: string;
    events: Slide01PointerTraceEvent[];
    expectedPhase: Slide01State["phase"];
    expectedWinner: Slide01State["decision"]["winner"];
  };

  const matrix: Case[] = [
    {
      name: "minimal click release",
      events: [
        event("pointerdown", 1, 0.5, 0.5),
        event("pointerup", 2, 0.5, 0.5),
      ],
      expectedPhase: "resolved",
      expectedWinner: "A",
    },
    {
      name: "single move then release",
      events: [
        event("pointerdown", 1, 0.2, 0.5),
        event("pointermove", 2, 0.3, 0.55),
        event("pointerup", 3, 0.6, 0.7),
      ],
      expectedPhase: "resolved",
      expectedWinner: "A",
    },
    {
      name: "left urgent sweep",
      events: [
        event("pointerdown", 1, 0.8, 0.64),
        event("pointermove", 2, 0.52, 0.47),
        event("pointermove", 3, 0.31, 0.33),
        event("pointerup", 4, 0.15, 0.2),
      ],
      expectedPhase: "resolved",
      expectedWinner: "B",
    },
    {
      name: "right deliberate spread",
      events: [
        event("pointerdown", 1, 0.28, 0.46),
        event("pointermove", 2, 0.4, 0.55),
        event("pointermove", 3, 0.57, 0.63),
        event("pointermove", 4, 0.73, 0.75),
        event("pointerup", 5, 0.86, 0.81),
      ],
      expectedPhase: "resolved",
      expectedWinner: "B",
    },
  ];

  for (const testCase of matrix) {
    let state = createSlide01InitialState();
    for (const pointerEvent of testCase.events) {
      state = applyEvent(state, pointerEvent);
    }
    assert.equal(state.phase, testCase.expectedPhase, testCase.name);
    assert.equal(state.decision.winner, testCase.expectedWinner, testCase.name);
  }
}

export function runSlide01ReducerSpecs(): void {
  test_initial_state_shape();
  test_idle_to_aiming_on_pointer_down();
  test_aiming_stays_aiming_below_threshold();
  test_aiming_to_weighing_after_threshold_crossed();
  test_weighing_updates_metrics_and_score();
  test_pointer_up_commits_then_auto_resolves_via_actions_mapper();
  test_resolve_action_is_noop_when_not_committed();
  test_pointer_move_without_session_is_ignored();
  test_pointer_up_without_session_is_ignored();
  test_mismatched_pointer_id_is_ignored();
  test_reset_returns_idle_and_clears_trace();
  test_toggle_hud_flips_flag();
  test_phase_history_records_transitions();
  test_resolved_state_can_start_new_run_without_manual_reset();
  test_route_b_path_resolves_to_route_b();
  test_route_a_path_resolves_to_route_a();
  test_replay_apply_merges_hud_from_current_state();
  test_replay_error_sets_status_to_error();
  test_phase_matrix_by_action_sequence();
}


----- END FILE: components/slides/slide01-ui/core/fsm/slide01-reducer.unit.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/replay/trace.ts -----

import {
  SLIDE01_TRACE_SOURCE,
  SLIDE01_TRACE_VERSION,
} from "../fsm/constants";
import { clamp01, stableHash } from "../fsm/math";
import {
  Slide01PointerTraceEvent,
  Slide01TraceEnvelope,
} from "../fsm/types";

function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null;
}

function isTraceKind(value: unknown): value is Slide01PointerTraceEvent["kind"] {
  return value === "pointerdown" || value === "pointermove" || value === "pointerup";
}

export function createTraceEnvelope(events: Slide01PointerTraceEvent[]): Slide01TraceEnvelope {
  return {
    version: SLIDE01_TRACE_VERSION,
    source: SLIDE01_TRACE_SOURCE,
    events,
  };
}

export function serializeTraceEnvelope(events: Slide01PointerTraceEvent[]): string {
  const envelope = createTraceEnvelope(events);
  return JSON.stringify(envelope, null, 2);
}

export function validateTraceEnvelope(payload: unknown): {
  ok: true;
  envelope: Slide01TraceEnvelope;
} | {
  ok: false;
  message: string;
} {
  if (!isObject(payload)) {
    return { ok: false, message: "Replay error: invalid trace envelope." };
  }
  if (payload.version !== SLIDE01_TRACE_VERSION) {
    return { ok: false, message: "Replay error: invalid trace version." };
  }
  if (payload.source !== SLIDE01_TRACE_SOURCE) {
    return { ok: false, message: "Replay error: invalid trace source." };
  }
  if (!Array.isArray(payload.events)) {
    return { ok: false, message: "Replay error: invalid trace events." };
  }

  const events: Slide01PointerTraceEvent[] = [];
  let previousSeq = 0;
  for (let index = 0; index < payload.events.length; index += 1) {
    const entry = payload.events[index];
    if (!isObject(entry)) {
      return { ok: false, message: "Replay error: invalid trace event object." };
    }
    if (!isTraceKind(entry.kind)) {
      return { ok: false, message: "Replay error: unsupported pointer kind." };
    }
    if (typeof entry.seq !== "number" || !Number.isFinite(entry.seq)) {
      return { ok: false, message: "Replay error: invalid sequence." };
    }
    if (entry.seq <= previousSeq) {
      return { ok: false, message: "Replay error: invalid sequence order." };
    }
    if (typeof entry.x !== "number" || typeof entry.y !== "number") {
      return { ok: false, message: "Replay error: invalid normalized coordinates." };
    }
    if (!Number.isFinite(entry.x) || !Number.isFinite(entry.y)) {
      return { ok: false, message: "Replay error: invalid normalized coordinates." };
    }
    if (typeof entry.pointerId !== "number" || !Number.isFinite(entry.pointerId)) {
      return { ok: false, message: "Replay error: invalid pointer id." };
    }
    if (typeof entry.button !== "number" || !Number.isFinite(entry.button)) {
      return { ok: false, message: "Replay error: invalid button id." };
    }
    if (typeof entry.targetId !== "string" || entry.targetId.length === 0) {
      return { ok: false, message: "Replay error: invalid target id." };
    }

    events.push({
      kind: entry.kind,
      seq: entry.seq,
      x: clamp01(entry.x),
      y: clamp01(entry.y),
      pointerId: entry.pointerId,
      button: entry.button,
      targetId: entry.targetId,
    });
    previousSeq = entry.seq;
  }

  return {
    ok: true,
    envelope: createTraceEnvelope(events),
  };
}

export function parseTraceEnvelope(text: string):
  | { ok: true; envelope: Slide01TraceEnvelope; envelopeHash: string }
  | { ok: false; message: string } {
  let payload: unknown;
  try {
    payload = JSON.parse(text);
  } catch (_error) {
    return { ok: false, message: "Replay error: invalid JSON." };
  }

  const validated = validateTraceEnvelope(payload);
  if ("message" in validated) {
    return {
      ok: false,
      message: validated.message,
    };
  }

  const normalizedText = JSON.stringify(validated.envelope);
  return {
    ok: true,
    envelope: validated.envelope,
    envelopeHash: stableHash(normalizedText),
  };
}


----- END FILE: components/slides/slide01-ui/core/replay/trace.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/replay/capture.ts -----

import { clamp01, round } from "../fsm/math";
import { Slide01PointerTraceEvent } from "../fsm/types";

export interface NormalizedPointerInput {
  kind: Slide01PointerTraceEvent["kind"];
  clientX: number;
  clientY: number;
  pointerId: number;
  button: number;
  seq: number;
  targetId: string;
  rect: {
    left: number;
    top: number;
    width: number;
    height: number;
  };
}

export function toNormalizedPoint(
  clientX: number,
  clientY: number,
  rect: { left: number; top: number; width: number; height: number }
): { x: number; y: number } {
  if (rect.width <= 0 || rect.height <= 0) {
    return { x: 0.5, y: 0.5 };
  }
  const x = clamp01((clientX - rect.left) / rect.width);
  const y = clamp01((clientY - rect.top) / rect.height);
  return {
    x: round(x, 6),
    y: round(y, 6),
  };
}

export function buildTraceEvent(input: NormalizedPointerInput): Slide01PointerTraceEvent {
  const point = toNormalizedPoint(input.clientX, input.clientY, input.rect);
  return {
    kind: input.kind,
    seq: input.seq,
    x: point.x,
    y: point.y,
    pointerId: input.pointerId,
    button: input.button,
    targetId: input.targetId,
  };
}


----- END FILE: components/slides/slide01-ui/core/replay/capture.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/replay/runner.ts -----

import { pointerTraceEventToActions } from "../fsm/actions";
import { createSlide01InitialState, reduceActions, slide01Reducer } from "../fsm/reducer";
import { Slide01ReplayResult, Slide01State, Slide01TraceEnvelope } from "../fsm/types";

export function replayTraceFromInitial(envelope: Slide01TraceEnvelope): Slide01State {
  let state = createSlide01InitialState();
  for (const event of envelope.events) {
    const mappedActions = pointerTraceEventToActions(event, "replay");
    state = reduceActions(state, mappedActions);
  }
  return state;
}

export function replayTraceFromState(
  _state: Slide01State,
  envelope: Slide01TraceEnvelope
): Slide01State {
  // Replay always starts from deterministic initial state.
  return replayTraceFromInitial(envelope);
}

export function applyReplayResult(
  currentState: Slide01State,
  replayedState: Slide01State,
  envelopeHash: string
): Slide01State {
  return slide01Reducer(currentState, {
    type: "REPLAY_APPLY",
    replayedState,
    envelopeHash,
  });
}

export function replayResult(
  currentState: Slide01State,
  envelope: Slide01TraceEnvelope,
  envelopeHash: string
): Slide01ReplayResult {
  const replayed = replayTraceFromState(currentState, envelope);
  return {
    ok: true,
    message: "Replay completed.",
    envelopeHash,
    state: replayed,
  };
}


----- END FILE: components/slides/slide01-ui/core/replay/runner.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/replay/samples.ts -----

import { createTraceEnvelope } from "./trace";

export const SAMPLE_TRACE_ROUTE_B = createTraceEnvelope([
  { kind: "pointerdown", seq: 1, x: 0.22, y: 0.44, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
  { kind: "pointermove", seq: 2, x: 0.32, y: 0.51, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
  { kind: "pointermove", seq: 3, x: 0.46, y: 0.61, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
  { kind: "pointermove", seq: 4, x: 0.62, y: 0.72, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
  { kind: "pointerup", seq: 5, x: 0.82, y: 0.78, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
]);

export const SAMPLE_TRACE_ROUTE_A = createTraceEnvelope([
  { kind: "pointerdown", seq: 1, x: 0.74, y: 0.62, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
  { kind: "pointermove", seq: 2, x: 0.58, y: 0.53, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
  { kind: "pointermove", seq: 3, x: 0.39, y: 0.41, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
  { kind: "pointermove", seq: 4, x: 0.26, y: 0.30, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
  { kind: "pointerup", seq: 5, x: 0.12, y: 0.20, pointerId: 1, button: 0, targetId: "slide01-weigh-arena" },
]);


----- END FILE: components/slides/slide01-ui/core/replay/samples.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/replay/index.ts -----

export * from "./capture";
export * from "./runner";
export * from "./samples";
export * from "./trace";


----- END FILE: components/slides/slide01-ui/core/replay/index.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/replay/slide01-replay.unit.ts -----

import { strict as assert } from "node:assert";
import { pointerTraceEventToActions } from "../fsm/actions";
import { reduceActions } from "../fsm/reducer";
import { Slide01PointerTraceEvent } from "../fsm/types";
import { replayResult, replayTraceFromInitial, replayTraceFromState } from "./runner";
import { SAMPLE_TRACE_ROUTE_A, SAMPLE_TRACE_ROUTE_B } from "./samples";
import {
  createTraceEnvelope,
  parseTraceEnvelope,
  serializeTraceEnvelope,
  validateTraceEnvelope,
} from "./trace";

function event(kind: Slide01PointerTraceEvent["kind"], seq: number, x: number, y: number) {
  return {
    kind,
    seq,
    x,
    y,
    pointerId: 1,
    button: 0,
    targetId: "slide01-weigh-arena",
  } satisfies Slide01PointerTraceEvent;
}

function test_serialize_and_parse_roundtrip(): void {
  const trace = [
    event("pointerdown", 1, 0.2, 0.44),
    event("pointermove", 2, 0.36, 0.56),
    event("pointerup", 3, 0.82, 0.78),
  ];
  const text = serializeTraceEnvelope(trace);
  assert.ok(text.includes("\"version\": \"slide01.trace.v1\""));
  const parsed = parseTraceEnvelope(text);
  assert.equal(parsed.ok, true);
  if (!parsed.ok) return;
  assert.equal(parsed.envelope.events.length, trace.length);
  assert.equal(parsed.envelope.events[0].kind, "pointerdown");
  assert.equal(parsed.envelope.events[2].kind, "pointerup");
}

function test_parse_invalid_json_reports_error(): void {
  const parsed = parseTraceEnvelope("{ invalid }");
  assert.equal(parsed.ok, false);
  if (parsed.ok) return;
  assert.ok(parsed.message.includes("invalid JSON"));
}

function test_validate_rejects_out_of_order_sequence(): void {
  const payload = {
    version: "slide01.trace.v1",
    source: "Slide01",
    events: [
      event("pointerdown", 1, 0.2, 0.4),
      event("pointermove", 1, 0.3, 0.5),
    ],
  };
  const result = validateTraceEnvelope(payload);
  assert.equal(result.ok, false);
  if (result.ok) return;
  assert.ok(result.message.includes("sequence"));
}

function test_validate_rejects_unknown_kind(): void {
  const payload = {
    version: "slide01.trace.v1",
    source: "Slide01",
    events: [
      {
        kind: "mousedown",
        seq: 1,
        x: 0.2,
        y: 0.4,
        pointerId: 1,
        button: 0,
        targetId: "slide01-weigh-arena",
      },
    ],
  };
  const result = validateTraceEnvelope(payload);
  assert.equal(result.ok, false);
  if (result.ok) return;
  assert.ok(result.message.includes("unsupported pointer kind"));
}

function test_validate_rejects_missing_target_id(): void {
  const payload = {
    version: "slide01.trace.v1",
    source: "Slide01",
    events: [
      {
        kind: "pointerdown",
        seq: 1,
        x: 0.2,
        y: 0.4,
        pointerId: 1,
        button: 0,
        targetId: "",
      },
    ],
  };
  const result = validateTraceEnvelope(payload);
  assert.equal(result.ok, false);
  if (result.ok) return;
  assert.ok(result.message.includes("target id"));
}

function test_replay_b_sample_resolves_to_route_b(): void {
  const state = replayTraceFromInitial(SAMPLE_TRACE_ROUTE_B);
  assert.equal(state.phase, "resolved");
  assert.equal(state.decision.winner, "B");
  assert.equal(state.trace.length, SAMPLE_TRACE_ROUTE_B.events.length);
}

function test_replay_a_sample_resolves_to_route_a(): void {
  const state = replayTraceFromInitial(SAMPLE_TRACE_ROUTE_A);
  assert.equal(state.phase, "resolved");
  assert.equal(state.decision.winner, "A");
  assert.equal(state.trace.length, SAMPLE_TRACE_ROUTE_A.events.length);
}

function test_replay_result_matches_direct_reducer_application(): void {
  const seedEnvelope = createTraceEnvelope([
    event("pointerdown", 1, 0.22, 0.44),
    event("pointermove", 2, 0.36, 0.56),
    event("pointermove", 3, 0.57, 0.66),
    event("pointerup", 4, 0.82, 0.78),
  ]);

  const replayState = replayTraceFromInitial(seedEnvelope);
  let manualState = replayTraceFromInitial(createTraceEnvelope([]));
  for (const pointerEvent of seedEnvelope.events) {
    const actions = pointerTraceEventToActions(pointerEvent, "replay");
    manualState = reduceActions(manualState, actions);
  }

  assert.deepEqual(replayState.phase, manualState.phase);
  assert.deepEqual(replayState.decision.winner, manualState.decision.winner);
  assert.deepEqual(replayState.score.routeA, manualState.score.routeA);
  assert.deepEqual(replayState.score.routeB, manualState.score.routeB);
}

function test_parse_returns_hash_for_same_payload(): void {
  const envelope = createTraceEnvelope([
    event("pointerdown", 1, 0.3, 0.4),
    event("pointermove", 2, 0.42, 0.55),
    event("pointerup", 3, 0.65, 0.7),
  ]);
  const text = JSON.stringify(envelope, null, 2);
  const first = parseTraceEnvelope(text);
  const second = parseTraceEnvelope(text);
  assert.equal(first.ok, true);
  assert.equal(second.ok, true);
  if (!first.ok || !second.ok) return;
  assert.equal(first.envelopeHash, second.envelopeHash);
}

function test_replay_from_state_ignores_existing_runtime_state(): void {
  const initialState = replayTraceFromInitial(SAMPLE_TRACE_ROUTE_A);
  assert.equal(initialState.decision.winner, "A");
  const replayed = replayTraceFromState(initialState, SAMPLE_TRACE_ROUTE_B);
  assert.equal(replayed.decision.winner, "B");
}

function test_replay_result_payload_shape(): void {
  const current = replayTraceFromInitial(createTraceEnvelope([]));
  const replay = replayResult(current, SAMPLE_TRACE_ROUTE_B, "hash-1");
  assert.equal(replay.ok, true);
  assert.equal(replay.envelopeHash, "hash-1");
  assert.equal(replay.state.phase, "resolved");
  assert.equal(replay.state.decision.winner, "B");
}

function test_validation_clamps_coordinates(): void {
  const payload = {
    version: "slide01.trace.v1",
    source: "Slide01",
    events: [
      {
        kind: "pointerdown",
        seq: 1,
        x: 2.2,
        y: -1.4,
        pointerId: 1,
        button: 0,
        targetId: "slide01-weigh-arena",
      },
    ],
  };
  const result = validateTraceEnvelope(payload);
  assert.equal(result.ok, true);
  if (!result.ok) return;
  assert.equal(result.envelope.events[0].x, 1);
  assert.equal(result.envelope.events[0].y, 0);
}

function test_parse_reports_invalid_source(): void {
  const payload = {
    version: "slide01.trace.v1",
    source: "OtherSlide",
    events: [],
  };
  const parsed = parseTraceEnvelope(JSON.stringify(payload));
  assert.equal(parsed.ok, false);
  if (parsed.ok) return;
  assert.ok(parsed.message.includes("source"));
}

function test_replay_long_trace_stability(): void {
  const events: Slide01PointerTraceEvent[] = [];
  events.push(event("pointerdown", 1, 0.2, 0.46));
  for (let step = 2; step <= 30; step += 1) {
    const x = Math.min(0.88, 0.2 + step * 0.02);
    const y = Math.min(0.84, 0.46 + step * 0.012);
    events.push(event("pointermove", step, x, y));
  }
  events.push(event("pointerup", 31, 0.89, 0.84));
  const envelope = createTraceEnvelope(events);
  const replayed = replayTraceFromInitial(envelope);
  assert.equal(replayed.phase, "resolved");
  assert.equal(replayed.trace.length, 31);
  assert.ok(replayed.score.routeA >= 0);
  assert.ok(replayed.score.routeB >= 0);
}

function test_replay_empty_trace_returns_idle_state(): void {
  const envelope = createTraceEnvelope([]);
  const replayed = replayTraceFromInitial(envelope);
  assert.equal(replayed.phase, "idle");
  assert.equal(replayed.trace.length, 0);
  assert.equal(replayed.decision.winner, null);
}

export function runSlide01ReplaySpecs(): void {
  test_serialize_and_parse_roundtrip();
  test_parse_invalid_json_reports_error();
  test_validate_rejects_out_of_order_sequence();
  test_validate_rejects_unknown_kind();
  test_validate_rejects_missing_target_id();
  test_replay_b_sample_resolves_to_route_b();
  test_replay_a_sample_resolves_to_route_a();
  test_replay_result_matches_direct_reducer_application();
  test_parse_returns_hash_for_same_payload();
  test_replay_from_state_ignores_existing_runtime_state();
  test_replay_result_payload_shape();
  test_validation_clamps_coordinates();
  test_parse_reports_invalid_source();
  test_replay_long_trace_stability();
  test_replay_empty_trace_returns_idle_state();
}


----- END FILE: components/slides/slide01-ui/core/replay/slide01-replay.unit.ts -----


----- BEGIN FILE: components/slides/slide01-ui/core/slide01-unit-runner.ts -----

import { runSlide01ReducerSpecs } from "./fsm/slide01-reducer.unit";
import { runSlide01ScoringSpecs } from "./fsm/slide01-scoring.unit";
import { runSlide01ReplaySpecs } from "./replay/slide01-replay.unit";

runSlide01ReducerSpecs();
runSlide01ScoringSpecs();
runSlide01ReplaySpecs();

console.log("[slide01-unit] PASS");


----- END FILE: components/slides/slide01-ui/core/slide01-unit-runner.ts -----


----- BEGIN FILE: components/slides/slide01-ui/ui/atoms/PanelFrame.tsx -----

import React from "react";

type PanelFrameProps = {
  title: string;
  subtitle?: string;
  testId: string;
  children: React.ReactNode;
  rightSlot?: React.ReactNode;
  className?: string;
};

export const PanelFrame: React.FC<PanelFrameProps> = ({
  title,
  subtitle,
  testId,
  children,
  rightSlot,
  className,
}) => {
  return (
    <section
      data-testid={testId}
      className={`rounded-2xl border border-white/15 bg-black/45 p-4 shadow-[0_0_40px_rgba(0,0,0,0.45)] ${className ?? ""}`}
    >
      <header className="mb-3 flex items-start justify-between gap-3">
        <div>
          <h3 className="font-code text-xs uppercase tracking-[0.28em] text-cyan/85">{title}</h3>
          {subtitle ? (
            <p className="mt-1 text-sm text-white/70 leading-relaxed">{subtitle}</p>
          ) : null}
        </div>
        {rightSlot ? <div className="shrink-0">{rightSlot}</div> : null}
      </header>
      <div>{children}</div>
    </section>
  );
};


----- END FILE: components/slides/slide01-ui/ui/atoms/PanelFrame.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/atoms/ActionButton.tsx -----

import React from "react";

type ActionButtonProps = {
  label: string;
  onClick: () => void;
  testId: string;
  tone?: "neutral" | "primary" | "warning";
  disabled?: boolean;
  className?: string;
};

const TONE_CLASS: Record<NonNullable<ActionButtonProps["tone"]>, string> = {
  neutral: "border-white/25 bg-black/35 text-white/85 hover:border-white/45",
  primary: "border-cyan/55 bg-cyan/20 text-cyan-100 hover:border-cyan/80",
  warning: "border-orange-300/60 bg-orange-500/15 text-orange-100 hover:border-orange-200",
};

export const ActionButton: React.FC<ActionButtonProps> = ({
  label,
  onClick,
  testId,
  tone = "neutral",
  disabled = false,
  className,
}) => {
  return (
    <button
      type="button"
      data-testid={testId}
      onClick={onClick}
      disabled={disabled}
      className={`rounded-lg border px-3 py-2 font-code text-[11px] uppercase tracking-[0.2em] transition-colors duration-150 ${TONE_CLASS[tone]} ${
        disabled ? "cursor-not-allowed opacity-45" : ""
      } ${className ?? ""}`}
    >
      {label}
    </button>
  );
};


----- END FILE: components/slides/slide01-ui/ui/atoms/ActionButton.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/atoms/PhaseChip.tsx -----

import React from "react";
import { Slide01Phase } from "../../core/fsm";

const PHASE_COLOR: Record<Slide01Phase, string> = {
  idle: "border-white/35 text-white/75",
  aiming: "border-cyan/55 text-cyan-200",
  weighing: "border-blue-300/65 text-blue-100",
  committed: "border-orange-300/70 text-orange-100",
  resolved: "border-emerald-300/70 text-emerald-100",
};

export const PhaseChip: React.FC<{ phase: Slide01Phase; testId: string }> = ({ phase, testId }) => {
  return (
    <div
      data-testid={testId}
      className={`inline-flex rounded-full border px-3 py-1 font-code text-[10px] uppercase tracking-[0.24em] ${PHASE_COLOR[phase]}`}
    >
      {phase}
    </div>
  );
};


----- END FILE: components/slides/slide01-ui/ui/atoms/PhaseChip.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/atoms/MetricBar.tsx -----

import React from "react";

type MetricBarProps = {
  label: string;
  value: number;
  testId: string;
  accent?: "cyan" | "amber" | "green" | "blue";
};

const ACCENT: Record<NonNullable<MetricBarProps["accent"]>, string> = {
  cyan: "from-cyan-400/70 to-cyan-200/60",
  amber: "from-amber-400/70 to-amber-200/60",
  green: "from-emerald-400/70 to-emerald-200/60",
  blue: "from-blue-400/70 to-blue-200/60",
};

export const MetricBar: React.FC<MetricBarProps> = ({
  label,
  value,
  testId,
  accent = "cyan",
}) => {
  const clamped = Math.max(0, Math.min(100, value));
  return (
    <div data-testid={testId} className="space-y-1">
      <div className="flex items-center justify-between text-[11px]">
        <span className="font-code uppercase tracking-[0.18em] text-white/65">{label}</span>
        <span className="font-code text-white/85">{clamped.toFixed(1)}%</span>
      </div>
      <div className="h-2 rounded-full bg-white/10">
        <div
          className={`h-2 rounded-full bg-gradient-to-r ${ACCENT[accent]} transition-all duration-150`}
          style={{ width: `${clamped}%` }}
        />
      </div>
    </div>
  );
};


----- END FILE: components/slides/slide01-ui/ui/atoms/MetricBar.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/atoms/RouteCriterionRow.tsx -----

import React from "react";

type RouteCriterionRowProps = {
  criterionLabel: string;
  profileValue: number;
  testId: string;
  tone: "A" | "B";
};

export const RouteCriterionRow: React.FC<RouteCriterionRowProps> = ({
  criterionLabel,
  profileValue,
  testId,
  tone,
}) => {
  const width = Math.max(0, Math.min(100, profileValue * 100));
  const gradient = tone === "A" ? "from-orange-400/70 to-orange-200/70" : "from-cyan-400/70 to-cyan-200/70";
  return (
    <div data-testid={testId} className="space-y-1">
      <div className="flex items-center justify-between text-[11px]">
        <span className="text-white/70">{criterionLabel}</span>
        <span className="font-code text-white/85">{width.toFixed(0)}%</span>
      </div>
      <div className="h-[5px] rounded-full bg-white/10">
        <div className={`h-[5px] rounded-full bg-gradient-to-r ${gradient}`} style={{ width: `${width}%` }} />
      </div>
    </div>
  );
};


----- END FILE: components/slides/slide01-ui/ui/atoms/RouteCriterionRow.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/atoms/ScorePill.tsx -----

import React from "react";

type ScorePillProps = {
  label: string;
  score: number;
  testId: string;
  tone: "A" | "B";
};

export const ScorePill: React.FC<ScorePillProps> = ({ label, score, testId, tone }) => {
  const className =
    tone === "A"
      ? "border-orange-300/60 bg-orange-300/15 text-orange-100"
      : "border-cyan-300/60 bg-cyan-300/15 text-cyan-100";

  return (
    <div
      data-testid={testId}
      className={`inline-flex items-center gap-2 rounded-full border px-3 py-1 font-code text-[10px] uppercase tracking-[0.22em] ${className}`}
    >
      <span>{label}</span>
      <span>{score.toFixed(2)}</span>
    </div>
  );
};


----- END FILE: components/slides/slide01-ui/ui/atoms/ScorePill.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/atoms/index.ts -----

export * from "./ActionButton";
export * from "./MetricBar";
export * from "./PanelFrame";
export * from "./PhaseChip";
export * from "./RouteCriterionRow";
export * from "./ScorePill";


----- END FILE: components/slides/slide01-ui/ui/atoms/index.ts -----


----- BEGIN FILE: components/slides/slide01-ui/ui/panels/RoutesPanel.tsx -----

import React from "react";
import {
  criterionContributionById,
  criterionSignalPercent,
  CriterionId,
  selectedRouteId,
  Slide01State,
  SLIDE01_TEST_IDS,
} from "../../core/fsm";
import { PanelFrame } from "../atoms/PanelFrame";
import { RouteCriterionRow } from "../atoms/RouteCriterionRow";
import { ScorePill } from "../atoms/ScorePill";

const CRITERION_IDS: CriterionId[] = [
  "deliverySpeed",
  "operationalRisk",
  "scalability",
  "budgetPredictability",
  "knowledgeRetention",
];

function routeHighlightClass(routeId: "A" | "B", selected: "A" | "B" | null): string {
  if (!selected) return "border-white/15";
  if (selected === routeId) {
    return routeId === "A"
      ? "border-orange-300/70 shadow-[0_0_26px_rgba(251,146,60,0.25)]"
      : "border-cyan-300/70 shadow-[0_0_26px_rgba(34,211,238,0.25)]";
  }
  return "border-white/15 opacity-70";
}

export const RoutesPanel: React.FC<{ state: Slide01State }> = ({ state }) => {
  const selected = selectedRouteId(state);
  const signal = (criterionId: CriterionId) => criterionSignalPercent(state, criterionId);
  const contribution = (criterionId: CriterionId) => criterionContributionById(state, criterionId);

  return (
    <PanelFrame
      testId={SLIDE01_TEST_IDS.routesPanel}
      title="Route Options"
      subtitle="Both routes are fixed. The gesture determines deterministic fit against these profiles."
      className="h-full"
      rightSlot={
        <div className="flex gap-2">
          <ScorePill label="A" score={state.score.routeA} tone="A" testId={SLIDE01_TEST_IDS.routeScoreA} />
          <ScorePill label="B" score={state.score.routeB} tone="B" testId={SLIDE01_TEST_IDS.routeScoreB} />
        </div>
      }
    >
      <div className="grid grid-cols-1 gap-3 md:grid-cols-2">
        <article
          data-testid={SLIDE01_TEST_IDS.routeCardA}
          className={`rounded-xl border bg-black/35 p-3 ${routeHighlightClass("A", selected)}`}
        >
          <div className="mb-2 flex items-center justify-between gap-3">
            <div>
              <h4 data-testid={SLIDE01_TEST_IDS.routeTitleA} className="font-display text-lg text-white">
                {state.routes.A.label} - {state.routes.A.name}
              </h4>
              <p data-testid={SLIDE01_TEST_IDS.routeTagA} className="text-xs text-white/70">
                {state.routes.A.summary}
              </p>
            </div>
            <div
              data-testid={SLIDE01_TEST_IDS.routeSelectedA}
              className="font-code text-[10px] uppercase tracking-[0.2em] text-orange-200"
            >
              {selected === "A" ? "selected" : "candidate"}
            </div>
          </div>
          <div className="space-y-2">
            {CRITERION_IDS.map((criterionId) => (
              <RouteCriterionRow
                key={criterionId}
                criterionLabel={`${contribution(criterionId)?.label ?? criterionId} (${signal(
                  criterionId
                ).toFixed(0)}%)`}
                profileValue={state.routes.A.profiles[criterionId]}
                tone="A"
                testId={`slide01-route-criterion-${criterionId}-A`}
              />
            ))}
          </div>
        </article>

        <article
          data-testid={SLIDE01_TEST_IDS.routeCardB}
          className={`rounded-xl border bg-black/35 p-3 ${routeHighlightClass("B", selected)}`}
        >
          <div className="mb-2 flex items-center justify-between gap-3">
            <div>
              <h4 data-testid={SLIDE01_TEST_IDS.routeTitleB} className="font-display text-lg text-white">
                {state.routes.B.label} - {state.routes.B.name}
              </h4>
              <p data-testid={SLIDE01_TEST_IDS.routeTagB} className="text-xs text-white/70">
                {state.routes.B.summary}
              </p>
            </div>
            <div
              data-testid={SLIDE01_TEST_IDS.routeSelectedB}
              className="font-code text-[10px] uppercase tracking-[0.2em] text-cyan-200"
            >
              {selected === "B" ? "selected" : "candidate"}
            </div>
          </div>
          <div className="space-y-2">
            {CRITERION_IDS.map((criterionId) => (
              <RouteCriterionRow
                key={criterionId}
                criterionLabel={`${contribution(criterionId)?.label ?? criterionId} (${signal(
                  criterionId
                ).toFixed(0)}%)`}
                profileValue={state.routes.B.profiles[criterionId]}
                tone="B"
                testId={`slide01-route-criterion-${criterionId}-B`}
              />
            ))}
          </div>
        </article>
      </div>
    </PanelFrame>
  );
};


----- END FILE: components/slides/slide01-ui/ui/panels/RoutesPanel.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/panels/WeighPanel.tsx -----

import React from "react";
import { Slide01State, SLIDE01_TEST_IDS } from "../../core/fsm";
import { MetricBar } from "../atoms/MetricBar";
import { PanelFrame } from "../atoms/PanelFrame";

type WeighPanelProps = {
  state: Slide01State;
  onPointerDown: (event: React.PointerEvent<HTMLDivElement>) => void;
  onPointerMove: (event: React.PointerEvent<HTMLDivElement>) => void;
  onPointerUp: (event: React.PointerEvent<HTMLDivElement>) => void;
};

export const WeighPanel: React.FC<WeighPanelProps> = ({
  state,
  onPointerDown,
  onPointerMove,
  onPointerUp,
}) => {
  const current = state.pointerCurrent;
  const start = state.gestureStart;
  const hasPointer = !!current;
  const pointerStyle = hasPointer
    ? {
        left: `${(current?.x ?? 0.5) * 100}%`,
        top: `${(current?.y ?? 0.5) * 100}%`,
      }
    : undefined;
  const startStyle = start
    ? {
        left: `${start.x * 100}%`,
        top: `${start.y * 100}%`,
      }
    : undefined;

  return (
    <PanelFrame
      testId={SLIDE01_TEST_IDS.weighPanel}
      title="Gesture Weighing"
      subtitle="Click and drag to weigh criteria. Release pointer to commit deterministic route selection."
      className="h-full"
    >
      <p
        data-testid={SLIDE01_TEST_IDS.weighInstruction}
        className="mb-3 text-sm leading-relaxed text-white/75"
      >
        Horizontal movement influences route direction. Stable and deeper gestures bias long-term governance criteria.
      </p>

      <div
        data-testid={SLIDE01_TEST_IDS.weighArena}
        className="relative h-56 select-none overflow-hidden rounded-xl border border-white/20 bg-black/45 md:h-64"
        onPointerDown={onPointerDown}
        onPointerMove={onPointerMove}
        onPointerUp={onPointerUp}
        onPointerCancel={onPointerUp}
      >
        <div
          data-testid={SLIDE01_TEST_IDS.weighArenaGrid}
          className="absolute inset-0 bg-[linear-gradient(rgba(255,255,255,0.08)_1px,transparent_1px),linear-gradient(90deg,rgba(255,255,255,0.08)_1px,transparent_1px)] bg-[size:32px_32px]"
        />
        <div
          data-testid={SLIDE01_TEST_IDS.weighAxisX}
          className="absolute left-2 right-2 top-1/2 h-[1px] bg-white/25"
        />
        <div
          data-testid={SLIDE01_TEST_IDS.weighAxisY}
          className="absolute bottom-2 top-2 left-1/2 w-[1px] bg-white/25"
        />
        {start ? (
          <div
            data-testid={SLIDE01_TEST_IDS.pointerStartDot}
            className="pointer-events-none absolute h-4 w-4 -translate-x-1/2 -translate-y-1/2 rounded-full border border-white/70 bg-transparent"
            style={startStyle}
          />
        ) : null}
        {hasPointer ? (
          <div
            data-testid={SLIDE01_TEST_IDS.pointerDot}
            className="pointer-events-none absolute h-4 w-4 -translate-x-1/2 -translate-y-1/2 rounded-full border border-cyan-300 bg-cyan-300/40 shadow-[0_0_22px_rgba(34,211,238,0.45)]"
            style={pointerStyle}
          />
        ) : null}
      </div>

      <div className="mt-4 grid grid-cols-1 gap-2 md:grid-cols-2">
        <MetricBar
          testId={SLIDE01_TEST_IDS.liveBias}
          label="Bias Right"
          value={state.metrics.biasRight * 100}
          accent="blue"
        />
        <MetricBar
          testId={SLIDE01_TEST_IDS.liveDeliberation}
          label="Deliberation"
          value={state.metrics.deliberation * 100}
          accent="green"
        />
        <MetricBar
          testId={SLIDE01_TEST_IDS.liveUrgency}
          label="Urgency"
          value={state.metrics.urgency * 100}
          accent="amber"
        />
        <MetricBar
          testId={SLIDE01_TEST_IDS.liveSamples}
          label="Sample Density"
          value={Math.min(100, state.metrics.sampleCount * 5)}
          accent="cyan"
        />
      </div>
    </PanelFrame>
  );
};


----- END FILE: components/slides/slide01-ui/ui/panels/WeighPanel.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/panels/OutcomePanel.tsx -----

import React from "react";
import { decisionEvidenceLine, hasResolvedDecision, Slide01State, SLIDE01_TEST_IDS } from "../../core/fsm";
import { ActionButton } from "../atoms/ActionButton";
import { PanelFrame } from "../atoms/PanelFrame";

type OutcomePanelProps = {
  state: Slide01State;
  onReset: () => void;
};

function phaseNarrative(phase: Slide01State["phase"]): string {
  if (phase === "idle") return "Waiting for deliberate pointer gesture.";
  if (phase === "aiming") return "Pointer down captured. Continue drag to weigh criteria.";
  if (phase === "weighing") return "Live weighting in progress.";
  if (phase === "committed") return "Gesture committed. Resolving final evidence.";
  return "Deterministic route resolved.";
}

export const OutcomePanel: React.FC<OutcomePanelProps> = ({ state, onReset }) => {
  const resolved = hasResolvedDecision(state);
  const headline = resolved ? state.decision.headline : "Pending deterministic selection";
  const scoreLine = decisionEvidenceLine(state);

  return (
    <PanelFrame
      testId={SLIDE01_TEST_IDS.outcomePanel}
      title="Decision Evidence"
      subtitle="Route selection is deterministic and trace-replayable."
      className="h-full"
      rightSlot={
        <ActionButton
          label="Reset"
          testId={SLIDE01_TEST_IDS.outcomeReset}
          onClick={onReset}
          tone="warning"
        />
      }
    >
      <div data-testid={SLIDE01_TEST_IDS.outcomeState} className="mb-2 font-code text-xs uppercase tracking-[0.2em] text-white/65">
        {phaseNarrative(state.phase)}
      </div>
      <h4 data-testid={SLIDE01_TEST_IDS.outcomeHeadline} className="text-2xl font-display text-white">
        {headline}
      </h4>
      <div data-testid={SLIDE01_TEST_IDS.outcomeWinner} className="mt-2 font-code text-sm uppercase tracking-[0.2em] text-cyan-200">
        {state.decision.winner ? `Winner: Route ${state.decision.winner}` : "Winner: --"}
      </div>
      <p data-testid={SLIDE01_TEST_IDS.outcomeScore} className="mt-2 rounded-lg border border-white/20 bg-black/35 px-3 py-2 font-code text-xs text-white/80">
        {scoreLine}
      </p>
      <ul data-testid={SLIDE01_TEST_IDS.outcomeBullets} className="mt-3 space-y-2 text-sm text-white/80">
        {state.decision.reasons.map((reason, index) => (
          <li key={`${reason}-${index}`} data-testid={`slide01-outcome-bullet-${index}`} className="rounded-lg border border-white/10 bg-black/30 px-3 py-2">
            {reason}
          </li>
        ))}
      </ul>
    </PanelFrame>
  );
};


----- END FILE: components/slides/slide01-ui/ui/panels/OutcomePanel.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/panels/ReplayPanel.tsx -----

import React from "react";
import { Slide01State, SLIDE01_TEST_IDS } from "../../core/fsm";
import { ActionButton } from "../atoms/ActionButton";
import { PanelFrame } from "../atoms/PanelFrame";

type ReplayPanelProps = {
  state: Slide01State;
  replayText: string;
  onReplayTextChange: (next: string) => void;
  onExport: () => void;
  onCopy: () => void;
  onLoadSample: () => void;
  onReplay: () => void;
};

export const ReplayPanel: React.FC<ReplayPanelProps> = ({
  state,
  replayText,
  onReplayTextChange,
  onExport,
  onCopy,
  onLoadSample,
  onReplay,
}) => {
  return (
    <PanelFrame
      testId={SLIDE01_TEST_IDS.replayPanel}
      title="Trace Replay Harness"
      subtitle="Export live pointer trace, paste JSON, and replay through the same reducer path."
      className="h-full"
    >
      <div className="mb-3 flex flex-wrap items-center gap-2">
        <div
          data-testid={SLIDE01_TEST_IDS.traceLength}
          className="rounded-lg border border-white/20 bg-black/35 px-3 py-2 font-code text-xs text-white/85"
        >
          trace events: {state.trace.length}
        </div>
        <ActionButton
          label="Export"
          testId={SLIDE01_TEST_IDS.traceExport}
          onClick={onExport}
          tone="primary"
        />
        <ActionButton
          label="Copy"
          testId={SLIDE01_TEST_IDS.traceCopy}
          onClick={onCopy}
          tone="neutral"
        />
        <ActionButton
          label="Load Sample"
          testId={SLIDE01_TEST_IDS.replayLoadSample}
          onClick={onLoadSample}
          tone="neutral"
        />
        <ActionButton
          label="Replay JSON"
          testId={SLIDE01_TEST_IDS.replayApply}
          onClick={onReplay}
          tone="primary"
          disabled={replayText.trim().length === 0}
        />
      </div>
      <label className="mb-1 block font-code text-[11px] uppercase tracking-[0.2em] text-white/65" htmlFor="slide01-replay-input">
        Replay JSON
      </label>
      <textarea
        id="slide01-replay-input"
        data-testid={SLIDE01_TEST_IDS.replayInput}
        className="h-40 w-full resize-y rounded-xl border border-white/20 bg-black/35 p-3 font-code text-xs leading-relaxed text-white/80 outline-none focus:border-cyan-300"
        placeholder='{\"version\":\"slide01.trace.v1\",\"source\":\"Slide01\",\"events\":[]}'
        value={replayText}
        onChange={(event) => onReplayTextChange(event.target.value)}
      />
      <p data-testid={SLIDE01_TEST_IDS.replayStatus} className="mt-2 font-code text-xs text-white/70">
        replay status: {state.replay.status} | {state.replay.message}
      </p>
    </PanelFrame>
  );
};


----- END FILE: components/slides/slide01-ui/ui/panels/ReplayPanel.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/panels/CriteriaSignalsPanel.tsx -----

import React from "react";
import { CriterionId, Slide01State, SLIDE01_OPTIONAL_CRITERION_SIGNAL_TEST_IDS } from "../../core/fsm";
import { MetricBar } from "../atoms/MetricBar";
import { PanelFrame } from "../atoms/PanelFrame";

const ORDER: CriterionId[] = [
  "deliverySpeed",
  "operationalRisk",
  "scalability",
  "budgetPredictability",
  "knowledgeRetention",
];

const LABELS: Record<CriterionId, string> = {
  deliverySpeed: "Delivery Speed Emphasis",
  operationalRisk: "Operational Risk Emphasis",
  scalability: "Scalability Emphasis",
  budgetPredictability: "Budget Predictability Emphasis",
  knowledgeRetention: "Knowledge Retention Emphasis",
};

export const CriteriaSignalsPanel: React.FC<{ state: Slide01State }> = ({ state }) => {
  const valueById = (criterionId: CriterionId): number => {
    const signal = state.score.signals.find((entry) => entry.criterionId === criterionId);
    return (signal?.emphasis ?? 0.5) * 100;
  };

  return (
    <PanelFrame
      testId="slide01-criteria-signals-panel"
      title="Criterion Signals"
      subtitle="Live deterministic signal intensities derived from gesture metrics."
      className="h-full"
    >
      <div className="space-y-3">
        {ORDER.map((criterionId, index) => (
          <MetricBar
            key={criterionId}
            testId={SLIDE01_OPTIONAL_CRITERION_SIGNAL_TEST_IDS[criterionId]}
            label={LABELS[criterionId]}
            value={valueById(criterionId)}
            accent={index % 2 === 0 ? "cyan" : "blue"}
          />
        ))}
      </div>
    </PanelFrame>
  );
};


----- END FILE: components/slides/slide01-ui/ui/panels/CriteriaSignalsPanel.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/panels/index.ts -----

export * from "./CriteriaSignalsPanel";
export * from "./OutcomePanel";
export * from "./ReplayPanel";
export * from "./RoutesPanel";
export * from "./WeighPanel";


----- END FILE: components/slides/slide01-ui/ui/panels/index.ts -----


----- BEGIN FILE: components/slides/slide01-ui/ui/hud/DevHud.tsx -----

import React from "react";
import { Slide01State, SLIDE01_TEST_IDS } from "../../core/fsm";

type DevHudProps = {
  state: Slide01State;
};

export const DevHud: React.FC<DevHudProps> = ({ state }) => {
  if (!state.hudVisible) return null;

  return (
    <aside
      data-testid={SLIDE01_TEST_IDS.hudPanel}
      className="rounded-xl border border-white/20 bg-black/65 p-3 font-code text-[11px] text-white/80"
    >
      <div data-testid={SLIDE01_TEST_IDS.hudPhase}>phase: {state.phase}</div>
      <div data-testid={SLIDE01_TEST_IDS.hudScoreA}>scoreA: {state.score.routeA.toFixed(4)}</div>
      <div data-testid={SLIDE01_TEST_IDS.hudScoreB}>scoreB: {state.score.routeB.toFixed(4)}</div>
      <div data-testid={SLIDE01_TEST_IDS.hudDelta}>delta(B-A): {state.score.difference.toFixed(4)}</div>
      <div data-testid={SLIDE01_TEST_IDS.hudTrace}>trace: {state.trace.length}</div>
      <div data-testid={SLIDE01_TEST_IDS.hudTransitionCount}>
        transitions: {state.transitionCount}
      </div>
    </aside>
  );
};


----- END FILE: components/slides/slide01-ui/ui/hud/DevHud.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/hud/index.ts -----

export * from "./DevHud";


----- END FILE: components/slides/slide01-ui/ui/hud/index.ts -----


----- BEGIN FILE: components/slides/slide01-ui/ui/scene/Slide01Scene.tsx -----

import React, { useCallback, useMemo, useReducer, useRef, useState } from "react";
import {
  createSlide01InitialState,
  pointerTraceEventToActions,
  slide01Reducer,
  SLIDE01_TEST_IDS,
} from "../../core/fsm";
import { buildTraceEvent } from "../../core/replay/capture";
import { parseTraceEnvelope, serializeTraceEnvelope } from "../../core/replay/trace";
import { replayResult } from "../../core/replay/runner";
import { SAMPLE_TRACE_ROUTE_B } from "../../core/replay/samples";
import { ActionButton } from "../atoms/ActionButton";
import { PhaseChip } from "../atoms/PhaseChip";
import { DevHud } from "../hud/DevHud";
import { CriteriaSignalsPanel } from "../panels/CriteriaSignalsPanel";
import { OutcomePanel } from "../panels/OutcomePanel";
import { ReplayPanel } from "../panels/ReplayPanel";
import { RoutesPanel } from "../panels/RoutesPanel";
import { WeighPanel } from "../panels/WeighPanel";
import "./slide01.scene.css";

function getActionableTargetId(element: EventTarget & HTMLDivElement): string {
  const testId = element.dataset.testid;
  if (typeof testId === "string" && testId.length > 0) return testId;
  return SLIDE01_TEST_IDS.weighArena;
}

export const Slide01Scene: React.FC = () => {
  const [state, dispatch] = useReducer(slide01Reducer, undefined, createSlide01InitialState);
  const [replayText, setReplayText] = useState("");
  const sequenceRef = useRef(0);

  const applyMappedActions = useCallback(
    (actions: ReturnType<typeof pointerTraceEventToActions>) => {
      for (const action of actions) {
        dispatch(action);
      }
    },
    [dispatch]
  );

  const emitPointerTraceEvent = useCallback(
    (
      event: React.PointerEvent<HTMLDivElement>,
      kind: "pointerdown" | "pointermove" | "pointerup"
    ) => {
      const rect = event.currentTarget.getBoundingClientRect();
      sequenceRef.current += 1;
      const traceEvent = buildTraceEvent({
        kind,
        seq: sequenceRef.current,
        clientX: event.clientX,
        clientY: event.clientY,
        pointerId: event.pointerId,
        button: event.button,
        targetId: getActionableTargetId(event.currentTarget),
        rect: {
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
        },
      });

      const mappedActions = pointerTraceEventToActions(traceEvent, "live");
      applyMappedActions(mappedActions);
    },
    [applyMappedActions]
  );

  const onPointerDown = useCallback(
    (event: React.PointerEvent<HTMLDivElement>) => {
      event.preventDefault();
      try {
        event.currentTarget.setPointerCapture(event.pointerId);
      } catch (_error) {
        // Ignore capture errors and continue deterministic reducer path.
      }
      emitPointerTraceEvent(event, "pointerdown");
    },
    [emitPointerTraceEvent]
  );

  const onPointerMove = useCallback(
    (event: React.PointerEvent<HTMLDivElement>) => {
      if (!state.pointerDown) return;
      if (state.activePointerId !== null && state.activePointerId !== event.pointerId) return;
      emitPointerTraceEvent(event, "pointermove");
    },
    [emitPointerTraceEvent, state.activePointerId, state.pointerDown]
  );

  const onPointerUp = useCallback(
    (event: React.PointerEvent<HTMLDivElement>) => {
      if (!state.pointerDown) return;
      if (state.activePointerId !== null && state.activePointerId !== event.pointerId) return;
      emitPointerTraceEvent(event, "pointerup");
      try {
        event.currentTarget.releasePointerCapture(event.pointerId);
      } catch (_error) {
        // Ignore capture release errors and continue deterministic reducer path.
      }
    },
    [emitPointerTraceEvent, state.activePointerId, state.pointerDown]
  );

  const onReset = useCallback(() => {
    sequenceRef.current = 0;
    dispatch({ type: "RESET" });
  }, [dispatch]);

  const onExport = useCallback(() => {
    const text = serializeTraceEnvelope(state.trace);
    setReplayText(text);
  }, [state.trace]);

  const onCopy = useCallback(() => {
    const text = serializeTraceEnvelope(state.trace);
    setReplayText(text);
    if (typeof navigator === "undefined" || !navigator.clipboard) {
      dispatch({ type: "REPLAY_ERROR", message: "Replay copy unavailable in this environment." });
      return;
    }
    void navigator.clipboard
      .writeText(text)
      .then(() => {
        dispatch({ type: "REPLAY_NOTE", message: "Trace copied to clipboard. Paste and replay anytime." });
      })
      .catch(() => {
        dispatch({ type: "REPLAY_ERROR", message: "Replay copy failed. Manual paste still available." });
      });
  }, [state.trace]);

  const onLoadSample = useCallback(() => {
    setReplayText(JSON.stringify(SAMPLE_TRACE_ROUTE_B, null, 2));
  }, []);

  const onReplay = useCallback(() => {
    const parsed = parseTraceEnvelope(replayText);
    if (parsed.ok === false) {
      dispatch({ type: "REPLAY_ERROR", message: parsed.message });
      return;
    }
    const replayed = replayResult(state, parsed.envelope, parsed.envelopeHash);
    sequenceRef.current =
      parsed.envelope.events[parsed.envelope.events.length - 1]?.seq ?? sequenceRef.current;
    dispatch({ type: "REPLAY_APPLY", replayedState: replayed.state, envelopeHash: parsed.envelopeHash });
  }, [replayText, state]);

  const subtitle = useMemo(() => {
    return "Deterministic route selector. Drag to weigh criteria and release to resolve evidence.";
  }, []);

  return (
    <div data-testid={SLIDE01_TEST_IDS.scene} className="slide01-scene-root">
      <div className="slide01-scene-content">
        <div className="flex items-center justify-between gap-4">
          <div>
            <h3 data-testid={SLIDE01_TEST_IDS.title} className="font-display text-3xl text-white">
              ROUTE SELECTOR
            </h3>
            <p data-testid={SLIDE01_TEST_IDS.subtitle} className="text-sm text-white/75">
              {subtitle}
            </p>
          </div>
          <div className="flex items-center gap-2">
            <PhaseChip phase={state.phase} testId={SLIDE01_TEST_IDS.phaseChip} />
            <ActionButton
              label={state.hudVisible ? "Hide HUD" : "Show HUD"}
              testId={SLIDE01_TEST_IDS.hudToggle}
              onClick={() => dispatch({ type: "TOGGLE_HUD" })}
              tone="neutral"
            />
          </div>
        </div>

        <div data-testid={SLIDE01_TEST_IDS.mainGrid} className="slide01-scene-grid-top">
          <RoutesPanel state={state} />
          <WeighPanel
            state={state}
            onPointerDown={onPointerDown}
            onPointerMove={onPointerMove}
            onPointerUp={onPointerUp}
          />
        </div>

        <div className="slide01-scene-grid-bottom">
          <OutcomePanel state={state} onReset={onReset} />
          <ReplayPanel
            state={state}
            replayText={replayText}
            onReplayTextChange={setReplayText}
            onExport={onExport}
            onCopy={onCopy}
            onLoadSample={onLoadSample}
            onReplay={onReplay}
          />
          <div className="space-y-2">
            <CriteriaSignalsPanel state={state} />
            <DevHud state={state} />
          </div>
        </div>
      </div>
    </div>
  );
};


----- END FILE: components/slides/slide01-ui/ui/scene/Slide01Scene.tsx -----


----- BEGIN FILE: components/slides/slide01-ui/ui/scene/slide01.scene.css -----

.slide01-scene-root {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 0 24px 92px;
  overflow: hidden;
}

.slide01-scene-root::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(circle at 20% 20%, rgba(34, 211, 238, 0.18), transparent 48%),
    radial-gradient(circle at 80% 70%, rgba(251, 146, 60, 0.14), transparent 42%),
    linear-gradient(120deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
  z-index: 0;
}

.slide01-scene-content {
  position: relative;
  z-index: 1;
  display: flex;
  flex: 1 1 auto;
  flex-direction: column;
  gap: 10px;
}

.slide01-scene-grid-top {
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 10px;
  min-height: 0;
}

.slide01-scene-grid-bottom {
  display: grid;
  grid-template-columns: 1.1fr 1fr 1fr;
  gap: 10px;
  min-height: 0;
}

@media (max-width: 1180px) {
  .slide01-scene-root {
    padding: 0 14px 96px;
    overflow-y: auto;
  }

  .slide01-scene-grid-top {
    grid-template-columns: 1fr;
  }

  .slide01-scene-grid-bottom {
    grid-template-columns: 1fr;
  }
}


----- END FILE: components/slides/slide01-ui/ui/scene/slide01.scene.css -----


----- BEGIN FILE: components/slides/slide01-ui/ui/scene/index.ts -----

export * from "./Slide01Scene";


----- END FILE: components/slides/slide01-ui/ui/scene/index.ts -----


----- BEGIN FILE: components/slides/slide01-ui/index.ts -----

export * from "./core/fsm";
export * from "./core/replay";
export { Slide01Scene } from "./ui/scene";


----- END FILE: components/slides/slide01-ui/index.ts -----


----- BEGIN FILE: docs/slide01/00-contract.md -----

# Slide01 Contract - Route Selector (Deterministic)

## 1. Purpose

Slide01 is a deterministic, user-driven route selector interaction.
The interaction is used to choose between two implementation routes (A and B) by weighing visible criteria through a deliberate pointer gesture.

This contract defines:
- Finite-state machine (FSM) states and transitions.
- Deterministic scoring model.
- Replay trace format and validation.
- Stable `data-testid` identifiers for all actionable controls.
- Test expectations for unit and smoke e2e coverage.

## 2. Scope

In-scope modules are restricted to:
- `components/slides/slide01-ui/**`
- `components/slides/Slide01.tsx`
- `tests/e2e/**` (Slide01 only)
- `docs/slide01/**`

Out of scope:
- runtime boot providers
- gate logic
- global deck wiring
- unrelated slide behavior

## 3. Interaction Summary

User flow:
1. User lands in `idle` state.
2. User presses pointer down inside the weighing arena (`aiming`).
3. User drags deliberately while keeping pointer down (`weighing`).
4. User releases pointer (`committed`).
5. System deterministically resolves selected route and explanation (`resolved`).

There is no autoplay, no randomization, and no timer-based transition.

## 4. Deterministic Invariants

The implementation must satisfy all invariants below.

1. Same trace events in same order always produce the same final state.
2. Same final state always renders the same evidence text and criteria bullets.
3. Tie-breaking is deterministic and explicit (`B` wins ties).
4. Route resolution never depends on wall-clock time.
5. Replay is pure reducer execution over trace-derived actions.
6. Every action has a stable `data-testid` target when initiated from UI.
7. Pointer coordinates are normalized into `[0..1]` and clamped.
8. Pointer move events with no active pointer are ignored.
9. Pointer up with no active session is ignored.
10. Reset always returns to initial state.

## 5. Route Model

### 5.1 Route A

- ID: `A`
- Label: `Route A`
- Name: `Rapid Stabilization`
- Intent: fast local mitigation to reduce immediate operational pressure.

### 5.2 Route B

- ID: `B`
- Label: `Route B`
- Name: `Standardized Scale Path`
- Intent: durable, scalable, and auditable operating model.

### 5.3 Criteria Definitions

Each criterion has:
- stable id
- human label
- weight
- route profile fit for A/B

Criteria IDs:
- `deliverySpeed`
- `operationalRisk`
- `scalability`
- `budgetPredictability`
- `knowledgeRetention`

Weight totals:
- sum of weights must equal `1.00`.

## 6. FSM Contract

### 6.1 States

- `idle`
- `aiming`
- `weighing`
- `committed`
- `resolved`

### 6.2 State Diagram

```text
idle
  -- pointerdown -->
aiming
  -- pointermove (distance >= threshold) -->
weighing
  -- pointerup -->
committed
  -- resolve_committed -->
resolved
  -- reset -->
idle
```

Support transitions:
- `aiming -- reset --> idle`
- `weighing -- reset --> idle`
- `committed -- reset --> idle`
- `resolved -- reset --> idle`

### 6.3 Transition Guards

- `pointerdown` only starts session when inside weighing arena.
- `pointermove` only updates gesture when pointer session is active.
- `pointerup` only commits when pointer session is active.
- `resolve_committed` only transitions when phase is `committed`.

### 6.4 Action Types

- `POINTER_EVENT`
- `RESOLVE_COMMITTED`
- `RESET`
- `TOGGLE_HUD`
- `SET_REPLAY_TEXT`
- `REPLAY_APPLY`

### 6.5 Transition Table

| Current | Action | Guard | Next | Notes |
|---|---|---|---|---|
| idle | POINTER_EVENT(pointerdown) | valid event | aiming | starts gesture session |
| idle | POINTER_EVENT(pointermove) | no session | idle | ignored |
| idle | POINTER_EVENT(pointerup) | no session | idle | ignored |
| idle | RESET | none | idle | idempotent |
| idle | TOGGLE_HUD | none | idle | ui-only flag changes |
| aiming | POINTER_EVENT(pointermove) | movement below threshold | aiming | updates provisional metrics |
| aiming | POINTER_EVENT(pointermove) | movement crosses threshold | weighing | first deliberate weighting frame |
| aiming | POINTER_EVENT(pointerup) | active session | committed | score snapshot frozen |
| aiming | RESET | none | idle | clears trace and score |
| weighing | POINTER_EVENT(pointermove) | active session | weighing | updates provisional score |
| weighing | POINTER_EVENT(pointerup) | active session | committed | score snapshot frozen |
| weighing | RESET | none | idle | clears trace and score |
| committed | RESOLVE_COMMITTED | none | resolved | winner + explanation evidence |
| committed | RESET | none | idle | manual reset |
| resolved | RESET | none | idle | allows repeat |
| resolved | POINTER_EVENT(pointerdown) | valid event | aiming | starts new run in same session counter |
| resolved | TOGGLE_HUD | none | resolved | diagnostics visibility |

## 7. Gesture Contract

### 7.1 Event Capture

Captured events:
- `pointerdown`
- `pointermove`
- `pointerup`

Fields per event:
- `kind`
- `seq`
- `x`
- `y`
- `pointerId`
- `button`
- `targetId`

### 7.2 Normalization

For a pointer event within arena rectangle:
- `x = clamp((clientX - rect.left) / rect.width, 0, 1)`
- `y = clamp((clientY - rect.top) / rect.height, 0, 1)`

### 7.3 Deliberate Gesture Threshold

Aiming becomes weighing when Manhattan delta from start crosses threshold:
- `abs(current.x - start.x) + abs(current.y - start.y) >= 0.045`

### 7.4 Metrics Produced

- `sampleCount`
- `totalDistance`
- `horizontalTravel`
- `verticalTravel`
- `meanX`
- `meanY`
- `spreadX`
- `spreadY`
- `momentum`
- `stability`
- `commitment`
- `urgency`
- `biasRight`
- `deliberation`

## 8. Scoring Contract

### 8.1 Scoring Inputs

Inputs are deterministic metrics from gesture samples.

Derived scalars:
- `biasRight = clamp01((meanX - 0.5) * 1.8 + 0.5)`
- `deliberation = clamp01(stability * 0.55 + commitment * 0.45)`

### 8.2 Criterion Emphasis Formulas

Each criterion emphasis in `[0..1]`.

- `deliverySpeed`
  - `0.25 + urgency*0.5 + momentum*0.2 - stability*0.15`
- `operationalRisk`
  - `0.2 + deliberation*0.5 + biasRight*0.2 + meanY*0.1`
- `scalability`
  - `0.15 + biasRight*0.45 + spreadX*0.2 + commitment*0.2`
- `budgetPredictability`
  - `0.2 + stability*0.45 + commitment*0.25 + meanY*0.1 - urgency*0.1`
- `knowledgeRetention`
  - `0.15 + deliberation*0.35 + meanY*0.2 + biasRight*0.2 + spreadY*0.1`

All formulas are clamped to `[0..1]`.

### 8.3 Route Compatibility

Compatibility function:
- `compatibility = 1 - abs(emphasis - profile)`

Per-criterion points:
- `pointsA = weight * compatibility(emphasis, profileA)`
- `pointsB = weight * compatibility(emphasis, profileB)`

Total score:
- `scoreA = sum(pointsA) * 100`
- `scoreB = sum(pointsB) * 100`

Winner:
- if `scoreB - scoreA > 0.0001` => `B`
- if `scoreA - scoreB > 0.0001` => `A`
- else tie => `B`

### 8.4 Explanation Rules

Explanation bullets are generated from sorted contribution deltas.

Rules:
1. Rank criteria by absolute delta.
2. Emit top 3 criteria as bullets.
3. Emit one metrics bullet summarizing certainty factors.
4. Keep bullet text stable and deterministic.

## 9. Replay Contract

### 9.1 Envelope Schema

```json
{
  "version": "slide01.trace.v1",
  "source": "Slide01",
  "events": [
    {
      "kind": "pointerdown",
      "seq": 1,
      "x": 0.2,
      "y": 0.6,
      "pointerId": 1,
      "button": 0,
      "targetId": "slide01-weigh-arena"
    }
  ]
}
```

### 9.2 Validation

Envelope is valid when:
- `version === "slide01.trace.v1"`
- `source === "Slide01"`
- `events` is an array
- every event has all required fields and normalized coordinates
- events are strictly increasing by `seq`

### 9.3 Replay Execution

Replay resets machine and applies events in order through reducer actions:
1. map trace event to reducer action list
2. apply all mapped actions sequentially
3. return resulting state

Pointer event mapping:
- `pointerdown` -> `[POINTER_EVENT]`
- `pointermove` -> `[POINTER_EVENT]`
- `pointerup` -> `[POINTER_EVENT, RESOLVE_COMMITTED]`

### 9.4 Replay Result

Replay returns:
- final phase
- selected route
- score snapshot
- explanation bullets
- event count
- status reason (`ok` / `parse_error` / `validation_error`)

## 10. UI Components Contract

### 10.1 Scene Composition

- `Slide01Scene` is the single exported scene component from `slide01-ui`.
- `Slide01.tsx` remains a thin shell with Header/NavArea and scene insertion.

### 10.2 Required UI Blocks

- Route cards panel (A/B with criteria fit)
- Weighing arena panel
- Outcome panel
- Replay panel
- Dev HUD panel (off by default)

### 10.3 Mandatory Behaviors

- no autoplay
- no randomization
- no timer loops
- deterministic state progression
- explicit reset action
- trace export action
- trace replay action

## 11. Test IDs

All actionable elements must have stable `data-testid`.

### 11.1 Scene and Root

- `slide01-scene`
- `slide01-title`
- `slide01-subtitle`
- `slide01-phase-chip`
- `slide01-main-grid`

### 11.2 Route Cards

- `slide01-routes-panel`
- `slide01-route-card-A`
- `slide01-route-card-B`
- `slide01-route-title-A`
- `slide01-route-title-B`
- `slide01-route-tag-A`
- `slide01-route-tag-B`
- `slide01-route-score-A`
- `slide01-route-score-B`
- `slide01-route-selected-A`
- `slide01-route-selected-B`
- `slide01-route-criterion-deliverySpeed-A`
- `slide01-route-criterion-deliverySpeed-B`
- `slide01-route-criterion-operationalRisk-A`
- `slide01-route-criterion-operationalRisk-B`
- `slide01-route-criterion-scalability-A`
- `slide01-route-criterion-scalability-B`
- `slide01-route-criterion-budgetPredictability-A`
- `slide01-route-criterion-budgetPredictability-B`
- `slide01-route-criterion-knowledgeRetention-A`
- `slide01-route-criterion-knowledgeRetention-B`

### 11.3 Weighing Arena

- `slide01-weigh-panel`
- `slide01-weigh-instruction`
- `slide01-weigh-arena`
- `slide01-weigh-arena-grid`
- `slide01-weigh-axis-x`
- `slide01-weigh-axis-y`
- `slide01-pointer-dot`
- `slide01-pointer-start-dot`
- `slide01-live-bias`
- `slide01-live-deliberation`
- `slide01-live-urgency`
- `slide01-live-samples`

### 11.4 Outcome

- `slide01-outcome-panel`
- `slide01-outcome-state`
- `slide01-outcome-headline`
- `slide01-outcome-score`
- `slide01-outcome-bullets`
- `slide01-outcome-bullet-0`
- `slide01-outcome-bullet-1`
- `slide01-outcome-bullet-2`
- `slide01-outcome-bullet-3`
- `slide01-outcome-winner`
- `slide01-outcome-reset`

### 11.5 Replay Controls

- `slide01-replay-panel`
- `slide01-trace-length`
- `slide01-trace-export`
- `slide01-trace-copy`
- `slide01-replay-input`
- `slide01-replay-load-sample`
- `slide01-replay-apply`
- `slide01-replay-status`

### 11.6 Dev HUD

- `slide01-hud-toggle`
- `slide01-hud-panel`
- `slide01-hud-phase`
- `slide01-hud-score-A`
- `slide01-hud-score-B`
- `slide01-hud-delta`
- `slide01-hud-trace`
- `slide01-hud-transition-count`

### 11.7 Navigation Hooks

- `slide01-scene` must remain visible while `NavArea` previous/next controls remain functional.

## 12. Evidence Text Contract

Resolved evidence headline format:
- `Route A selected` or `Route B selected`

Score evidence format:
- `A: <xx.xx> | B: <yy.yy> | Delta: <zz.zz>`

Reason bullet format:
- `Operational Risk: +12.40 pts for Route B`

## 13. Error Handling

Replay parse/validation errors must:
- not crash scene
- set replay status to `error`
- surface stable user-visible message
- preserve previous resolved evidence when possible

## 14. Accessibility Contract

- Weighing arena supports pointer interaction.
- Buttons are semantic `<button>` elements.
- Replay textarea has label and placeholder.
- Outcome text uses high-contrast classes.

## 15. Unit Test Matrix

The following matrix must be covered by Slide01 unit tests.

### 15.1 Reducer and FSM

- idle + pointerdown => aiming
- aiming + move below threshold => aiming
- aiming + move above threshold => weighing
- weighing + move => weighing
- aiming + pointerup => committed
- weighing + pointerup => committed
- committed + resolve => resolved
- resolved + reset => idle
- toggle hud flips boolean
- pointermove without active session ignored
- pointerup without active session ignored

### 15.2 Scoring

- stable right-biased deep gesture favors Route B
- urgent left-biased shallow gesture favors Route A
- deterministic tie goes Route B
- weights sum to 1.00
- all criterion emphasis values clamped [0..1]
- score range bounded [0..100]

### 15.3 Replay

- envelope parse success on valid json
- parse error on malformed json
- validation error on out-of-order seq
- validation error on invalid kind
- replay reproduces selected route from original trace
- replay event count equals trace length

## 16. Smoke E2E Matrix

Happy path smoke test:
1. Navigate to app root.
2. Move to Slide01.
3. Assert scene and critical controls visible.
4. Execute deterministic drag gesture from left-mid to right-lower.
5. Assert resolved outcome headline visible.
6. Assert winner evidence text exists.
7. Export trace.
8. Replay trace.
9. Assert winner and score evidence remain stable.

## 17. State Payload Contract

`Slide01MachineState` required keys:
- `phase`
- `phaseHistory`
- `hudVisible`
- `trace`
- `pointer`
- `metrics`
- `score`
- `winner`
- `outcome`
- `transitionCount`
- `replay`

## 18. Reducer Purity

Reducer must:
- be side-effect free
- avoid mutable shared state
- return new objects only when fields change
- never read browser globals directly

Side effects (clipboard, text area IO) remain in UI adapters.

## 19. Replay Purity

Replay runner must:
- be deterministic
- run without DOM
- only call reducer and pure mappers
- return identical output for identical input

## 20. Constants Contract

- `SLIDE01_TRACE_VERSION = "slide01.trace.v1"`
- `SLIDE01_TRACE_SOURCE = "Slide01"`
- `SLIDE01_TIE_BREAKER = "B"`
- `SLIDE01_MOVEMENT_THRESHOLD = 0.045`

## 21. Event Mapping Contract

### 21.1 Live Event Mapping

DOM pointer event -> trace event -> reducer actions.

### 21.2 Replay Event Mapping

JSON trace event -> reducer actions (same mapper).

Mapping function must be shared to guarantee parity.

## 22. Performance Contract

- Gesture handling uses O(1) incremental updates where practical.
- Replay linear complexity O(n) with n = trace events.
- No animation loops in core logic.

## 23. Security and Robustness

- Replay parser limits numeric parsing to finite values.
- Unknown fields in trace payload are ignored.
- Unknown action kinds are rejected.

## 24. Developer HUD Contract

HUD is opt-in via explicit button.
Default HUD state is hidden.
HUD shows:
- phase
- scoreA
- scoreB
- delta
- trace length
- transition count

HUD must not alter scoring or transitions.

## 25. Copy Contract

Scene copy anchors:
- Header label: `ROUTE SELECTOR`
- Instruction: `Click and drag to weigh criteria, then release to commit.`
- Outcome label: `Deterministic decision evidence`

## 26. Regression Constraints

- Deck navigation must remain functional through existing NavArea wiring.
- Slide01 load should not emit console errors.
- Interaction must complete in under 10 seconds in normal test conditions.

## 27. Known Assumptions

- App starts on Slide00, then user navigates to Slide01 using ArrowRight.
- Slide01 scene uses shared shell and does not alter app-level providers.

## 28. Test Data Samples

### 28.1 Route B leaning sample

- down at `(0.22, 0.44)`
- moves toward `(0.78, 0.76)`
- up at `(0.82, 0.78)`

Expected winner: `B`

### 28.2 Route A leaning sample

- down at `(0.70, 0.60)`
- quick moves toward `(0.18, 0.25)`
- up at `(0.12, 0.20)`

Expected winner: `A`

## 29. Contract Compliance Checklist

- [ ] Thin `Slide01.tsx` orchestrator only
- [ ] `slide01-ui` modular tree created
- [ ] deterministic reducer/FSM implemented
- [ ] replay capture and replay loader implemented
- [ ] dev HUD off by default implemented
- [ ] stable `data-testid` coverage complete
- [ ] unit tests added for reducer/scoring/replay
- [ ] smoke e2e added for happy path
- [ ] docs `REPORT.md` added

## 30. Extended Test ID Notes

The following IDs are reserved for future internal assertions and can be added without contract break:
- `slide01-criterion-signal-deliverySpeed`
- `slide01-criterion-signal-operationalRisk`
- `slide01-criterion-signal-scalability`
- `slide01-criterion-signal-budgetPredictability`
- `slide01-criterion-signal-knowledgeRetention`

These IDs are optional in v1 but recommended for diagnostics.

## 31. Deterministic Replay Acceptance

A replay is accepted when all conditions are true:
1. `final.phase === "resolved"`
2. `final.winner` equals expected winner from source run
3. score deltas are exactly equal to source run (rounded string format)
4. `trace.length` equals imported event count

## 32. Failure Modes and User Signals

- parse failure -> `Replay error: invalid JSON`
- schema failure -> `Replay error: invalid trace envelope`
- sequence failure -> `Replay error: invalid sequence`
- unsupported kind -> `Replay error: unsupported pointer kind`

## 33. State Serialization Contract

Serialized deterministic state snapshot contains:
- phase
- scoreA
- scoreB
- winner
- traceLength
- topReasonIds (array)

Snapshot serialization is used only for diagnostics and tests.

## 34. Minimal Replay Harness Requirements

The harness must expose pure functions:
- `serializeTraceEnvelope(state.trace)`
- `parseTraceEnvelope(json)`
- `replayTraceFromInitial(envelope)`

## 35. Final Contract Statement

Slide01 is considered complete when:
- deterministic route selection works by deliberate user gesture,
- replay reproduces decision through reducer path,
- evidence text is visible and stable,
- and all listed tests pass in the target environment.


----- END FILE: docs/slide01/00-contract.md -----


----- BEGIN FILE: docs/slide01/REPORT.md -----

# Slide01 Implementation Report

## 1. Goal

Slide01 was rebuilt as a deterministic, user-driven route selector that:
- presents two routes with explicit criteria,
- captures deliberate pointer gesture input,
- computes deterministic Route A/B scoring,
- resolves a visible outcome with explanation,
- supports trace capture and replay through the same reducer path,
- remains compatible with existing deck navigation.

## 2. Scope Compliance

Changes were limited to allowed paths:
- `components/slides/slide01-ui/**`
- `components/slides/Slide01.tsx`
- `tests/e2e/**` (Slide01 files only)
- `docs/slide01/**`

No runtime boot, gate, or provider wiring was modified.

## 3. Deliverables Completed

1. Production modules in `components/slides/slide01-ui/**`.
2. `Slide01.tsx` reduced to thin composition wrapper.
3. Deterministic reducer/FSM with state progression:
   - `idle -> aiming -> weighing -> committed -> resolved`.
4. Minimal replay harness:
   - pointer trace capture,
   - JSON export/import,
   - deterministic replay through reducer actions.
5. Documentation:
   - `docs/slide01/00-contract.md`
   - `docs/slide01/REPORT.md`
6. Tests:
   - unit tests for reducer/scoring/replay in `slide01-ui/core/**`,
   - Playwright smoke test `tests/e2e/slide01-route-selector.e2e.spec.ts`.

## 4. Slide01 Composition

`components/slides/Slide01.tsx` now only composes shell primitives and scene:
- `SlideContainer`
- `Header`
- `Slide01Scene`
- `NavArea`

All interaction logic moved into `slide01-ui`.

## 5. Architecture Summary

### 5.1 Core FSM

Path:
- `components/slides/slide01-ui/core/fsm/types.ts`
- `components/slides/slide01-ui/core/fsm/reducer.ts`
- `components/slides/slide01-ui/core/fsm/actions.ts`
- `components/slides/slide01-ui/core/fsm/scoring.ts`
- `components/slides/slide01-ui/core/fsm/gesture.ts`

Responsibilities:
- own full interaction state,
- process pointer events,
- compute metrics + score snapshots,
- resolve deterministic decision,
- maintain phase history and transition count.

### 5.2 Replay Core

Path:
- `components/slides/slide01-ui/core/replay/trace.ts`
- `components/slides/slide01-ui/core/replay/capture.ts`
- `components/slides/slide01-ui/core/replay/runner.ts`
- `components/slides/slide01-ui/core/replay/samples.ts`

Responsibilities:
- normalize pointer coordinates,
- serialize and validate trace envelopes,
- parse replay JSON with deterministic hash,
- replay envelope through reducer action mapping.

### 5.3 UI Modules

Paths:
- `components/slides/slide01-ui/ui/atoms/**`
- `components/slides/slide01-ui/ui/panels/**`
- `components/slides/slide01-ui/ui/hud/**`
- `components/slides/slide01-ui/ui/scene/**`

Responsibilities:
- present route cards and criteria,
- provide weighing arena,
- show deterministic outcome evidence,
- expose replay controls and HUD toggle.

## 6. Deterministic Interaction Behavior

### 6.1 Input Model

Captured events:
- `pointerdown`
- `pointermove`
- `pointerup`

Event payload includes:
- normalized `x/y`,
- `seq`,
- `pointerId`,
- `button`,
- `targetId`.

### 6.2 State Progression

- `pointerdown` starts session and enters `aiming`.
- movement crossing threshold enters `weighing`.
- `pointerup` commits gesture (`committed`).
- shared mapper adds resolve action after `pointerup`.
- reducer resolves route (`resolved`) and generates reasons.

### 6.3 Determinism Guards

- no timer-based transitions,
- no random numbers,
- tie-breaker fixed to Route B,
- replay uses same action mapping as live events.

## 7. Replay Harness

### 7.1 Export

`Export` serializes current trace to:
- version `slide01.trace.v1`
- source `Slide01`
- ordered pointer events.

### 7.2 Import/Reapply

`Replay JSON` path:
1. parse JSON,
2. validate envelope and sequence order,
3. replay via reducer path,
4. apply replayed state to scene.

### 7.3 Error Handling

Replay parser surfaces deterministic messages:
- invalid JSON,
- invalid envelope/source/version,
- invalid sequence,
- unsupported pointer kind.

## 8. UI Evidence Added

Visible deterministic evidence:
- headline: `Route A selected` / `Route B selected`,
- winner label,
- score line:
  - `A: xx.xx | B: yy.yy | Delta: zz.zz`,
- reason bullet list with criterion impacts.

Reset action included to repeat interaction.

## 9. Dev HUD

HUD remains off by default.
Toggled by explicit button:
- test id: `slide01-hud-toggle`.

HUD displays:
- phase,
- scoreA,
- scoreB,
- delta,
- trace length,
- transition count.

## 10. Test IDs

Actionable controls all have stable `data-testid` and are documented in:
- `docs/slide01/00-contract.md`.

## 11. Files Added/Changed

### 11.1 Changed

- `components/slides/Slide01.tsx`

### 11.2 Added Core FSM

- `components/slides/slide01-ui/core/fsm/types.ts`
- `components/slides/slide01-ui/core/fsm/constants.ts`
- `components/slides/slide01-ui/core/fsm/math.ts`
- `components/slides/slide01-ui/core/fsm/gesture.ts`
- `components/slides/slide01-ui/core/fsm/scoring.ts`
- `components/slides/slide01-ui/core/fsm/reducer.ts`
- `components/slides/slide01-ui/core/fsm/actions.ts`
- `components/slides/slide01-ui/core/fsm/selectors.ts`
- `components/slides/slide01-ui/core/fsm/index.ts`

### 11.3 Added Core Replay

- `components/slides/slide01-ui/core/replay/trace.ts`
- `components/slides/slide01-ui/core/replay/capture.ts`
- `components/slides/slide01-ui/core/replay/runner.ts`
- `components/slides/slide01-ui/core/replay/samples.ts`
- `components/slides/slide01-ui/core/replay/index.ts`

### 11.4 Added UI

- `components/slides/slide01-ui/ui/atoms/PanelFrame.tsx`
- `components/slides/slide01-ui/ui/atoms/ActionButton.tsx`
- `components/slides/slide01-ui/ui/atoms/PhaseChip.tsx`
- `components/slides/slide01-ui/ui/atoms/MetricBar.tsx`
- `components/slides/slide01-ui/ui/atoms/RouteCriterionRow.tsx`
- `components/slides/slide01-ui/ui/atoms/ScorePill.tsx`
- `components/slides/slide01-ui/ui/atoms/index.ts`
- `components/slides/slide01-ui/ui/panels/RoutesPanel.tsx`
- `components/slides/slide01-ui/ui/panels/WeighPanel.tsx`
- `components/slides/slide01-ui/ui/panels/OutcomePanel.tsx`
- `components/slides/slide01-ui/ui/panels/ReplayPanel.tsx`
- `components/slides/slide01-ui/ui/panels/CriteriaSignalsPanel.tsx`
- `components/slides/slide01-ui/ui/panels/index.ts`
- `components/slides/slide01-ui/ui/hud/DevHud.tsx`
- `components/slides/slide01-ui/ui/hud/index.ts`
- `components/slides/slide01-ui/ui/scene/Slide01Scene.tsx`
- `components/slides/slide01-ui/ui/scene/slide01.scene.css`
- `components/slides/slide01-ui/ui/scene/index.ts`
- `components/slides/slide01-ui/index.ts`

### 11.5 Added Unit Tests

- `components/slides/slide01-ui/core/fsm/slide01-scoring.unit.ts`
- `components/slides/slide01-ui/core/fsm/slide01-reducer.unit.ts`
- `components/slides/slide01-ui/core/replay/slide01-replay.unit.ts`
- `components/slides/slide01-ui/core/slide01-unit-runner.ts`

### 11.6 Added E2E

- `tests/e2e/slide01-route-selector.e2e.spec.ts`
- `tests/e2e/slide01.playwright.config.ts`

### 11.7 Added Docs

- `docs/slide01/00-contract.md`
- `docs/slide01/REPORT.md`

## 12. Commands Executed

### 12.1 Unit Runner

Command:
```bash
npx tsx components/slides/slide01-ui/core/slide01-unit-runner.ts
```

Result:
- PASS (`[slide01-unit] PASS`)

### 12.2 Typecheck (project standard)

Command:
```bash
npm run typecheck
```

Result:
- PASS

### 12.3 Slide01 Smoke E2E (isolated harness)

Command:
```bash
npx concurrently -k --success first \
  "npx wait-on http://127.0.0.1:3230 --timeout 120000 && npx playwright test --config tests/e2e/slide01.playwright.config.ts" \
  "npx cross-env DEMO_TEST_MODE=true VITE_ENABLE_VOICE=false tsx watch server/index.ts" \
  "npx cross-env DEMO_TEST_MODE=true VITE_ENABLE_VOICE=false vite --port 3230 --host 127.0.0.1 --strictPort"
```

Result:
- PASS (`1 passed`)

## 13. Notes About Environment Issues

- Default e2e config port (`3200`) had external collisions in this environment.
- Added Slide01-only Playwright config on isolated port `3230` to keep smoke deterministic.
- No shared/global Playwright config was modified.

## 14. LOC Summary

Meaningful additions are above requested threshold.
Approximate total lines in changed/created Slide01 scope: >3900.

## 15. Assumptions

1. Deck starts at Slide00 in e2e environments.
2. Navigation to Slide01 remains available via `ArrowRight` or `NEXT`.
3. Replay tie-breaker is intentionally fixed to Route B.

## 16. Remaining TODOs (Minimal)

1. If desired, register Slide01 unit runner in global `tests/unit/run-all.ts` later (outside current allowed scope).
2. If desired, consolidate e2e port strategy across repo to avoid shared collisions.


----- END FILE: docs/slide01/REPORT.md -----


----- BEGIN FILE: tests/e2e/slide01-route-selector.e2e.spec.ts -----

import { expect, test } from "@playwright/test";

test("Slide01 route selector resolves deterministically and replay reproduces evidence", async ({
  page,
}) => {
  const severe: string[] = [];
  page.on("console", (message) => {
    if (message.type() !== "error") return;
    const text = message.text();
    if (/favicon|Failed to load resource/i.test(text)) return;
    severe.push(text);
  });

  await page.goto("/");
  await expect(page.getByTestId("deck-root")).toBeVisible();
  await expect(page.getByTestId("slide00-boot-console")).toBeVisible();

  await page.keyboard.press("ArrowRight");
  if ((await page.getByTestId("slide01-scene").count()) === 0) {
    await page.getByRole("button", { name: /NEXT/i }).click();
  }

  await expect(page.getByTestId("slide01-scene")).toBeVisible();
  await expect(page.getByTestId("slide01-weigh-arena")).toBeVisible();
  await expect(page.getByTestId("slide01-outcome-headline")).toBeVisible();

  const arena = page.getByTestId("slide01-weigh-arena");
  const box = await arena.boundingBox();
  expect(box).not.toBeNull();
  if (!box) return;

  const startX = box.x + box.width * 0.22;
  const startY = box.y + box.height * 0.44;
  const midX = box.x + box.width * 0.56;
  const midY = box.y + box.height * 0.63;
  const endX = box.x + box.width * 0.82;
  const endY = box.y + box.height * 0.78;

  await page.mouse.move(startX, startY);
  await page.mouse.down();
  await page.mouse.move(midX, midY);
  await page.mouse.move(endX, endY);
  await page.mouse.up();

  await expect(page.getByTestId("slide01-outcome-headline")).toContainText("Route B selected");
  const winnerText = await page.getByTestId("slide01-outcome-headline").innerText();
  const scoreText = await page.getByTestId("slide01-outcome-score").innerText();
  await expect(page.getByTestId("slide01-trace-length")).toContainText("trace events:");
  await expect(page.getByTestId("slide01-trace-length")).not.toContainText("trace events: 0");

  await page.getByTestId("slide01-trace-export").click();
  const exportedTrace = await page.getByTestId("slide01-replay-input").inputValue();
  expect(exportedTrace).toContain("\"version\": \"slide01.trace.v1\"");

  await page.getByTestId("slide01-outcome-reset").click();
  await expect(page.getByTestId("slide01-outcome-headline")).toContainText("Pending deterministic");

  await page.getByTestId("slide01-replay-input").fill(exportedTrace);
  await page.getByTestId("slide01-replay-apply").click();

  await expect(page.getByTestId("slide01-outcome-headline")).toHaveText(winnerText);
  await expect(page.getByTestId("slide01-outcome-score")).toHaveText(scoreText);
  await expect(page.getByTestId("slide01-replay-status")).toContainText("replayed");

  expect(severe).toEqual([]);
});


----- END FILE: tests/e2e/slide01-route-selector.e2e.spec.ts -----


----- BEGIN FILE: tests/e2e/slide01.playwright.config.ts -----

import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: ".",
  testMatch: ["slide01-route-selector.e2e.spec.ts"],
  timeout: 20000,
  expect: { timeout: 5000 },
  fullyParallel: false,
  retries: 0,
  workers: 1,
  use: {
    baseURL: "http://127.0.0.1:3230",
    headless: true,
  },
});


----- END FILE: tests/e2e/slide01.playwright.config.ts -----

