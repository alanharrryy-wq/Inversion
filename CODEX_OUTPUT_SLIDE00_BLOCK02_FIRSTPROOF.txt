1) Domain summary
Slide 00 FINAL EXPERIENCE LOCK: First Proof Ritual + RightSeal + Layered gesture demo.
- Implemented deterministic gesture state machine (Idle -> Dragged -> Holding -> Sealed) with explicit anchor interaction events.
- Added gesture-driven layered visual demo in main stage (drag parallax/reveal, hold pressure glow/compression, release seal snap).
- Converted right side into a compact RightSeal judgment/status module with post-completion canonical line profile selection.
- Kept Slide00 as thin orchestrator wiring only; runtime semantics untouched.
- Added unit helper tests + Playwright Slide00 smoke for ritual completion and timer/autoplay guard checks.

2) File tree of new/changed files
NEW
- components/slides/slide00-ui/first-proof/firstProof.types.ts
- components/slides/slide00-ui/first-proof/firstProof.helpers.ts
- components/slides/slide00-ui/first-proof/firstProof.copy.ts
- components/slides/slide00-ui/first-proof/useFirstProofRitual.ts
- components/slides/slide00-ui/first-proof/FirstProofRail.tsx
- components/slides/slide00-ui/first-proof/LayerStackDemo.tsx
- components/slides/slide00-ui/first-proof/RightSeal.tsx
- components/slides/slide00-ui/first-proof/FirstProofRitual.tsx
- components/slides/slide00-ui/first-proof/firstProof.css
- components/slides/slide00-ui/first-proof/index.ts
- components/slides/slide00-ui/first-proof/__tests__/firstProof.helpers.test.ts
- tests/e2e/slide00-firstproof.e2e.spec.ts
MODIFIED
- components/slides/Slide00.tsx
- components/slides/slide00-ui/index.ts
- tests/unit/playwright-harness.unit.ts
- tests/unit/run-all.ts

3) Full contents of all NEW files created in this iteration
===== NEW FILE: components/slides/slide00-ui/first-proof/firstProof.types.ts =====
`$ext
export type FirstProofRitualStage = "Idle" | "Dragged" | "Holding" | "Sealed";

export type FirstProofStepKey = "drag" | "hold" | "release";
export type FirstProofStepStatus = "locked" | "active" | "complete";

export type FirstProofSealStatus =
  | "incomplete"
  | "intent-registered"
  | "responsibility-pending"
  | "system-armed"
  | "sealed";

export type FirstProofCanonicalProfile = "legacy" | "speed";

export type FirstProofPointerPoint = {
  x: number;
  y: number;
};

export type FirstProofThresholds = {
  dragThresholdPx: number;
  maxDragTravelPx: number;
  holdTravelThresholdPx: number;
  dragResistance: number;
  holdGain: number;
  releaseSnapPx: number;
};

export type FirstProofState = {
  stage: FirstProofRitualStage;
  pointerActive: boolean;
  activePointerId: number | null;
  originPoint: FirstProofPointerPoint | null;
  pointerPoint: FirstProofPointerPoint | null;
  dragRawPx: number;
  dragVisualPx: number;
  dragPeakPx: number;
  dragProgress: number;
  holdTravelPx: number;
  holdProgress: number;
  sealProgress: number;
};

export type FirstProofMachineEvent =
  | { type: "pointer_down"; pointerId: number; x: number; y: number }
  | { type: "pointer_move"; pointerId: number; x: number; y: number }
  | { type: "pointer_up"; pointerId: number; x: number; y: number }
  | { type: "pointer_cancel"; pointerId: number; x: number; y: number }
  | { type: "reset" };

export type FirstProofAnchorInteractionEvent = {
  kind: "anchor-interaction";
  anchorId: string;
  note: string;
};

export type FirstProofTransitionResult = {
  state: FirstProofState;
  events: FirstProofAnchorInteractionEvent[];
};

export type FirstProofStepModel = {
  key: FirstProofStepKey;
  status: FirstProofStepStatus;
  progress: number;
};

export type FirstProofSnapshot = {
  stage: FirstProofRitualStage;
  activeStep: FirstProofStepKey | "sealed";
  completed: boolean;
  pointerActive: boolean;
  dragProgress: number;
  holdProgress: number;
  releaseProgress: number;
  totalProgress: number;
  layerOffsetPx: number;
  layerReveal: number;
  compression: number;
  glowIntensity: number;
  sealStatus: FirstProofSealStatus;
  steps: FirstProofStepModel[];
};
```

===== NEW FILE: components/slides/slide00-ui/first-proof/firstProof.helpers.ts =====
`$ext
import {
  FirstProofMachineEvent,
  FirstProofSnapshot,
  FirstProofState,
  FirstProofThresholds,
  FirstProofTransitionResult,
} from "./firstProof.types";

export const FIRST_PROOF_DEFAULT_THRESHOLDS: FirstProofThresholds = {
  dragThresholdPx: 148,
  maxDragTravelPx: 332,
  holdTravelThresholdPx: 244,
  dragResistance: 0.34,
  holdGain: 1,
  releaseSnapPx: 186,
};

type StageOrderValue = 0 | 1 | 2 | 3;

const STAGE_ORDER: Record<FirstProofState["stage"], StageOrderValue> = {
  Idle: 0,
  Dragged: 1,
  Holding: 2,
  Sealed: 3,
};

function clamp(value: number, min: number, max: number): number {
  if (value < min) return min;
  if (value > max) return max;
  return value;
}

function distance(a: { x: number; y: number }, b: { x: number; y: number }): number {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.hypot(dx, dy);
}

function applyDragResistance(rawTravelPx: number, thresholds: FirstProofThresholds): number {
  const clampedRaw = clamp(rawTravelPx, 0, thresholds.maxDragTravelPx);
  if (clampedRaw <= thresholds.dragThresholdPx) {
    return clampedRaw;
  }

  const overshoot = clampedRaw - thresholds.dragThresholdPx;
  return thresholds.dragThresholdPx + overshoot * thresholds.dragResistance;
}

function normalizeStage(
  currentStage: FirstProofState["stage"],
  requestedStage: FirstProofState["stage"]
): FirstProofState["stage"] {
  return STAGE_ORDER[requestedStage] >= STAGE_ORDER[currentStage]
    ? requestedStage
    : currentStage;
}

function event(anchorId: string, note: string): FirstProofTransitionResult["events"][number] {
  return {
    kind: "anchor-interaction",
    anchorId,
    note,
  };
}

export function resolveFirstProofThresholds(
  overrides?: Partial<FirstProofThresholds>
): FirstProofThresholds {
  if (!overrides) return FIRST_PROOF_DEFAULT_THRESHOLDS;

  return {
    dragThresholdPx: clamp(
      overrides.dragThresholdPx ?? FIRST_PROOF_DEFAULT_THRESHOLDS.dragThresholdPx,
      64,
      480
    ),
    maxDragTravelPx: clamp(
      overrides.maxDragTravelPx ?? FIRST_PROOF_DEFAULT_THRESHOLDS.maxDragTravelPx,
      120,
      640
    ),
    holdTravelThresholdPx: clamp(
      overrides.holdTravelThresholdPx ?? FIRST_PROOF_DEFAULT_THRESHOLDS.holdTravelThresholdPx,
      80,
      600
    ),
    dragResistance: clamp(
      overrides.dragResistance ?? FIRST_PROOF_DEFAULT_THRESHOLDS.dragResistance,
      0.08,
      0.9
    ),
    holdGain: clamp(overrides.holdGain ?? FIRST_PROOF_DEFAULT_THRESHOLDS.holdGain, 0.1, 3),
    releaseSnapPx: clamp(
      overrides.releaseSnapPx ?? FIRST_PROOF_DEFAULT_THRESHOLDS.releaseSnapPx,
      80,
      380
    ),
  };
}

function withDerivedValues(state: FirstProofState, thresholds: FirstProofThresholds): FirstProofState {
  const dragProgress = clamp(state.dragPeakPx / thresholds.dragThresholdPx, 0, 1);
  const holdProgress = clamp(state.holdTravelPx / thresholds.holdTravelThresholdPx, 0, 1);
  const sealProgress =
    state.stage === "Sealed"
      ? 1
      : state.stage === "Holding"
        ? 0.78
        : state.stage === "Dragged"
          ? 0.34 + holdProgress * 0.38
          : dragProgress * 0.34;

  return {
    ...state,
    dragProgress,
    holdProgress,
    sealProgress: clamp(sealProgress, 0, 1),
  };
}

export function createInitialFirstProofState(
  thresholds: FirstProofThresholds = FIRST_PROOF_DEFAULT_THRESHOLDS
): FirstProofState {
  return withDerivedValues(
    {
      stage: "Idle",
      pointerActive: false,
      activePointerId: null,
      originPoint: null,
      pointerPoint: null,
      dragRawPx: 0,
      dragVisualPx: 0,
      dragPeakPx: 0,
      dragProgress: 0,
      holdTravelPx: 0,
      holdProgress: 0,
      sealProgress: 0,
    },
    thresholds
  );
}

function handlePointerDown(
  state: FirstProofState,
  pointerId: number,
  x: number,
  y: number,
  thresholds: FirstProofThresholds
): FirstProofTransitionResult {
  if (state.stage === "Sealed" || state.pointerActive) {
    return { state, events: [] };
  }

  const nextState = withDerivedValues(
    {
      ...state,
      pointerActive: true,
      activePointerId: pointerId,
      originPoint: { x, y },
      pointerPoint: { x, y },
    },
    thresholds
  );

  return { state: nextState, events: [] };
}

function handlePointerMove(
  state: FirstProofState,
  pointerId: number,
  x: number,
  y: number,
  thresholds: FirstProofThresholds
): FirstProofTransitionResult {
  if (
    state.stage === "Sealed" ||
    !state.pointerActive ||
    state.activePointerId !== pointerId ||
    !state.originPoint ||
    !state.pointerPoint
  ) {
    return { state, events: [] };
  }

  const nextPoint = { x, y };
  const rawDragPx = clamp(nextPoint.x - state.originPoint.x, 0, thresholds.maxDragTravelPx);
  const dragPeakPx = Math.max(state.dragPeakPx, rawDragPx);
  const dragVisualPx = applyDragResistance(rawDragPx, thresholds);

  let nextStage = state.stage;
  const events: FirstProofTransitionResult["events"] = [];

  if (state.stage === "Idle" && dragPeakPx >= thresholds.dragThresholdPx) {
    nextStage = "Dragged";
    events.push(
      event(
        "slide00:firstproof:drag-threshold",
        "First Proof drag threshold reached"
      )
    );
  }

  let holdTravelPx = state.holdTravelPx;
  if (state.stage === "Dragged" || state.stage === "Holding") {
    const movement = distance(state.pointerPoint, nextPoint);
    holdTravelPx = clamp(
      holdTravelPx + movement * thresholds.holdGain,
      0,
      thresholds.holdTravelThresholdPx
    );

    if (
      nextStage === "Dragged" &&
      holdTravelPx >= thresholds.holdTravelThresholdPx
    ) {
      nextStage = "Holding";
      events.push(
        event(
          "slide00:firstproof:hold-threshold",
          "First Proof hold pressure threshold reached"
        )
      );
    }
  }

  const nextState = withDerivedValues(
    {
      ...state,
      stage: nextStage,
      pointerPoint: nextPoint,
      dragRawPx: rawDragPx,
      dragVisualPx,
      dragPeakPx,
      holdTravelPx,
    },
    thresholds
  );

  return { state: nextState, events };
}

function handlePointerRelease(
  state: FirstProofState,
  pointerId: number,
  x: number,
  y: number,
  thresholds: FirstProofThresholds
): FirstProofTransitionResult {
  if (!state.pointerActive || state.activePointerId !== pointerId) {
    return { state, events: [] };
  }

  const events: FirstProofTransitionResult["events"] = [];
  let nextStage = state.stage;
  let dragVisualPx = state.dragVisualPx;
  let dragRawPx = 0;

  if (state.stage === "Holding" && state.holdProgress >= 1) {
    nextStage = normalizeStage(nextStage, "Sealed");
    dragVisualPx = thresholds.releaseSnapPx;
    dragRawPx = thresholds.dragThresholdPx;
    events.push(event("slide00:firstproof:sealed", "First Proof ritual sealed"));
  } else if (state.stage === "Dragged" || state.stage === "Holding") {
    dragVisualPx = Math.max(thresholds.dragThresholdPx * 0.66, state.dragVisualPx * 0.66);
  } else {
    dragVisualPx = 0;
  }

  const nextState = withDerivedValues(
    {
      ...state,
      stage: nextStage,
      pointerActive: false,
      activePointerId: null,
      originPoint: null,
      pointerPoint: { x, y },
      dragRawPx,
      dragVisualPx,
    },
    thresholds
  );

  return { state: nextState, events };
}

export function transitionFirstProofState(
  state: FirstProofState,
  machineEvent: FirstProofMachineEvent,
  thresholds: FirstProofThresholds = FIRST_PROOF_DEFAULT_THRESHOLDS
): FirstProofTransitionResult {
  if (machineEvent.type === "reset") {
    return { state: createInitialFirstProofState(thresholds), events: [] };
  }

  if (machineEvent.type === "pointer_down") {
    return handlePointerDown(
      state,
      machineEvent.pointerId,
      machineEvent.x,
      machineEvent.y,
      thresholds
    );
  }

  if (machineEvent.type === "pointer_move") {
    return handlePointerMove(
      state,
      machineEvent.pointerId,
      machineEvent.x,
      machineEvent.y,
      thresholds
    );
  }

  if (machineEvent.type === "pointer_up" || machineEvent.type === "pointer_cancel") {
    return handlePointerRelease(
      state,
      machineEvent.pointerId,
      machineEvent.x,
      machineEvent.y,
      thresholds
    );
  }

  return { state, events: [] };
}

function deriveSealStatus(state: FirstProofState): FirstProofSnapshot["sealStatus"] {
  if (state.stage === "Sealed") return "sealed";
  if (state.stage === "Holding") return "system-armed";
  if (state.stage === "Dragged" && state.holdProgress > 0.12) return "responsibility-pending";
  if (state.stage === "Dragged") return "intent-registered";
  return "incomplete";
}

export function deriveFirstProofSnapshot(
  state: FirstProofState,
  thresholds: FirstProofThresholds = FIRST_PROOF_DEFAULT_THRESHOLDS
): FirstProofSnapshot {
  const completed = state.stage === "Sealed";
  const activeStep =
    state.stage === "Sealed"
      ? "sealed"
      : state.stage === "Holding"
        ? "release"
        : state.stage === "Dragged"
          ? "hold"
          : "drag";

  const releaseProgress =
    completed ? 1 : state.stage === "Holding" ? 0.72 : 0;

  const totalProgress = completed
    ? 1
    : clamp(state.dragProgress * 0.45 + state.holdProgress * 0.45 + releaseProgress * 0.1, 0, 0.96);

  const layerOffsetPx = completed
    ? thresholds.releaseSnapPx
    : state.pointerActive
      ? state.dragVisualPx
      : state.stage === "Dragged" || state.stage === "Holding"
        ? Math.max(state.dragVisualPx, thresholds.dragThresholdPx * 0.68)
        : state.dragVisualPx;

  const layerReveal = clamp(state.dragProgress * 0.72 + state.holdProgress * 0.28, 0, 1);
  const compression = completed ? 1 : state.holdProgress;
  const glowIntensity = completed
    ? 1
    : clamp(0.24 + state.dragProgress * 0.16 + state.holdProgress * 0.6, 0.24, 0.94);

  return {
    stage: state.stage,
    activeStep,
    completed,
    pointerActive: state.pointerActive,
    dragProgress: state.dragProgress,
    holdProgress: state.holdProgress,
    releaseProgress,
    totalProgress,
    layerOffsetPx,
    layerReveal,
    compression,
    glowIntensity,
    sealStatus: deriveSealStatus(state),
    steps: [
      {
        key: "drag",
        status: state.dragProgress >= 1 ? "complete" : "active",
        progress: state.dragProgress,
      },
      {
        key: "hold",
        status:
          state.dragProgress < 1
            ? "locked"
            : state.holdProgress >= 1
              ? "complete"
              : "active",
        progress: state.holdProgress,
      },
      {
        key: "release",
        status: state.holdProgress < 1 ? "locked" : completed ? "complete" : "active",
        progress: releaseProgress,
      },
    ],
  };
}
```

===== NEW FILE: components/slides/slide00-ui/first-proof/firstProof.copy.ts =====
`$ext
import {
  FirstProofCanonicalProfile,
  FirstProofSealStatus,
  FirstProofStepKey,
} from "./firstProof.types";

export const FIRST_PROOF_COPY = {
  ritualLabel: "FIRST PROOF RITUAL",
  ritualSubtitle: "Gesto explicito. Reaccion deterministica.",
  railTitle: "Micro-rail operativo",
  railSubtitle: "Arrastra. Mantén presionado. Suelta para confirmar.",
  gestureHint: "Sin autoplay. Solo obedece a tu gesto.",
  steps: {
    drag: {
      label: "Arrastra",
      detail: "Desplaza el bloque frontal hasta exponer la capa inferior.",
    },
    hold: {
      label: "Mantén presionado",
      detail: "Sostén y comprime con movimiento para registrar presión.",
    },
    release: {
      label: "Suelta para confirmar",
      detail: "Al soltar en estado ARMED, el sello se fija.",
    },
  } satisfies Record<
    FirstProofStepKey,
    {
      label: string;
      detail: string;
    }
  >,
  status: {
    incomplete: "Ejecución incompleta",
    "intent-registered": "Intención registrada",
    "responsibility-pending": "Responsabilidad pendiente",
    "system-armed": "Sistema armado",
    sealed: "Sistema sellado",
  } satisfies Record<FirstProofSealStatus, string>,
  statusDetail: {
    incomplete: "Sin gesto válido no existe prueba.",
    "intent-registered": "El sistema detectó dirección operativa.",
    "responsibility-pending": "La acción existe, falta sostenerla.",
    "system-armed": "La presión fue suficiente. Falta liberar.",
    sealed: "Sello emitido. Estado congelado.",
  } satisfies Record<FirstProofSealStatus, string>,
  canonical: {
    opening: "Esto no fue diseñado para ser fácil.",
    legacy:
      "Fue diseñado para ser posible… hoy, mañana y cuando tú ya no estés aquí operándolo.",
    speed: "Para quien se mueve más rápido que los demás.",
  },
  seal: {
    badgeLabel: "RIGHT SEAL",
    badgeStateLabel: "Juicio",
    progressLabel: "Progreso",
    compactHint: "El panel evalúa, no explica.",
  },
};

export function getFirstProofCanonicalLine(
  profile: FirstProofCanonicalProfile
): string {
  if (profile === "speed") {
    return FIRST_PROOF_COPY.canonical.speed;
  }
  return FIRST_PROOF_COPY.canonical.legacy;
}

export function getFirstProofStatusCopy(status: FirstProofSealStatus): string {
  return FIRST_PROOF_COPY.status[status];
}

export function getFirstProofStatusDetailCopy(status: FirstProofSealStatus): string {
  return FIRST_PROOF_COPY.statusDetail[status];
}
```

===== NEW FILE: components/slides/slide00-ui/first-proof/useFirstProofRitual.ts =====
`$ext
import React, { useCallback, useMemo, useRef, useState } from "react";
import { getFirstProofCanonicalLine } from "./firstProof.copy";
import {
  createInitialFirstProofState,
  deriveFirstProofSnapshot,
  resolveFirstProofThresholds,
  transitionFirstProofState,
} from "./firstProof.helpers";
import {
  FirstProofCanonicalProfile,
  FirstProofMachineEvent,
  FirstProofSnapshot,
  FirstProofState,
  FirstProofThresholds,
  FirstProofTransitionResult,
} from "./firstProof.types";

export type UseFirstProofRitualOptions = {
  recordAnchorInteraction?: (anchorId: string, note?: string) => void;
  profile?: FirstProofCanonicalProfile;
  thresholds?: Partial<FirstProofThresholds>;
};

type FirstProofGestureHandlers = {
  onPointerDown: React.PointerEventHandler<HTMLDivElement>;
  onPointerMove: React.PointerEventHandler<HTMLDivElement>;
  onPointerUp: React.PointerEventHandler<HTMLDivElement>;
  onPointerCancel: React.PointerEventHandler<HTMLDivElement>;
};

export type UseFirstProofRitualResult = {
  profile: FirstProofCanonicalProfile;
  canonicalLine: string;
  state: FirstProofState;
  snapshot: FirstProofSnapshot;
  thresholds: FirstProofThresholds;
  gestureHandlers: FirstProofGestureHandlers;
  reset: () => void;
};

function pointerEventToMachineEvent(
  event:
    | React.PointerEvent<HTMLDivElement>
    | {
        pointerId: number;
        x: number;
        y: number;
      },
  type: FirstProofMachineEvent["type"]
): FirstProofMachineEvent {
  if ("clientX" in event) {
    if (type === "reset") {
      return { type: "reset" };
    }
    return {
      type,
      pointerId: event.pointerId,
      x: event.clientX,
      y: event.clientY,
    } as FirstProofMachineEvent;
  }

  if (type === "reset") {
    return { type: "reset" };
  }

  return {
    type,
    pointerId: event.pointerId,
    x: event.x,
    y: event.y,
  } as FirstProofMachineEvent;
}

export function useFirstProofRitual(
  options: UseFirstProofRitualOptions = {}
): UseFirstProofRitualResult {
  const resolvedProfile = options.profile ?? "legacy";
  const resolvedThresholds = useMemo(
    () => resolveFirstProofThresholds(options.thresholds),
    [options.thresholds]
  );

  const [state, setState] = useState<FirstProofState>(() =>
    createInitialFirstProofState(resolvedThresholds)
  );
  const stateRef = useRef<FirstProofState>(state);

  const commitTransition = useCallback(
    (result: FirstProofTransitionResult) => {
      stateRef.current = result.state;
      setState(result.state);
      if (!options.recordAnchorInteraction || result.events.length === 0) return;
      for (const emitted of result.events) {
        options.recordAnchorInteraction(emitted.anchorId, emitted.note);
      }
    },
    [options.recordAnchorInteraction]
  );

  const dispatchMachineEvent = useCallback(
    (machineEvent: FirstProofMachineEvent) => {
      const transitionResult = transitionFirstProofState(
        stateRef.current,
        machineEvent,
        resolvedThresholds
      );
      commitTransition(transitionResult);
    },
    [commitTransition, resolvedThresholds]
  );

  const onPointerDown = useCallback<React.PointerEventHandler<HTMLDivElement>>(
    (event) => {
      event.preventDefault();
      if (!event.currentTarget.hasPointerCapture(event.pointerId)) {
        event.currentTarget.setPointerCapture(event.pointerId);
      }

      dispatchMachineEvent(pointerEventToMachineEvent(event, "pointer_down"));
    },
    [dispatchMachineEvent]
  );

  const onPointerMove = useCallback<React.PointerEventHandler<HTMLDivElement>>(
    (event) => {
      dispatchMachineEvent(pointerEventToMachineEvent(event, "pointer_move"));
    },
    [dispatchMachineEvent]
  );

  const onPointerUp = useCallback<React.PointerEventHandler<HTMLDivElement>>(
    (event) => {
      if (event.currentTarget.hasPointerCapture(event.pointerId)) {
        event.currentTarget.releasePointerCapture(event.pointerId);
      }
      dispatchMachineEvent(pointerEventToMachineEvent(event, "pointer_up"));
    },
    [dispatchMachineEvent]
  );

  const onPointerCancel = useCallback<React.PointerEventHandler<HTMLDivElement>>(
    (event) => {
      if (event.currentTarget.hasPointerCapture(event.pointerId)) {
        event.currentTarget.releasePointerCapture(event.pointerId);
      }
      dispatchMachineEvent(pointerEventToMachineEvent(event, "pointer_cancel"));
    },
    [dispatchMachineEvent]
  );

  const reset = useCallback(() => {
    dispatchMachineEvent({ type: "reset" });
  }, [dispatchMachineEvent]);

  const snapshot = useMemo(
    () => deriveFirstProofSnapshot(state, resolvedThresholds),
    [resolvedThresholds, state]
  );

  return {
    profile: resolvedProfile,
    canonicalLine: getFirstProofCanonicalLine(resolvedProfile),
    state,
    snapshot,
    thresholds: resolvedThresholds,
    gestureHandlers: {
      onPointerDown,
      onPointerMove,
      onPointerUp,
      onPointerCancel,
    },
    reset,
  };
}
```

===== NEW FILE: components/slides/slide00-ui/first-proof/FirstProofRail.tsx =====
`$ext
import React from "react";
import { FIRST_PROOF_COPY } from "./firstProof.copy";
import { FirstProofSnapshot } from "./firstProof.types";

export function FirstProofRail(props: {
  snapshot: FirstProofSnapshot;
}) {
  return (
    <section className="slide00-firstproof-rail" aria-label={FIRST_PROOF_COPY.railTitle}>
      <header className="slide00-firstproof-rail-head">
        <p className="slide00-firstproof-kicker">{FIRST_PROOF_COPY.railTitle}</p>
        <p className="slide00-firstproof-rail-subtitle">{FIRST_PROOF_COPY.railSubtitle}</p>
      </header>

      <ol className="slide00-firstproof-step-list">
        {props.snapshot.steps.map((step) => (
          <li
            key={step.key}
            className="slide00-firstproof-step"
            data-status={step.status}
            data-testid={`slide00-firstproof-step-${step.key}`}
          >
            <p className="slide00-firstproof-step-label">{FIRST_PROOF_COPY.steps[step.key].label}</p>
            <p className="slide00-firstproof-step-detail">{FIRST_PROOF_COPY.steps[step.key].detail}</p>
            <div className="slide00-firstproof-step-track" aria-hidden="true">
              <span
                className="slide00-firstproof-step-fill"
                style={{ transform: `scaleX(${step.progress})` }}
              />
            </div>
          </li>
        ))}
      </ol>
    </section>
  );
}
```

===== NEW FILE: components/slides/slide00-ui/first-proof/LayerStackDemo.tsx =====
`$ext
import React from "react";
import { FIRST_PROOF_COPY } from "./firstProof.copy";
import { FirstProofSnapshot } from "./firstProof.types";

type GestureHandlers = {
  onPointerDown: React.PointerEventHandler<HTMLDivElement>;
  onPointerMove: React.PointerEventHandler<HTMLDivElement>;
  onPointerUp: React.PointerEventHandler<HTMLDivElement>;
  onPointerCancel: React.PointerEventHandler<HTMLDivElement>;
};

export function LayerStackDemo(props: {
  snapshot: FirstProofSnapshot;
  gestureHandlers: GestureHandlers;
}) {
  const frontOffset = props.snapshot.layerOffsetPx;
  const middleOffset = frontOffset * (0.52 - props.snapshot.compression * 0.14);
  const rearOffset = frontOffset * (0.26 - props.snapshot.compression * 0.08);
  const compressionScale = 1 - props.snapshot.compression * 0.05;
  const layerReveal = props.snapshot.layerReveal;

  return (
    <section className="slide00-firstproof-stage">
      <header className="slide00-firstproof-stage-head">
        <p className="slide00-firstproof-kicker">{FIRST_PROOF_COPY.ritualLabel}</p>
        <p className="slide00-firstproof-stage-subtitle">{FIRST_PROOF_COPY.ritualSubtitle}</p>
      </header>

      <div
        className="slide00-firstproof-gesture-zone"
        data-pointer-active={props.snapshot.pointerActive}
        data-sealed={props.snapshot.completed}
        data-testid="slide00-firstproof-gesture-drag"
        role="group"
        tabIndex={0}
        aria-label={FIRST_PROOF_COPY.gestureHint}
        onPointerDown={props.gestureHandlers.onPointerDown}
        onPointerMove={props.gestureHandlers.onPointerMove}
        onPointerUp={props.gestureHandlers.onPointerUp}
        onPointerCancel={props.gestureHandlers.onPointerCancel}
      >
        <div className="slide00-firstproof-layer-stack">
          <div
            className="slide00-firstproof-layer slide00-firstproof-layer--rear"
            style={{
              transform: `translate3d(${rearOffset.toFixed(2)}px, 0, 0) scale(${(
                1 -
                props.snapshot.compression * 0.02
              ).toFixed(4)})`,
              opacity: 0.44 + layerReveal * 0.56,
            }}
          />
          <div
            className="slide00-firstproof-layer slide00-firstproof-layer--mid"
            style={{
              transform: `translate3d(${middleOffset.toFixed(2)}px, 0, 0) scale(${(
                1 -
                props.snapshot.compression * 0.03
              ).toFixed(4)})`,
              opacity: 0.56 + layerReveal * 0.44,
            }}
          />
          <div
            className="slide00-firstproof-layer slide00-firstproof-layer--front"
            style={{
              transform: `translate3d(${frontOffset.toFixed(2)}px, 0, 0) scale(${compressionScale.toFixed(
                4
              )})`,
              boxShadow: `0 0 ${Math.round(18 + props.snapshot.glowIntensity * 42)}px rgba(70, 220, 255, ${
                0.18 + props.snapshot.glowIntensity * 0.24
              })`,
            }}
          >
            <span className="slide00-firstproof-layer-caption">OPERATOR INPUT</span>
          </div>
          <div
            className="slide00-firstproof-underlayer-reveal"
            style={{ opacity: layerReveal }}
          >
            <span>UNDER LAYER · EVIDENCE SURFACE</span>
          </div>
        </div>

        <div className="slide00-firstproof-pressure-lens" data-testid="slide00-firstproof-gesture-hold">
          <span>HOLD PRESSURE {Math.round(props.snapshot.holdProgress * 100)}%</span>
        </div>

        <div className="slide00-firstproof-release-lens" data-testid="slide00-firstproof-gesture-release">
          <span>
            {props.snapshot.completed
              ? "SEAL IMPRINT: LOCKED"
              : props.snapshot.activeStep === "release"
                ? "RELEASE TO CONFIRM"
                : "RELEASE CHANNEL: STANDBY"}
          </span>
        </div>
      </div>
    </section>
  );
}
```

===== NEW FILE: components/slides/slide00-ui/first-proof/RightSeal.tsx =====
`$ext
import React from "react";
import {
  FIRST_PROOF_COPY,
  getFirstProofCanonicalLine,
  getFirstProofStatusCopy,
  getFirstProofStatusDetailCopy,
} from "./firstProof.copy";
import { FirstProofCanonicalProfile, FirstProofSnapshot } from "./firstProof.types";

export function RightSeal(props: {
  snapshot: FirstProofSnapshot;
  profile?: FirstProofCanonicalProfile;
}) {
  const profile = props.profile ?? "legacy";
  const canonicalLine = getFirstProofCanonicalLine(profile);

  return (
    <section
      className="slide00-rightseal"
      data-sealed={props.snapshot.completed}
      data-testid="slide00-rightseal"
      aria-live="polite"
    >
      <header className="slide00-rightseal-head">
        <p className="slide00-rightseal-badge-label">{FIRST_PROOF_COPY.seal.badgeLabel}</p>
        <p className="slide00-rightseal-progress-label">
          {FIRST_PROOF_COPY.seal.progressLabel} {Math.round(props.snapshot.totalProgress * 100)}%
        </p>
      </header>

      <p className="slide00-rightseal-judge-label">{FIRST_PROOF_COPY.seal.badgeStateLabel}</p>
      <p className="slide00-rightseal-state" data-testid="slide00-rightseal-state">
        {getFirstProofStatusCopy(props.snapshot.sealStatus)}
      </p>
      <p className="slide00-rightseal-detail">{getFirstProofStatusDetailCopy(props.snapshot.sealStatus)}</p>

      <div className="slide00-rightseal-progress" role="presentation" aria-hidden="true">
        <span
          className="slide00-rightseal-progress-fill"
          style={{ transform: `scaleX(${props.snapshot.totalProgress})` }}
        />
      </div>

      <p className="slide00-rightseal-hint">{FIRST_PROOF_COPY.seal.compactHint}</p>

      {props.snapshot.completed ? (
        <p className="slide00-rightseal-canonical">{canonicalLine}</p>
      ) : null}
    </section>
  );
}
```

===== NEW FILE: components/slides/slide00-ui/first-proof/FirstProofRitual.tsx =====
`$ext
import React, { useEffect } from "react";
import { FirstProofRail } from "./FirstProofRail";
import { LayerStackDemo } from "./LayerStackDemo";
import { RightSeal } from "./RightSeal";
import "./firstProof.css";
import { useFirstProofRitual } from "./useFirstProofRitual";
import {
  FirstProofCanonicalProfile,
  FirstProofSnapshot,
  FirstProofThresholds,
} from "./firstProof.types";

export function FirstProofRitual(props: {
  recordAnchorInteraction?: (anchorId: string, note?: string) => void;
  profile?: FirstProofCanonicalProfile;
  thresholds?: Partial<FirstProofThresholds>;
  showInlineRightSeal?: boolean;
  onSnapshotChange?: (snapshot: FirstProofSnapshot) => void;
}) {
  const ritual = useFirstProofRitual({
    recordAnchorInteraction: props.recordAnchorInteraction,
    profile: props.profile,
    thresholds: props.thresholds,
  });

  useEffect(() => {
    if (!props.onSnapshotChange) return;
    props.onSnapshotChange(ritual.snapshot);
  }, [props.onSnapshotChange, ritual.snapshot]);

  return (
    <section className="slide00-firstproof-root" data-testid="slide00-firstproof-root">
      <LayerStackDemo snapshot={ritual.snapshot} gestureHandlers={ritual.gestureHandlers} />
      <FirstProofRail snapshot={ritual.snapshot} />
      {props.showInlineRightSeal === false ? null : (
        <RightSeal snapshot={ritual.snapshot} profile={ritual.profile} />
      )}
    </section>
  );
}
```

===== NEW FILE: components/slides/slide00-ui/first-proof/firstProof.css =====
`$ext
.slide00-firstproof-root {
  display: grid;
  gap: 12px;
}

.slide00-power-console-section--firstproof {
  margin-bottom: 12px;
}

.slide00-firstproof-kicker {
  margin: 0;
  font-family: var(--boot-font-code, "Consolas", "Courier New", monospace);
  font-size: var(--boot-font-micro-size, 10px);
  letter-spacing: var(--boot-letter-code, 0.16em);
  text-transform: uppercase;
  color: rgba(188, 223, 237, 0.86);
}

.slide00-firstproof-stage {
  border-radius: var(--boot-radius-lg, 18px);
  border: 1px solid var(--boot-border-soft);
  background:
    radial-gradient(700px 260px at 20% -20%, rgba(70, 220, 255, 0.22), rgba(0, 0, 0, 0) 70%),
    linear-gradient(180deg, rgba(7, 24, 35, 0.86), rgba(6, 17, 24, 0.86));
  box-shadow:
    0 16px 40px rgba(3, 10, 16, 0.46),
    inset 0 0 0 1px rgba(130, 204, 233, 0.12);
  padding: 14px;
  display: grid;
  gap: 10px;
}

.slide00-firstproof-stage-head {
  display: grid;
  gap: 4px;
}

.slide00-firstproof-stage-subtitle {
  margin: 0;
  font-family: var(--boot-font-body, "Segoe UI", sans-serif);
  font-size: var(--boot-font-body-small-size, 12px);
  line-height: var(--boot-font-body-small-line-height, 1.4);
  color: var(--boot-text-dim, rgba(185, 211, 226, 0.72));
}

.slide00-firstproof-gesture-zone {
  border-radius: var(--boot-radius-md, 12px);
  border: 1px solid rgba(130, 204, 233, 0.3);
  background:
    radial-gradient(140% 160% at 0% 0%, rgba(70, 220, 255, 0.18), rgba(0, 0, 0, 0) 60%),
    linear-gradient(160deg, rgba(6, 17, 24, 0.88), rgba(4, 11, 17, 0.9));
  min-height: 220px;
  padding: 12px;
  display: grid;
  grid-template-rows: 1fr auto auto;
  gap: 8px;
  position: relative;
  cursor: grab;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  outline: none;
}

.slide00-firstproof-gesture-zone[data-pointer-active="true"] {
  cursor: grabbing;
}

.slide00-firstproof-gesture-zone:focus-visible {
  box-shadow: 0 0 0 2px rgba(147, 235, 255, 0.9);
}

.slide00-firstproof-layer-stack {
  position: relative;
  min-height: 130px;
}

.slide00-firstproof-layer {
  position: absolute;
  inset: 0;
  border-radius: 12px;
  border: 1px solid rgba(130, 204, 233, 0.3);
  transition: transform 220ms cubic-bezier(0.22, 1, 0.36, 1), opacity 220ms ease, box-shadow 220ms ease;
  transform-origin: center center;
}

.slide00-firstproof-gesture-zone[data-pointer-active="true"] .slide00-firstproof-layer {
  transition: none;
}

.slide00-firstproof-layer--rear {
  background:
    linear-gradient(140deg, rgba(4, 32, 45, 0.86), rgba(3, 18, 26, 0.86));
  border-color: rgba(130, 204, 233, 0.26);
}

.slide00-firstproof-layer--mid {
  background:
    linear-gradient(140deg, rgba(5, 45, 63, 0.84), rgba(3, 24, 34, 0.88));
  border-color: rgba(130, 204, 233, 0.34);
}

.slide00-firstproof-layer--front {
  background:
    linear-gradient(140deg, rgba(12, 84, 112, 0.72), rgba(8, 41, 57, 0.92));
  border-color: rgba(144, 224, 250, 0.58);
  display: flex;
  align-items: flex-end;
  justify-content: flex-start;
  padding: 12px;
}

.slide00-firstproof-layer-caption {
  font-family: var(--boot-font-code, "Consolas", "Courier New", monospace);
  font-size: var(--boot-font-micro-size, 10px);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  color: rgba(229, 242, 250, 0.95);
}

.slide00-firstproof-underlayer-reveal {
  position: absolute;
  inset: auto 10px 10px 10px;
  min-height: 42px;
  border-radius: 8px;
  border: 1px dashed rgba(130, 204, 233, 0.42);
  background: rgba(5, 18, 27, 0.74);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: opacity 180ms ease;
}

.slide00-firstproof-underlayer-reveal > span {
  font-family: var(--boot-font-code, "Consolas", "Courier New", monospace);
  font-size: var(--boot-font-micro-size, 10px);
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: rgba(191, 225, 238, 0.86);
}

.slide00-firstproof-pressure-lens,
.slide00-firstproof-release-lens {
  border-radius: 8px;
  border: 1px solid rgba(130, 204, 233, 0.3);
  background: rgba(5, 17, 25, 0.7);
  min-height: 30px;
  display: flex;
  align-items: center;
  padding: 0 10px;
}

.slide00-firstproof-pressure-lens > span,
.slide00-firstproof-release-lens > span {
  font-family: var(--boot-font-code, "Consolas", "Courier New", monospace);
  font-size: var(--boot-font-micro-size, 10px);
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: rgba(204, 235, 248, 0.9);
}

.slide00-firstproof-release-lens {
  border-color: rgba(144, 224, 250, 0.48);
  background: rgba(4, 23, 33, 0.74);
}

.slide00-firstproof-gesture-zone[data-sealed="true"] .slide00-firstproof-release-lens {
  border-color: rgba(91, 247, 198, 0.56);
  background: rgba(4, 39, 30, 0.7);
}

.slide00-firstproof-rail {
  border-radius: var(--boot-radius-md, 12px);
  border: 1px solid var(--boot-border-soft);
  background: rgba(6, 20, 30, 0.8);
  padding: 12px;
  display: grid;
  gap: 10px;
}

.slide00-firstproof-rail-head {
  display: grid;
  gap: 4px;
}

.slide00-firstproof-rail-subtitle {
  margin: 0;
  font-family: var(--boot-font-body, "Segoe UI", sans-serif);
  font-size: var(--boot-font-body-small-size, 12px);
  line-height: var(--boot-font-body-small-line-height, 1.4);
  color: var(--boot-text-dim, rgba(185, 211, 226, 0.72));
}

.slide00-firstproof-step-list {
  margin: 0;
  padding: 0;
  list-style: none;
  display: grid;
  gap: 8px;
}

.slide00-firstproof-step {
  border-radius: 10px;
  border: 1px solid rgba(130, 204, 233, 0.22);
  background: rgba(4, 13, 20, 0.68);
  padding: 8px 10px;
  display: grid;
  gap: 5px;
}

.slide00-firstproof-step[data-status="active"] {
  border-color: rgba(144, 224, 250, 0.5);
}

.slide00-firstproof-step[data-status="complete"] {
  border-color: rgba(91, 247, 198, 0.46);
  background: rgba(4, 39, 30, 0.52);
}

.slide00-firstproof-step[data-status="locked"] {
  opacity: 0.72;
}

.slide00-firstproof-step-label {
  margin: 0;
  font-family: var(--boot-font-code, "Consolas", "Courier New", monospace);
  font-size: var(--boot-font-code-size, 11px);
  letter-spacing: var(--boot-letter-code, 0.16em);
  text-transform: uppercase;
  color: var(--boot-text, rgba(229, 242, 250, 0.92));
}

.slide00-firstproof-step-detail {
  margin: 0;
  font-family: var(--boot-font-body, "Segoe UI", sans-serif);
  font-size: var(--boot-font-body-small-size, 12px);
  line-height: var(--boot-font-body-small-line-height, 1.4);
  color: var(--boot-text-dim, rgba(185, 211, 226, 0.72));
}

.slide00-firstproof-step-track {
  height: 4px;
  border-radius: 999px;
  background: rgba(100, 144, 164, 0.24);
  overflow: hidden;
}

.slide00-firstproof-step-fill {
  display: block;
  height: 100%;
  width: 100%;
  border-radius: inherit;
  background: linear-gradient(90deg, rgba(70, 220, 255, 0.66), rgba(91, 247, 198, 0.8));
  transform-origin: left center;
  transition: transform 180ms ease;
}

.slide00-rightseal {
  border-radius: var(--boot-radius-lg, 18px);
  border: 1px solid var(--boot-border-soft);
  background:
    radial-gradient(260px 180px at 16% 0%, rgba(70, 220, 255, 0.18), rgba(0, 0, 0, 0) 72%),
    linear-gradient(180deg, rgba(7, 24, 35, 0.88), rgba(5, 17, 25, 0.9));
  box-shadow:
    0 18px 40px rgba(2, 8, 12, 0.52),
    inset 0 0 0 1px rgba(130, 204, 233, 0.14);
  padding: 12px;
  display: grid;
  gap: 8px;
  transition: padding 220ms ease, border-radius 220ms ease, background 220ms ease;
}

.slide00-rightseal-head {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.slide00-rightseal-badge-label,
.slide00-rightseal-progress-label,
.slide00-rightseal-judge-label {
  margin: 0;
  font-family: var(--boot-font-code, "Consolas", "Courier New", monospace);
  font-size: var(--boot-font-micro-size, 10px);
  letter-spacing: var(--boot-letter-code, 0.16em);
  text-transform: uppercase;
}

.slide00-rightseal-badge-label {
  color: rgba(224, 244, 253, 0.94);
}

.slide00-rightseal-progress-label,
.slide00-rightseal-judge-label {
  color: rgba(185, 211, 226, 0.78);
}

.slide00-rightseal-state {
  margin: 0;
  font-family: var(--boot-font-display, "Segoe UI", sans-serif);
  font-size: clamp(17px, 2.1vw, 21px);
  line-height: 1.14;
  color: rgba(236, 249, 255, 0.97);
  letter-spacing: -0.01em;
}

.slide00-rightseal-detail,
.slide00-rightseal-hint,
.slide00-rightseal-canonical {
  margin: 0;
  font-family: var(--boot-font-body, "Segoe UI", sans-serif);
  font-size: var(--boot-font-body-small-size, 12px);
  line-height: var(--boot-font-body-small-line-height, 1.4);
  color: rgba(185, 211, 226, 0.84);
}

.slide00-rightseal-progress {
  height: 6px;
  border-radius: 999px;
  background: rgba(120, 170, 196, 0.24);
  overflow: hidden;
}

.slide00-rightseal-progress-fill {
  width: 100%;
  height: 100%;
  display: block;
  transform-origin: left center;
  background: linear-gradient(90deg, rgba(70, 220, 255, 0.64), rgba(91, 247, 198, 0.82));
  transition: transform 220ms ease;
}

.slide00-rightseal[data-sealed="true"] {
  padding: 10px 11px;
  border-radius: 12px;
  border-color: rgba(91, 247, 198, 0.58);
  background:
    radial-gradient(220px 140px at 16% 0%, rgba(91, 247, 198, 0.2), rgba(0, 0, 0, 0) 72%),
    linear-gradient(180deg, rgba(4, 35, 28, 0.9), rgba(3, 22, 17, 0.92));
}

.slide00-rightseal[data-sealed="true"] .slide00-rightseal-state {
  font-size: 16px;
}

.slide00-rightseal[data-sealed="true"] .slide00-rightseal-hint {
  display: none;
}

.slide00-rightseal[data-sealed="true"] .slide00-rightseal-canonical {
  color: rgba(201, 255, 234, 0.92);
}

@media (max-width: 980px) {
  .slide00-firstproof-gesture-zone {
    min-height: 188px;
  }
}
```

===== NEW FILE: components/slides/slide00-ui/first-proof/index.ts =====
`$ext
export * from "./FirstProofRitual";
export * from "./FirstProofRail";
export * from "./RightSeal";
export * from "./LayerStackDemo";
export * from "./useFirstProofRitual";
export * from "./firstProof.types";
export * from "./firstProof.helpers";
export * from "./firstProof.copy";
```

===== NEW FILE: components/slides/slide00-ui/first-proof/__tests__/firstProof.helpers.test.ts =====
`$ext
import { strict as assert } from "node:assert";
import {
  createInitialFirstProofState,
  resolveFirstProofThresholds,
  transitionFirstProofState,
} from "../firstProof.helpers";
import { FirstProofState } from "../firstProof.types";

const TEST_THRESHOLDS = resolveFirstProofThresholds({
  dragThresholdPx: 100,
  maxDragTravelPx: 280,
  holdTravelThresholdPx: 80,
  holdGain: 1,
  releaseSnapPx: 140,
});

function down(state: FirstProofState, pointerId: number, x: number, y: number) {
  return transitionFirstProofState(
    state,
    { type: "pointer_down", pointerId, x, y },
    TEST_THRESHOLDS
  );
}

function move(state: FirstProofState, pointerId: number, x: number, y: number) {
  return transitionFirstProofState(
    state,
    { type: "pointer_move", pointerId, x, y },
    TEST_THRESHOLDS
  );
}

function up(state: FirstProofState, pointerId: number, x: number, y: number) {
  return transitionFirstProofState(
    state,
    { type: "pointer_up", pointerId, x, y },
    TEST_THRESHOLDS
  );
}

function test_drag_threshold_boundary() {
  let state = createInitialFirstProofState(TEST_THRESHOLDS);
  state = down(state, 1, 0, 0).state;

  let result = move(state, 1, 99, 0);
  assert.equal(result.state.stage, "Idle");
  assert.equal(result.events.length, 0);

  result = move(result.state, 1, 100, 0);
  assert.equal(result.state.stage, "Dragged");
  assert.equal(result.events.length, 1);
  assert.equal(result.events[0].anchorId, "slide00:firstproof:drag-threshold");
}

function test_hold_threshold_boundary() {
  let state = createInitialFirstProofState(TEST_THRESHOLDS);
  state = down(state, 11, 0, 0).state;
  state = move(state, 11, 100, 0).state;

  let result = move(state, 11, 120, 0);
  assert.equal(result.state.stage, "Dragged");
  assert.equal(result.state.holdProgress < 1, true);

  result = move(result.state, 11, 180, 0);
  assert.equal(result.state.stage, "Holding");
  assert.equal(result.state.holdProgress, 1);
  assert.equal(result.events.length, 1);
  assert.equal(result.events[0].anchorId, "slide00:firstproof:hold-threshold");
}

function test_release_transition_validity() {
  let state = createInitialFirstProofState(TEST_THRESHOLDS);
  state = down(state, 2, 0, 0).state;
  state = move(state, 2, 100, 0).state;

  const earlyRelease = up(state, 2, 100, 0);
  assert.equal(earlyRelease.state.stage, "Dragged");
  assert.equal(earlyRelease.events.length, 0);

  state = down(earlyRelease.state, 2, 100, 0).state;
  state = move(state, 2, 120, 0).state;
  const holding = move(state, 2, 180, 0);
  assert.equal(holding.state.stage, "Holding");

  const sealed = up(holding.state, 2, 180, 0);
  assert.equal(sealed.state.stage, "Sealed");
  assert.equal(sealed.events.length, 1);
  assert.equal(sealed.events[0].anchorId, "slide00:firstproof:sealed");
}

function test_idempotence_same_input_same_output() {
  let state = createInitialFirstProofState(TEST_THRESHOLDS);
  state = down(state, 7, 0, 0).state;

  const first = move(state, 7, 40, 0);
  const second = move(first.state, 7, 40, 0);

  assert.deepEqual(second.state, first.state);
  assert.equal(second.events.length, 0);

  const ignored = move(second.state, 9, 120, 0);
  assert.deepEqual(ignored.state, second.state);
  assert.equal(ignored.events.length, 0);
}

export function runFirstProofHelperSpecs() {
  test_drag_threshold_boundary();
  test_hold_threshold_boundary();
  test_release_transition_validity();
  test_idempotence_same_input_same_output();
}
```

===== NEW FILE: tests/e2e/slide00-firstproof.e2e.spec.ts =====
`$ext
import { expect, test } from "@playwright/test";
import { readdirSync, readFileSync, statSync } from "node:fs";
import path from "node:path";

function collectDomainFiles(rootDir: string): string[] {
  const stack = [rootDir];
  const files: string[] = [];

  while (stack.length > 0) {
    const current = stack.pop() as string;
    for (const entry of readdirSync(current)) {
      const fullPath = path.join(current, entry);
      const stats = statSync(fullPath);
      if (stats.isDirectory()) {
        stack.push(fullPath);
        continue;
      }
      if (!/\.(ts|tsx|css)$/.test(entry)) continue;
      files.push(fullPath);
    }
  }

  files.sort((a, b) => a.localeCompare(b, "en", { sensitivity: "base" }));
  return files;
}

function assertTimerFreeFirstProofDomain() {
  const domainRoot = path.join(
    process.cwd(),
    "components",
    "slides",
    "slide00-ui",
    "first-proof"
  );

  const files = collectDomainFiles(domainRoot);
  expect(files.length).toBeGreaterThan(0);

  for (const filePath of files) {
    const content = readFileSync(filePath, "utf8");
    expect(content).not.toMatch(/\bsetTimeout\s*\(/);
    expect(content).not.toMatch(/\bsetInterval\s*\(/);
    expect(content).not.toMatch(/\brequestAnimationFrame\s*\(/);
  }
}

test("Slide00 First Proof ritual seals deterministically with drag hold release", async ({ page }) => {
  await page.goto("/");

  await expect(page.getByTestId("slide00-firstproof-root")).toBeVisible();
  await expect(page.getByTestId("slide00-firstproof-step-drag")).toBeVisible();
  await expect(page.getByTestId("slide00-firstproof-step-hold")).toBeVisible();
  await expect(page.getByTestId("slide00-firstproof-step-release")).toBeVisible();
  await expect(page.getByTestId("slide00-rightseal-state")).toContainText("Ejecución incompleta");

  const dragSurface = page.getByTestId("slide00-firstproof-gesture-drag");
  await expect(dragSurface).toBeVisible();
  await expect(page.getByTestId("slide00-firstproof-gesture-hold")).toBeVisible();
  await expect(page.getByTestId("slide00-firstproof-gesture-release")).toBeVisible();

  const box = await dragSurface.boundingBox();
  expect(box).not.toBeNull();
  if (!box) return;

  const startX = box.x + 38;
  const startY = box.y + box.height * 0.5;

  await page.mouse.move(startX, startY);
  await page.mouse.down();
  await page.mouse.move(startX + 196, startY, { steps: 14 });
  await page.mouse.move(startX + 230, startY + 88, { steps: 10 });
  await page.mouse.move(startX + 28, startY + 88, { steps: 14 });
  await page.mouse.move(startX + 210, startY + 24, { steps: 12 });
  await page.mouse.up();

  await expect(page.getByTestId("slide00-rightseal")).toHaveAttribute("data-sealed", "true");
  await expect(page.getByTestId("slide00-rightseal-state")).toContainText("Sistema sellado");
  await expect(page.getByTestId("slide00-rightseal")).toContainText(
    "Fue diseñado para ser posible… hoy, mañana y cuando tú ya no estés aquí operándolo."
  );

  assertTimerFreeFirstProofDomain();
});
```

4) Full contents of MODIFIED files (only the files changed in this iteration)
===== MODIFIED FILE: components/slides/Slide00.tsx =====
`$ext
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Header, NavArea, SlideContainer } from "../SlideRenderer";
import {
  OPERATOR_DIAGNOSTICS,
  WOW_DEMO_SCRIPT,
  WOW_MIRROR,
  WOW_OPENING_CINEMA,
  WOW_TOUR,
  WOW_TOUR_AUTOSTART,
} from "../../config/wow";
import { useBootRuntime } from "../../runtime/boot/BootRuntimeContext";
import {
  BootFoot,
  BootNote,
  BootPanel,
  BootPanelBody,
  BootPanelFooter,
  BootPanelHeader,
  BootSideColumn,
  BootStatusBadge,
  BootToast,
  BootTopline,
  DiagnosticsDock,
  DiagnosticsDockToggle,
  EvidenceList,
  FirstProofCanonicalProfile,
  FirstProofRitual,
  FirstProofSnapshot,
  GateMatrix,
  OpeningFlagsBadge,
  PersistenceIndicator,
  RightSeal,
  ResetControls,
  Slide00HiddenState,
  Slide00Shell,
  ViewControlsTogglePanel,
  buildEvidenceRows,
  buildEvidenceStatusCards,
  buildGateRows,
  clearSystemStorageKeys,
  collectSystemStorageKeys,
  createInitialFirstProofState,
  deriveFirstProofSnapshot,
  formatDateTime,
  formatTimestamp,
  humanReason,
  useSlide00ViewVisibility,
} from "./slide00-ui";
import { CopyBoundary, useCopy } from "./slide00-ui/copy";
import {
  FitDiagnosticsOverlay,
  PowerConsoleFrame,
  PowerConsoleGrid,
  PowerConsoleSection,
  SideDockScrollRegion,
  useDensityPreset,
  useViewportMetrics,
} from "./slide00-ui/layout";
import { FirstActionModel, FirstActionsRail, StatusStrip, StatusStripItem } from "./slide00-ui/interactions";
import { TokenBridge } from "./slide00-ui/tokens/TokenBridge";
import { BootStatusChip, ConfirmSlotState } from "./slide00-ui/types";
import "./Slide00.boot.css";

const SHOW_FIT_DIAGNOSTICS = false;

type Slide00Props = {
  nextSlide: () => void;
  prevSlide: () => void;
};

export const Slide00: React.FC<Slide00Props> = (props) => {
  return (
    <CopyBoundary>
      <Slide00Content {...props} />
    </CopyBoundary>
  );
};

type PersistenceState = {
  hasSnapshot: boolean;
  keys: string[];
};

function readPersistenceState(): PersistenceState {
  if (typeof window === "undefined") {
    return { hasSnapshot: false, keys: [] };
  }

  const keys = collectSystemStorageKeys(window.localStorage);
  return {
    hasSnapshot: keys.includes("hitech.boot.snapshot.v1"),
    keys,
  };
}

const Slide00Content: React.FC<Slide00Props> = ({ nextSlide, prevSlide }) => {
  const boot = useBootRuntime();
  const viewVisibility = useSlide00ViewVisibility();
  const { t } = useCopy();
  const firstProofProfile: FirstProofCanonicalProfile = "legacy";
  const [showToast, setShowToast] = useState(false);
  const [toastDetail, setToastDetail] = useState(() => t("slide00.toast.title"));
  const [diagnosticsOpen, setDiagnosticsOpen] = useState(false);
  const [diagnosticsCompact, setDiagnosticsCompact] = useState(false);
  const [demoScriptActive, setDemoScriptActive] = useState(false);
  const [mirrorActive, setMirrorActive] = useState(false);
  const [persistence, setPersistence] = useState<PersistenceState>(() => readPersistenceState());
  const [firstProofSnapshot, setFirstProofSnapshot] = useState<FirstProofSnapshot>(() =>
    deriveFirstProofSnapshot(createInitialFirstProofState())
  );
  const [actionFeedback, setActionFeedback] = useState<Record<string, string>>({});
  const lastToastLogIdRef = useRef<string | null>(null);
  const viewportMetrics = useViewportMetrics();
  const densityPreset = useDensityPreset(viewportMetrics);

  const refreshPersistence = useCallback(() => {
    setPersistence(readPersistenceState());
  }, []);

  const onFirstProofSnapshotChange = useCallback((snapshot: FirstProofSnapshot) => {
    setFirstProofSnapshot(snapshot);
  }, []);

  const evidenceRows = useMemo(() => buildEvidenceRows(boot), [boot.state.evidence]);
  const blockerRows = useMemo(
    () => evidenceRows.filter((row) => row.blocker),
    [evidenceRows]
  );
  const gateRows = useMemo(() => buildGateRows(boot), [boot.gates]);

  const kpiCards = useMemo(
    () =>
      buildEvidenceStatusCards({
        gateLocked: boot.gateLocked,
        armed: boot.isArmed,
        operatorAssisted: boot.isOperatorAssisted,
        missingBlockers: boot.diagnostics.evidenceSummary.blockersMissing,
        satisfiedBlockers: boot.diagnostics.evidenceSummary.blockersSatisfied,
        labels: {
          gateKey: t("slide00.kpi.gate"),
          blockersKey: t("slide00.kpi.blockers"),
          pathKey: t("slide00.kpi.path"),
          gateLockedValue: t("slide00.kpi.gate.locked"),
          gateOpenValue: t("slide00.kpi.gate.open"),
          pathEvidenceValue: t("slide00.kpi.path.evidence"),
          pathAssistedValue: t("slide00.kpi.path.assisted"),
          pathStrictValue: t("slide00.kpi.path.strict"),
        },
      }),
    [boot.gateLocked, boot.isArmed, boot.isOperatorAssisted, boot.diagnostics.evidenceSummary, t]
  );

  const confirmSlot = useMemo(
    () => {
      if (boot.isArmed) {
        return {
          state: "armed" as ConfirmSlotState,
          text: t("slide00.confirm.prefix"),
          strongText: t("slide00.confirm.armed"),
        };
      }

      if (boot.state.boot.status === "ARMED_PENDING_CONFIRM") {
        return {
          state: "pending" as ConfirmSlotState,
          text: t("slide00.confirm.prefix"),
          strongText: t("slide00.confirm.pending"),
        };
      }

      return {
        state: "empty" as ConfirmSlotState,
        text: t("slide00.confirm.empty"),
      };
    },
    [boot.state.boot.status, boot.isArmed, t]
  );

  const showConfirmButton =
    boot.state.boot.status === "ARMED_PENDING_CONFIRM" ||
    (boot.state.boot.status === "OPERATOR_ASSISTED" && !boot.isArmed);

  const confirmLabel =
    boot.state.boot.status === "OPERATOR_ASSISTED" && !boot.isArmed
      ? t("slide00.panel.confirmOverrideButton")
      : t("slide00.panel.confirmButton");

  const canConfirm =
    boot.state.boot.status === "ARMED_PENDING_CONFIRM" ? boot.canConfirm : true;

  useEffect(() => {
    const lastLog = boot.state.operatorLog[boot.state.operatorLog.length - 1];
    if (!lastLog) return;
    if (lastLog.action !== "boot:arm:confirmed") return;
    if (lastToastLogIdRef.current === lastLog.id) return;

    lastToastLogIdRef.current = lastLog.id;
    setToastDetail(lastLog.title);
    setShowToast(true);
  }, [boot.state.operatorLog]);

  useEffect(() => {
    refreshPersistence();
  }, [boot.state, refreshPersistence]);

  useEffect(() => {
    if (viewVisibility.showDiagnostics) return;
    setDiagnosticsOpen(false);
  }, [viewVisibility.showDiagnostics]);

  const armNow = useCallback(() => {
    boot.recordAnchorInteraction("slide00:arm-system", "Primary arm button clicked");
    if (!boot.canArm) return;
    boot.requestArm();
  }, [boot]);

  const confirmArm = useCallback(() => {
    boot.recordAnchorInteraction("slide00:confirm-arm", "Arm confirmation clicked");
    if (boot.state.boot.status === "ARMED_PENDING_CONFIRM" && !boot.canConfirm) return;
    boot.confirmArm();
  }, [boot]);

  const toggleOverride = useCallback(() => {
    boot.recordAnchorInteraction("slide00:override-toggle", "Operator override toggled");
    boot.setOverride(!boot.state.boot.overrideEnabled);
  }, [boot]);

  const softReset = useCallback(() => {
    boot.recordAnchorInteraction("slide00:soft-reset", "Operator soft reset requested");
    boot.resetLocal();
    setShowToast(false);
    refreshPersistence();
  }, [boot, refreshPersistence]);

  const hardReset = useCallback(() => {
    boot.recordAnchorInteraction("slide00:hard-reset", "Operator hard reset requested");
    boot.resetLocal();

    if (typeof window !== "undefined") {
      const cleared = clearSystemStorageKeys(window.localStorage);
      boot.appendOperatorLog({
        level: "warning",
        title: "Hard reset completed",
        detail: `Cleared ${cleared} local storage key(s).`,
        action: "boot:reset:hard",
      });
    }

    setShowToast(false);
    refreshPersistence();
  }, [boot, refreshPersistence]);

  const copySnapshot = useCallback(async () => {
    boot.recordAnchorInteraction("slide00:snapshot-copy", "Operator requested snapshot copy");
    const copied = await boot.copySnapshotToClipboard();

    boot.appendOperatorLog({
      level: copied ? "success" : "warning",
      title: copied ? "Snapshot copied" : "Snapshot copy unavailable",
      detail: copied
        ? "Snapshot JSON copied to clipboard."
        : "Clipboard API unavailable. Use download snapshot.",
      action: copied ? "boot:snapshot:copied" : "boot:snapshot:copy:failed",
    });

    return copied;
  }, [boot]);

  const downloadSnapshot = useCallback(() => {
    boot.recordAnchorInteraction(
      "slide00:snapshot-download",
      "Operator requested snapshot download"
    );
    const downloaded = boot.downloadSnapshot("boot-snapshot.json");

    boot.appendOperatorLog({
      level: downloaded ? "success" : "warning",
      title: downloaded ? "Snapshot downloaded" : "Snapshot download unavailable",
      detail: downloaded
        ? "Snapshot file was generated locally."
        : "Download API unavailable in this environment.",
      action: downloaded ? "boot:snapshot:downloaded" : "boot:snapshot:download:failed",
    });

    return downloaded;
  }, [boot]);

  const toggleDemoScript = useCallback(() => {
    const next = !demoScriptActive;
    setDemoScriptActive(next);
    boot.recordAnchorInteraction(
      "slide00:toggle-demo-script",
      `Demo script toggled ${next ? "on" : "off"}`
    );
    window.dispatchEvent(
      new CustomEvent("wow:demo-script-toggle", { detail: { enabled: next } })
    );
  }, [boot, demoScriptActive]);

  const toggleMirror = useCallback(() => {
    const next = !mirrorActive;
    setMirrorActive(next);
    boot.recordAnchorInteraction(
      "slide00:toggle-mirror",
      `Mirror intro toggled ${next ? "on" : "off"}`
    );
    window.dispatchEvent(new CustomEvent("wow:mirror-toggle", { detail: { enabled: next } }));
  }, [boot, mirrorActive]);

  const diagnosticsMeta = useMemo(
    () => [
      {
        key: "state",
        label: t("slide00.diagnostics.meta.state"),
        value: boot.state.boot.status,
        testId: "boot-state-value",
      },
      {
        key: "gate",
        label: t("slide00.diagnostics.meta.gate"),
        value: boot.gateLocked ? t("slide00.kpi.gate.locked") : t("slide00.kpi.gate.open"),
      },
      {
        key: "event",
        label: t("slide00.diagnostics.meta.event"),
        value: boot.diagnostics.lastEvent
          ? `${boot.diagnostics.lastEvent.id} · ${boot.diagnostics.lastEvent.action}`
          : t("slide00.diagnostics.meta.none"),
      },
      {
        key: "anchor",
        label: t("slide00.diagnostics.meta.anchor"),
        value: boot.diagnostics.lastInteractedAnchor ?? t("slide00.diagnostics.meta.none"),
      },
    ],
    [boot.state.boot.status, boot.gateLocked, boot.diagnostics.lastEvent, boot.diagnostics.lastInteractedAnchor, t]
  );

  const diagnosticsControls = useMemo(
    () => [
      {
        key: "override",
        copy: t("slide00.diagnostics.controls.override.copy"),
        actions: [
          {
            key: "toggle",
            label: boot.state.boot.overrideEnabled
              ? t("slide00.diagnostics.controls.override.on")
              : t("slide00.diagnostics.controls.override.off"),
            active: boot.state.boot.overrideEnabled,
            onClick: toggleOverride,
            testId: "operator-override-toggle",
          },
        ],
      },
      {
        key: "reset",
        copy: t("slide00.diagnostics.controls.reset.copy"),
        actions: [
          {
            key: "soft-reset",
            label: t("slide00.diagnostics.controls.reset.button"),
            onClick: softReset,
            testId: "operator-reset-local",
          },
        ],
      },
      {
        key: "snapshot",
        copy: t("slide00.diagnostics.controls.snapshot.copy"),
        actions: [
          {
            key: "copy",
            label: t("slide00.diagnostics.controls.snapshot.copyButton"),
            onClick: copySnapshot,
            testId: "operator-copy-snapshot",
          },
          {
            key: "download",
            label: t("slide00.diagnostics.controls.snapshot.downloadButton"),
            onClick: downloadSnapshot,
            testId: "operator-download-snapshot",
          },
        ],
      },
      {
        key: "demo-script",
        copy: t("slide00.diagnostics.controls.demo.copy"),
        actions: [
          {
            key: "demo",
            label: demoScriptActive
              ? t("slide00.diagnostics.controls.demo.on")
              : t("slide00.diagnostics.controls.demo.off"),
            active: demoScriptActive,
            onClick: toggleDemoScript,
          },
        ],
      },
      {
        key: "mirror",
        copy: t("slide00.diagnostics.controls.mirror.copy"),
        actions: [
          {
            key: "mirror",
            label: mirrorActive
              ? t("slide00.diagnostics.controls.mirror.on")
              : t("slide00.diagnostics.controls.mirror.off"),
            active: mirrorActive,
            onClick: toggleMirror,
          },
        ],
      },
    ],
    [
      boot.state.boot.overrideEnabled,
      copySnapshot,
      demoScriptActive,
      downloadSnapshot,
      mirrorActive,
      softReset,
      toggleDemoScript,
      toggleMirror,
      toggleOverride,
      t,
    ]
  );

  const diagnosticsLogRows = useMemo(
    () =>
      boot.state.operatorLog
        .slice(-8)
        .reverse()
        .map((entry) => ({
          id: entry.id,
          head: `${entry.action} · ${formatTimestamp(entry.ts)}`,
          body: `${entry.title} - ${entry.detail}`,
        })),
    [boot.state.operatorLog]
  );

  const lastEventLabel = boot.diagnostics.lastEvent
    ? `${boot.diagnostics.lastEvent.id} · ${boot.diagnostics.lastEvent.action}`
    : t("slide00.diagnostics.meta.none");

  const cinematicFlagSummary = [
    WOW_TOUR ? "tour" : null,
    WOW_TOUR_AUTOSTART ? "tour_autostart" : null,
    WOW_DEMO_SCRIPT ? "demo_script" : null,
    WOW_OPENING_CINEMA ? "opening_cinema" : null,
    WOW_MIRROR ? "mirror" : null,
  ]
    .filter(Boolean)
    .join(", ");

  const status = useMemo(() => {
    if (boot.state.boot.status === "IDLE") return t("slide00.statusLabel.IDLE");
    if (boot.state.boot.status === "ARMED_PENDING_CONFIRM") return t("slide00.statusLabel.ARMED_PENDING_CONFIRM");
    if (boot.state.boot.status === "ARMED_CONFIRMED") return t("slide00.statusLabel.ARMED_CONFIRMED");
    if (boot.state.boot.status === "OPERATOR_ASSISTED") return t("slide00.statusLabel.OPERATOR_ASSISTED");
    return boot.state.boot.status;
  }, [boot.state.boot.status, t]);

  const statusNarrativeLabel = useMemo(() => {
    if (boot.state.boot.status === "IDLE") return t("slide00.statusNarrative.IDLE");
    if (boot.state.boot.status === "ARMED_PENDING_CONFIRM") return t("slide00.statusNarrative.ARMED_PENDING_CONFIRM");
    if (boot.state.boot.status === "ARMED_CONFIRMED") return t("slide00.statusNarrative.ARMED_CONFIRMED");
    if (boot.state.boot.status === "OPERATOR_ASSISTED") return t("slide00.statusNarrative.OPERATOR_ASSISTED");
    return t("slide00.statusNarrative.UNKNOWN");
  }, [boot.state.boot.status, t]);

  const diagnosticsSurfaceVisible = viewVisibility.showDiagnostics && OPERATOR_DIAGNOSTICS;
  const stateChips = useMemo<BootStatusChip[]>(
    () => [
      { id: "IDLE", label: t("slide00.stateChip.idle"), variant: "danger" },
      { id: "ARMED_PENDING_CONFIRM", label: t("slide00.stateChip.pending"), variant: "warning" },
      { id: "ARMED_CONFIRMED", label: t("slide00.stateChip.armed"), variant: "default" },
      { id: "OPERATOR_ASSISTED", label: t("slide00.stateChip.assisted"), variant: "warning" },
    ],
    [t]
  );

  const addActionFeedback = useCallback((actionId: string, message: string) => {
    setActionFeedback((prev) => ({
      ...prev,
      [actionId]: `${message} · ${formatTimestamp(Date.now())}`,
    }));
  }, []);

  const runFirstAction = useCallback(
    async (
      actionId: string,
      label: string,
      enabled: boolean,
      action: () => void | Promise<boolean>
    ) => {
      if (!enabled) {
        addActionFeedback(actionId, t("slide00.actionFeedback.blocked", { label }));
        return;
      }

      const result = await action();
      if (result === false) {
        addActionFeedback(actionId, t("slide00.actionFeedback.unavailable", { label }));
        return;
      }

      addActionFeedback(actionId, t("slide00.actionFeedback.executed", { label }));
    },
    [addActionFeedback, t]
  );

  const statusTone =
    boot.state.boot.status === "ARMED_CONFIRMED"
      ? "good"
      : boot.state.boot.status === "ARMED_PENDING_CONFIRM"
        ? "warn"
        : boot.state.boot.status === "OPERATOR_ASSISTED"
          ? "warn"
          : "danger";

  const statusItems = useMemo<StatusStripItem[]>(
    () => [
      {
        key: "state",
        label: t("slide00.statusStrip.state"),
        value: status,
        tone: statusTone,
      },
      {
        key: "gate",
        label: t("slide00.statusStrip.gate"),
        value: boot.gateLocked ? t("slide00.kpi.gate.locked") : t("slide00.kpi.gate.open"),
        tone: boot.gateLocked ? "danger" : "good",
      },
      {
        key: "path",
        label: t("slide00.statusStrip.path"),
        value: boot.isArmed
          ? t("slide00.kpi.path.evidence")
          : boot.isOperatorAssisted
            ? t("slide00.kpi.path.assisted")
            : t("slide00.kpi.path.strict"),
        tone: boot.isArmed ? "good" : boot.isOperatorAssisted ? "warn" : "neutral",
      },
      {
        key: "blockers",
        label: t("slide00.statusStrip.blockers"),
        value: `${boot.diagnostics.evidenceSummary.blockersSatisfied}/${
          boot.diagnostics.evidenceSummary.blockersSatisfied +
          boot.diagnostics.evidenceSummary.blockersMissing
        }`,
        tone: boot.diagnostics.evidenceSummary.blockersMissing > 0 ? "warn" : "good",
      },
    ],
    [
      boot.gateLocked,
      boot.isArmed,
      boot.isOperatorAssisted,
      boot.diagnostics.evidenceSummary.blockersSatisfied,
      boot.diagnostics.evidenceSummary.blockersMissing,
      status,
      statusTone,
      t,
    ]
  );

  const firstActions = useMemo<FirstActionModel[]>(
    () => [
      {
        id: "arm",
        title: t("slide00.firstActions.action.arm.title"),
        description: t("slide00.firstActions.action.arm.description"),
        badge: boot.canArm ? t("slide00.firstActions.badge.ready") : t("slide00.firstActions.badge.blocked"),
        badgeTone: boot.canArm ? "good" : "warn",
        enabled: boot.canArm,
        feedback: actionFeedback.arm,
        onClick: () => {
          void runFirstAction("arm", t("slide00.firstActions.action.arm.confirm"), boot.canArm, () => {
            armNow();
          });
        },
        testId: "first-action-arm",
      },
      {
        id: "confirm",
        title: t("slide00.firstActions.action.confirm.title"),
        description: t("slide00.firstActions.action.confirm.description"),
        badge: canConfirm && showConfirmButton
          ? t("slide00.firstActions.badge.ready")
          : t("slide00.firstActions.badge.blocked"),
        badgeTone: canConfirm && showConfirmButton ? "good" : "warn",
        enabled: canConfirm && showConfirmButton,
        feedback: actionFeedback.confirm,
        onClick: () => {
          void runFirstAction(
            "confirm",
            t("slide00.firstActions.action.confirm.confirm"),
            canConfirm && showConfirmButton,
            () => {
              confirmArm();
            }
          );
        },
        testId: "first-action-confirm",
      },
      {
        id: "override",
        title: t("slide00.firstActions.action.override.title"),
        description: t("slide00.firstActions.action.override.description"),
        badge: t("slide00.firstActions.badge.ready"),
        badgeTone: boot.state.boot.overrideEnabled ? "warn" : "neutral",
        enabled: true,
        feedback: actionFeedback.override,
        onClick: () => {
          void runFirstAction("override", t("slide00.firstActions.action.override.confirm"), true, () => {
            toggleOverride();
          });
        },
        testId: "first-action-override",
      },
      {
        id: "diagnostics",
        title: t("slide00.firstActions.action.diagnostics.title"),
        description: t("slide00.firstActions.action.diagnostics.description"),
        badge: diagnosticsSurfaceVisible ? t("slide00.firstActions.badge.ready") : t("slide00.firstActions.badge.blocked"),
        badgeTone: diagnosticsSurfaceVisible ? "good" : "danger",
        enabled: diagnosticsSurfaceVisible,
        feedback: actionFeedback.diagnostics,
        onClick: () => {
          void runFirstAction(
            "diagnostics",
            t("slide00.firstActions.action.diagnostics.confirm"),
            diagnosticsSurfaceVisible,
            () => {
              setDiagnosticsOpen(true);
            }
          );
        },
        testId: "first-action-diagnostics",
      },
      {
        id: "hud",
        title: t("slide00.firstActions.action.hud.title"),
        description: t("slide00.firstActions.action.hud.description"),
        badge: viewVisibility.showTopHudRow
          ? t("slide00.firstActions.badge.executed")
          : t("slide00.firstActions.badge.ready"),
        badgeTone: viewVisibility.showTopHudRow ? "good" : "neutral",
        enabled: true,
        feedback: actionFeedback.hud,
        onClick: () => {
          void runFirstAction("hud", t("slide00.firstActions.action.hud.confirm"), true, () => {
            viewVisibility.setShowTopHudRow(!viewVisibility.showTopHudRow);
          });
        },
        testId: "first-action-hud",
      },
      {
        id: "reset",
        title: t("slide00.firstActions.action.reset.title"),
        description: t("slide00.firstActions.action.reset.description"),
        badge: t("slide00.firstActions.badge.ready"),
        badgeTone: "warn",
        enabled: true,
        feedback: actionFeedback.reset,
        onClick: () => {
          void runFirstAction("reset", t("slide00.firstActions.action.reset.confirm"), true, () => {
            softReset();
          });
        },
        testId: "first-action-reset",
      },
      {
        id: "snapshot-copy",
        title: t("slide00.firstActions.action.snapshotCopy.title"),
        description: t("slide00.firstActions.action.snapshotCopy.description"),
        badge: t("slide00.firstActions.badge.ready"),
        badgeTone: "neutral",
        enabled: true,
        feedback: actionFeedback["snapshot-copy"],
        onClick: () => {
          void runFirstAction(
            "snapshot-copy",
            t("slide00.firstActions.action.snapshotCopy.confirm"),
            true,
            () => copySnapshot()
          );
        },
        testId: "first-action-snapshot-copy",
      },
      {
        id: "snapshot-download",
        title: t("slide00.firstActions.action.snapshotDownload.title"),
        description: t("slide00.firstActions.action.snapshotDownload.description"),
        badge: t("slide00.firstActions.badge.ready"),
        badgeTone: "neutral",
        enabled: true,
        feedback: actionFeedback["snapshot-download"],
        onClick: () => {
          void runFirstAction(
            "snapshot-download",
            t("slide00.firstActions.action.snapshotDownload.confirm"),
            true,
            () => downloadSnapshot()
          );
        },
        testId: "first-action-snapshot-download",
      },
    ],
    [
      actionFeedback,
      armNow,
      boot.canArm,
      boot.state.boot.overrideEnabled,
      canConfirm,
      confirmArm,
      copySnapshot,
      diagnosticsSurfaceVisible,
      downloadSnapshot,
      runFirstAction,
      showConfirmButton,
      softReset,
      t,
      toggleOverride,
      viewVisibility,
    ]
  );

  return (
    <SlideContainer>
      <TokenBridge
        preset={densityPreset.preset}
        width={viewportMetrics.viewportWidth}
        height={viewportMetrics.viewportHeight}
        scaleX={viewportMetrics.scaleX}
        scaleY={viewportMetrics.scaleY}
        compactViewport={viewportMetrics.compactViewport}
        className="slide00-token-bridge"
      >
        <PowerConsoleFrame preset={densityPreset.preset} metrics={viewportMetrics}>
          <Slide00Shell
            nav={<NavArea prev={prevSlide} next={nextSlide} />}
            toast={
              <BootToast
                open={showToast}
                detail={toastDetail}
                onDismiss={() => setShowToast(false)}
                title={t("slide00.toast.title")}
                dismissLabel={t("slide00.toast.dismiss")}
              />
            }
            diagnostics={
              diagnosticsSurfaceVisible ? (
                <>
                  <DiagnosticsDockToggle
                    open={diagnosticsOpen}
                    onClick={() => setDiagnosticsOpen((prev) => !prev)}
                    openLabel={t("slide00.diagnostics.toggle.open")}
                    closedLabel={t("slide00.diagnostics.toggle.closed")}
                  />
                  <DiagnosticsDock
                    open={diagnosticsOpen}
                    compact={diagnosticsCompact}
                    onBack={() => setDiagnosticsOpen(false)}
                    onToggleMode={() => setDiagnosticsCompact((prev) => !prev)}
                    metaItems={diagnosticsMeta}
                    controlRows={diagnosticsControls}
                    satisfiedRows={boot.diagnostics.satisfiedEvidence}
                    missingRows={boot.diagnostics.missingBlockers}
                    logRows={diagnosticsLogRows}
                    footerCopy={t("slide00.diagnostics.footer.copy")}
                    footerTime={t("slide00.diagnostics.footer.time", { time: new Date().toLocaleString() })}
                    title={t("slide00.diagnostics.title")}
                    modeCompactLabel={t("slide00.diagnostics.mode.compact")}
                    modeDockedLabel={t("slide00.diagnostics.mode.docked")}
                    backLabel={t("slide00.diagnostics.back")}
                    satisfiedTitle={t("slide00.diagnostics.section.satisfied")}
                    missingTitle={t("slide00.diagnostics.section.missing")}
                    logTitle={t("slide00.diagnostics.section.log")}
                    noneLabel={t("slide00.diagnostics.none")}
                    logEmptyLabel={t("slide00.diagnostics.log.empty")}
                  />
                </>
              ) : null
            }
          >
            <BootTopline
              brandTitle={t("slide00.topline.brandTitle")}
              brandSubtitle={t("slide00.topline.brandSubtitle")}
              slideLabel={t("slide00.topline.slideLabel")}
            />

            <Header
              title={t("slide00.header.title")}
              breadcrumb={t("slide00.header.breadcrumb")}
              slideNum={1}
              rightBadge={t("slide00.header.rightBadge", { status })}
            />

            <PowerConsoleGrid
              main={
                <>
                  <PowerConsoleSection className="slide00-power-console-section--firstproof">
                    <FirstProofRitual
                      recordAnchorInteraction={boot.recordAnchorInteraction}
                      profile={firstProofProfile}
                      showInlineRightSeal={false}
                      onSnapshotChange={onFirstProofSnapshotChange}
                    />
                  </PowerConsoleSection>

                  <BootPanel
                    header={
                      <BootPanelHeader
                        title={t("slide00.panel.title")}
                        subtitle={
                          <>
                            {t("slide00.panel.subtitle.start")} <strong>{t("slide00.panel.subtitle.armed")}</strong>{" "}
                            {t("slide00.panel.subtitle.end")}
                          </>
                        }
                        whyLabel={t("slide00.panel.why")}
                      />
                    }
                    body={
                      <BootPanelBody
                        status={boot.state.boot.status}
                        armLabel={t("slide00.panel.armButton")}
                        canArm={boot.canArm}
                        canConfirm={canConfirm}
                        showConfirm={showConfirmButton}
                        confirmLabel={confirmLabel}
                        onArm={armNow}
                        onConfirm={confirmArm}
                        confirmState={confirmSlot.state}
                        confirmText={confirmSlot.text}
                        confirmStrongText={confirmSlot.strongText}
                        cards={kpiCards}
                        stateChips={stateChips}
                      />
                    }
                    footer={
                      <BootPanelFooter>
                        <p className="slide00-arm-emphasis-copy">{t("slide00.panel.emphasis")}</p>
                      </BootPanelFooter>
                    }
                  />
                </>
              }
              side={
                <PowerConsoleSection className="slide00-power-console-section--side">
                  <SideDockScrollRegion maxHeight={viewportMetrics.sideScrollHeight}>
                    <BootSideColumn>
                      <RightSeal snapshot={firstProofSnapshot} profile={firstProofProfile} />

                      <ViewControlsTogglePanel
                        showTopHudRow={viewVisibility.showTopHudRow}
                        showTopRibbon={viewVisibility.showTopRibbon}
                        showDiagnostics={viewVisibility.showDiagnostics}
                        onTopHudRowChange={viewVisibility.setShowTopHudRow}
                        onTopRibbonChange={viewVisibility.setShowTopRibbon}
                        onDiagnosticsChange={viewVisibility.setShowDiagnostics}
                        title={t("slide00.viewControls.title")}
                        copy={t("slide00.viewControls.copy")}
                        topHudLabel={t("slide00.viewControls.topHud")}
                        topRibbonLabel={t("slide00.viewControls.topRibbon")}
                        diagnosticsLabel={t("slide00.viewControls.diagnostics")}
                      />

                      {/* TODO(slide00-first-proof): Legacy side modules intentionally kept but hidden in this ritual lock iteration. */}
                      <div hidden aria-hidden="true">
                        <BootStatusBadge
                          isArmed={boot.isArmed}
                          isOperatorAssisted={boot.isOperatorAssisted}
                          narrative={statusNarrativeLabel}
                          lastEventLabel={lastEventLabel}
                          label={t("slide00.badge.systemStatus.label")}
                          armedLabel={t("slide00.badge.systemStatus.armed")}
                          assistedLabel={t("slide00.badge.systemStatus.assisted")}
                          lockedLabel={t("slide00.badge.systemStatus.locked")}
                          lastEventPrefix={t("slide00.badge.systemStatus.lastEvent")}
                        />

                        <OpeningFlagsBadge
                          summary={cinematicFlagSummary || t("slide00.diagnostics.none")}
                          autostartReason={humanReason(boot.gates.tourAutostart.reason)}
                          warning={boot.gates.tourAutostart.reason === "autostart-disabled-by-boot-contract"}
                          label={t("slide00.badge.flags.label")}
                          autostartLabel={t("slide00.badge.flags.autostart")}
                        />

                        <PersistenceIndicator
                          persisted={persistence.hasSnapshot}
                          keyCount={persistence.keys.length}
                          keys={persistence.keys}
                          title={t("slide00.persistence.title")}
                          detectedLabel={t("slide00.persistence.detected")}
                          emptyLabel={t("slide00.persistence.none")}
                          keyCountLabel={t("slide00.persistence.keys", { count: persistence.keys.length })}
                        />

                        <ResetControls
                          onSoftReset={softReset}
                          onHardReset={hardReset}
                          title={t("slide00.reset.title")}
                          copy={t("slide00.reset.copy")}
                          softLabel={t("slide00.reset.soft")}
                          hardLabel={t("slide00.reset.hard")}
                        />

                        <GateMatrix
                          rows={gateRows}
                          humanReason={humanReason}
                          title={t("slide00.gate.title")}
                          availableLabel={t("slide00.gate.available")}
                          lockedLabel={t("slide00.gate.locked")}
                          disabledLabel={t("slide00.gate.disabled")}
                        />
                      </div>
                    </BootSideColumn>
                  </SideDockScrollRegion>
                </PowerConsoleSection>
              }
              afterMain={
                <>
                  <PowerConsoleSection className="slide00-power-console-section--status">
                    <StatusStrip
                      title={t("slide00.statusStrip.title")}
                      subtitle={t("slide00.statusStrip.subtitle")}
                      items={statusItems}
                    />
                  </PowerConsoleSection>
                  <PowerConsoleSection className="slide00-power-console-section--actions">
                    <FirstActionsRail
                      title={t("slide00.firstActions.title")}
                      subtitle={t("slide00.firstActions.subtitle")}
                      actions={firstActions}
                    />
                  </PowerConsoleSection>
                </>
              }
            />

            <EvidenceList
              title={t("slide00.evidence.title")}
              rows={blockerRows}
              formatTimestamp={formatTimestamp}
              metaLabel={t("slide00.evidence.meta")}
              confirmedLabel={(time) => t("slide00.evidence.confirmed", { time })}
              awaitingLabel={t("slide00.evidence.awaiting")}
              satisfiedLabel={t("slide00.evidence.state.satisfied")}
              missingLabel={t("slide00.evidence.state.missing")}
              idleLabel={t("slide00.evidence.state.idle")}
            />

            <BootFoot
              left={t("slide00.foot.left", { time: formatDateTime(Date.now()) })}
              right={t("slide00.foot.right", {
                anchor: boot.diagnostics.lastInteractedAnchor ?? t("slide00.diagnostics.meta.none"),
              })}
            />

            <BootNote warning={boot.isOperatorAssisted}>
              {t("slide00.note.override.start")} <strong>{t("slide00.note.override.armed")}</strong>
              {t("slide00.note.override.end")}
            </BootNote>

            <BootNote danger={boot.gateLocked}>{t("slide00.note.locked")}</BootNote>

            <Slide00HiddenState
              bootStatus={boot.state.boot.status}
              armedEvidence={
                boot.state.evidence.entries["evidence:system:armed"].satisfied
                  ? "satisfied"
                  : "missing"
              }
            />
          </Slide00Shell>
        </PowerConsoleFrame>

        <FitDiagnosticsOverlay
          enabled={SHOW_FIT_DIAGNOSTICS}
          preset={densityPreset.preset}
          presetReason={densityPreset.reason}
          metrics={viewportMetrics}
        />
      </TokenBridge>
    </SlideContainer>
  );
};
```

===== MODIFIED FILE: components/slides/slide00-ui/index.ts =====
`$ext
export * from "./AiCoreIcon";
export * from "./ArmSystemButton";
export * from "./BootCenterLayout";
export * from "./BootFoot";
export * from "./BootNote";
export * from "./BootPanel";
export * from "./BootPanelBody";
export * from "./BootPanelFooter";
export * from "./BootPanelHeader";
export * from "./BootSideColumn";
export * from "./BootStateIndicator";
export * from "./BootStatusBadge";
export * from "./BootTopline";
export * from "./BootToast";
export * from "./ConfirmSlot";
export * from "./DiagnosticsBackButton";
export * from "./DiagnosticsDock";
export * from "./DiagnosticsDockToggle";
export * from "./EvidenceList";
export * from "./EvidenceStatusStrip";
export * from "./GateMatrix";
export * from "./GlassSurface";
export * from "./OpeningFlagsBadge";
export * from "./PersistenceIndicator";
export * from "./ResetControls";
export * from "./Slide00HiddenState";
export * from "./Slide00Shell";
export * from "./Slide00ViewVisibilityContext";
export * from "./TopHudRow";
export * from "./TopRibbon";
export * from "./ViewControlsTogglePanel";
export * from "./slide00.helpers";
export * from "./types";
export * from "./layout";
export * from "./copy";
export * from "./interactions";
export * from "./first-proof";
export * from "./tokens";
export * from "./tokens/TokenBridge";
```

===== MODIFIED FILE: tests/unit/playwright-harness.unit.ts =====
`$ext
import { strict as assert } from 'node:assert';
import { readdirSync, readFileSync, statSync } from 'node:fs';
import path from 'node:path';

const repoRoot = process.cwd();
const allowedE2eSpecs = [
  'tests/e2e/demo.e2e.spec.ts',
  'tests/e2e/gemini-boundary.e2e.spec.ts',
  'tests/e2e/slide00-boot-gate.e2e.spec.ts',
  'tests/e2e/slide00-firstproof.e2e.spec.ts',
] as const;

function normalize(relPath: string): string {
  return relPath.replace(/\\/g, '/');
}

function walk(dir: string): string[] {
  const stack = [dir];
  const files: string[] = [];
  const excluded = new Set(['.git', 'node_modules', 'dist', 'build', '.run', '.next', '.vite', 'coverage']);

  while (stack.length > 0) {
    const current = stack.pop()!;
    for (const entry of readdirSync(current)) {
      const full = path.join(current, entry);
      const st = statSync(full);
      if (st.isDirectory()) {
        if (!excluded.has(entry) && !entry.startsWith('INVERSION_')) stack.push(full);
        continue;
      }
      files.push(normalize(path.relative(repoRoot, full)));
    }
  }

  return files;
}

function test_playwright_config_scope() {
  const content = readFileSync(path.join(repoRoot, 'playwright.config.ts'), 'utf8');
  assert.match(content, /testDir\s*:\s*['"]\.\/tests\/e2e['"]/);
  assert.match(content, /testMatch\s*:\s*\[[^\]]*e2e\.spec\.ts[^\]]*\]/s);
}

function test_e2e_specs_are_confined() {
  const files = walk(repoRoot);
  const e2eSpecs = files
    .filter((rel) => rel.endsWith('.e2e.spec.ts'))
    .sort((a, b) => a.localeCompare(b));
  const expectedSpecs = [...allowedE2eSpecs].sort((a, b) => a.localeCompare(b));

  assert.equal(allowedE2eSpecs.includes('tests/e2e/slide00-boot-gate.e2e.spec.ts'), true);
  assert.deepEqual(e2eSpecs, expectedSpecs);
}

export function runPlaywrightHarnessSpecs(): void {
  test_playwright_config_scope();
  test_e2e_specs_are_confined();
}
```

===== MODIFIED FILE: tests/unit/run-all.ts =====
`$ext
import { runNoReworkGuardSpecs } from './no-rework-guard.unit';
import { runPlaywrightHarnessSpecs } from './playwright-harness.unit';
import { runBootEvidenceSpecs } from './boot-evidence.unit';
import { runBootReducerSpecs } from './boot-reducer.unit';
import { runBootWowGateSpecs } from './boot-wow-gate.unit';
import { runGuideEngineSpecs } from './wow-guide-engine.unit';
import { runGuideSchemaSpecs } from './wow-guide-schema.unit';
import { runSlide00CopySpecs } from './slide00-copy.unit';
import { runFirstProofHelperSpecs } from '../../components/slides/slide00-ui/first-proof/__tests__/firstProof.helpers.test';

runBootReducerSpecs();
runBootEvidenceSpecs();
runBootWowGateSpecs();
runGuideEngineSpecs();
runGuideSchemaSpecs();
runSlide00CopySpecs();
runFirstProofHelperSpecs();
runPlaywrightHarnessSpecs();
runNoReworkGuardSpecs();

console.log('[unit] PASS');
```

5) git diff and git diff --stat
Scoped git status (repo currently has pre-existing unrelated dirty files; this is the full status):
```txt
 M App.tsx
 M README.md
 M components/slides/Slide00.boot.css
 M components/slides/Slide00.tsx
 M components/slides/slide00-ui/BootPanelBody.tsx
 M components/slides/slide00-ui/BootStateIndicator.tsx
 M components/slides/slide00-ui/BootStatusBadge.tsx
 M components/slides/slide00-ui/BootToast.tsx
 M components/slides/slide00-ui/DiagnosticsBackButton.tsx
 M components/slides/slide00-ui/DiagnosticsDock.tsx
 M components/slides/slide00-ui/DiagnosticsDockToggle.tsx
 M components/slides/slide00-ui/EvidenceList.tsx
 M components/slides/slide00-ui/GateMatrix.tsx
 M components/slides/slide00-ui/OpeningFlagsBadge.tsx
 M components/slides/slide00-ui/PersistenceIndicator.tsx
 M components/slides/slide00-ui/ResetControls.tsx
 M components/slides/slide00-ui/ViewControlsTogglePanel.tsx
 M components/slides/slide00-ui/index.ts
 M components/slides/slide00-ui/slide00.helpers.ts
 M components/slides/slide00-ui/types.ts
 M tests/unit/playwright-harness.unit.ts
 M tests/unit/run-all.ts
?? AGENTS.md
?? CODEX_OUTPUT_SLIDE00_BLOCK01_FROM_REPO.txt
?? components/slides/slide00-ui/copy/
?? components/slides/slide00-ui/first-proof/
?? components/slides/slide00-ui/interactions/
?? components/slides/slide00-ui/layout/
?? components/slides/slide00-ui/tokens/
?? docs/INVERSION_KERNEL_SPEC_v1.md
?? docs/INVERSION_PRINCIPLES.md
?? tests/e2e/slide00-firstproof.e2e.spec.ts
?? tests/unit/slide00-copy.unit.ts
```
Scoped git diff --stat (files of this iteration):
```txt
 components/slides/Slide00.tsx         | 1172 +++++++++++++++++++++++----------
 components/slides/slide00-ui/index.ts |    8 +-
 tests/unit/playwright-harness.unit.ts |    1 +
 tests/unit/run-all.ts                 |    4 +
 4 files changed, 828 insertions(+), 357 deletions(-)
```
Scoped git diff --numstat (files of this iteration):
```txt
816	356	components/slides/Slide00.tsx
7	1	components/slides/slide00-ui/index.ts
1	0	tests/unit/playwright-harness.unit.ts
4	0	tests/unit/run-all.ts
```
Scoped git diff (files of this iteration):
```diff
diff --git a/components/slides/Slide00.tsx b/components/slides/Slide00.tsx
index 993674e..44efe3c 100644
--- a/components/slides/Slide00.tsx
+++ b/components/slides/Slide00.tsx
@@ -1,5 +1,5 @@
-import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
-import { Header, NavArea, SlideContainer } from "../SlideRenderer";
+import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
+import { Header, NavArea, SlideContainer } from "../SlideRenderer";
 import {
   OPERATOR_DIAGNOSTICS,
   WOW_DEMO_SCRIPT,
@@ -8,89 +8,126 @@ import {
   WOW_TOUR,
   WOW_TOUR_AUTOSTART,
 } from "../../config/wow";
-import { useBootRuntime } from "../../runtime/boot";
+import { useBootRuntime } from "../../runtime/boot/BootRuntimeContext";
 import {
-  BootCenterLayout,
   BootFoot,
-  BootNote,
-  BootPanel,
-  BootPanelBody,
-  BootPanelFooter,
-  BootPanelHeader,
-  BootSideColumn,
-  BootStatusBadge,
-  BootToast,
-  BootTopline,
-  DiagnosticsDock,
+  BootNote,
+  BootPanel,
+  BootPanelBody,
+  BootPanelFooter,
+  BootPanelHeader,
+  BootSideColumn,
+  BootStatusBadge,
+  BootToast,
+  BootTopline,
+  DiagnosticsDock,
   DiagnosticsDockToggle,
   EvidenceList,
+  FirstProofCanonicalProfile,
+  FirstProofRitual,
+  FirstProofSnapshot,
   GateMatrix,
   OpeningFlagsBadge,
   PersistenceIndicator,
+  RightSeal,
   ResetControls,
   Slide00HiddenState,
   Slide00Shell,
   ViewControlsTogglePanel,
-  buildConfirmSlotContent,
   buildEvidenceRows,
-  buildEvidenceStatusCards,
+  buildEvidenceStatusCards,
   buildGateRows,
   clearSystemStorageKeys,
   collectSystemStorageKeys,
+  createInitialFirstProofState,
+  deriveFirstProofSnapshot,
   formatDateTime,
   formatTimestamp,
   humanReason,
-  statusLabel,
-  statusNarrative,
   useSlide00ViewVisibility,
 } from "./slide00-ui";
+import { CopyBoundary, useCopy } from "./slide00-ui/copy";
+import {
+  FitDiagnosticsOverlay,
+  PowerConsoleFrame,
+  PowerConsoleGrid,
+  PowerConsoleSection,
+  SideDockScrollRegion,
+  useDensityPreset,
+  useViewportMetrics,
+} from "./slide00-ui/layout";
+import { FirstActionModel, FirstActionsRail, StatusStrip, StatusStripItem } from "./slide00-ui/interactions";
+import { TokenBridge } from "./slide00-ui/tokens/TokenBridge";
+import { BootStatusChip, ConfirmSlotState } from "./slide00-ui/types";
 import "./Slide00.boot.css";
 
+const SHOW_FIT_DIAGNOSTICS = false;
+
 type Slide00Props = {
   nextSlide: () => void;
   prevSlide: () => void;
 };
 
-type PersistenceState = {
-  hasSnapshot: boolean;
-  keys: string[];
+export const Slide00: React.FC<Slide00Props> = (props) => {
+  return (
+    <CopyBoundary>
+      <Slide00Content {...props} />
+    </CopyBoundary>
+  );
 };
-
-function readPersistenceState(): PersistenceState {
-  if (typeof window === "undefined") {
-    return { hasSnapshot: false, keys: [] };
-  }
-
-  const keys = collectSystemStorageKeys(window.localStorage);
-  return {
-    hasSnapshot: keys.includes("hitech.boot.snapshot.v1"),
-    keys,
-  };
-}
-
-export const Slide00: React.FC<Slide00Props> = ({ nextSlide, prevSlide }) => {
+
+type PersistenceState = {
+  hasSnapshot: boolean;
+  keys: string[];
+};
+
+function readPersistenceState(): PersistenceState {
+  if (typeof window === "undefined") {
+    return { hasSnapshot: false, keys: [] };
+  }
+
+  const keys = collectSystemStorageKeys(window.localStorage);
+  return {
+    hasSnapshot: keys.includes("hitech.boot.snapshot.v1"),
+    keys,
+  };
+}
+
+const Slide00Content: React.FC<Slide00Props> = ({ nextSlide, prevSlide }) => {
   const boot = useBootRuntime();
   const viewVisibility = useSlide00ViewVisibility();
+  const { t } = useCopy();
+  const firstProofProfile: FirstProofCanonicalProfile = "legacy";
   const [showToast, setShowToast] = useState(false);
-  const [toastDetail, setToastDetail] = useState("Sistema listo");
+  const [toastDetail, setToastDetail] = useState(() => t("slide00.toast.title"));
   const [diagnosticsOpen, setDiagnosticsOpen] = useState(false);
   const [diagnosticsCompact, setDiagnosticsCompact] = useState(false);
   const [demoScriptActive, setDemoScriptActive] = useState(false);
   const [mirrorActive, setMirrorActive] = useState(false);
   const [persistence, setPersistence] = useState<PersistenceState>(() => readPersistenceState());
+  const [firstProofSnapshot, setFirstProofSnapshot] = useState<FirstProofSnapshot>(() =>
+    deriveFirstProofSnapshot(createInitialFirstProofState())
+  );
+  const [actionFeedback, setActionFeedback] = useState<Record<string, string>>({});
   const lastToastLogIdRef = useRef<string | null>(null);
-
+  const viewportMetrics = useViewportMetrics();
+  const densityPreset = useDensityPreset(viewportMetrics);
+
   const refreshPersistence = useCallback(() => {
     setPersistence(readPersistenceState());
   }, []);
 
-  const evidenceRows = useMemo(() => buildEvidenceRows(boot), [boot.state.evidence]);
-  const blockerRows = useMemo(
-    () => evidenceRows.filter((row) => row.blocker),
-    [evidenceRows]
-  );
-  const gateRows = useMemo(() => buildGateRows(boot), [boot.gates]);
-
+  const onFirstProofSnapshotChange = useCallback((snapshot: FirstProofSnapshot) => {
+    setFirstProofSnapshot(snapshot);
+  }, []);
+
+  const evidenceRows = useMemo(() => buildEvidenceRows(boot), [boot.state.evidence]);
+  const blockerRows = useMemo(
+    () => evidenceRows.filter((row) => row.blocker),
+    [evidenceRows]
+  );
+  const gateRows = useMemo(() => buildGateRows(boot), [boot.gates]);
+
   const kpiCards = useMemo(
     () =>
       buildEvidenceStatusCards({
@@ -99,433 +136,856 @@ export const Slide00: React.FC<Slide00Props> = ({ nextSlide, prevSlide }) => {
         operatorAssisted: boot.isOperatorAssisted,
         missingBlockers: boot.diagnostics.evidenceSummary.blockersMissing,
         satisfiedBlockers: boot.diagnostics.evidenceSummary.blockersSatisfied,
+        labels: {
+          gateKey: t("slide00.kpi.gate"),
+          blockersKey: t("slide00.kpi.blockers"),
+          pathKey: t("slide00.kpi.path"),
+          gateLockedValue: t("slide00.kpi.gate.locked"),
+          gateOpenValue: t("slide00.kpi.gate.open"),
+          pathEvidenceValue: t("slide00.kpi.path.evidence"),
+          pathAssistedValue: t("slide00.kpi.path.assisted"),
+          pathStrictValue: t("slide00.kpi.path.strict"),
+        },
       }),
-    [boot.gateLocked, boot.isArmed, boot.isOperatorAssisted, boot.diagnostics.evidenceSummary]
+    [boot.gateLocked, boot.isArmed, boot.isOperatorAssisted, boot.diagnostics.evidenceSummary, t]
   );
-
+
   const confirmSlot = useMemo(
-    () =>
-      buildConfirmSlotContent({
-        status: boot.state.boot.status,
-        isArmed: boot.isArmed,
-      }),
-    [boot.state.boot.status, boot.isArmed]
+    () => {
+      if (boot.isArmed) {
+        return {
+          state: "armed" as ConfirmSlotState,
+          text: t("slide00.confirm.prefix"),
+          strongText: t("slide00.confirm.armed"),
+        };
+      }
+
+      if (boot.state.boot.status === "ARMED_PENDING_CONFIRM") {
+        return {
+          state: "pending" as ConfirmSlotState,
+          text: t("slide00.confirm.prefix"),
+          strongText: t("slide00.confirm.pending"),
+        };
+      }
+
+      return {
+        state: "empty" as ConfirmSlotState,
+        text: t("slide00.confirm.empty"),
+      };
+    },
+    [boot.state.boot.status, boot.isArmed, t]
   );
-
-  const showConfirmButton =
-    boot.state.boot.status === "ARMED_PENDING_CONFIRM" ||
-    (boot.state.boot.status === "OPERATOR_ASSISTED" && !boot.isArmed);
-
+
+  const showConfirmButton =
+    boot.state.boot.status === "ARMED_PENDING_CONFIRM" ||
+    (boot.state.boot.status === "OPERATOR_ASSISTED" && !boot.isArmed);
+
   const confirmLabel =
     boot.state.boot.status === "OPERATOR_ASSISTED" && !boot.isArmed
-      ? "confirm arming (override path)"
-      : "confirm arming";
-
-  const canConfirm =
-    boot.state.boot.status === "ARMED_PENDING_CONFIRM" ? boot.canConfirm : true;
-
-  useEffect(() => {
-    const lastLog = boot.state.operatorLog[boot.state.operatorLog.length - 1];
-    if (!lastLog) return;
-    if (lastLog.action !== "boot:arm:confirmed") return;
-    if (lastToastLogIdRef.current === lastLog.id) return;
-
-    lastToastLogIdRef.current = lastLog.id;
-    setToastDetail(lastLog.title);
-    setShowToast(true);
-  }, [boot.state.operatorLog]);
-
-  useEffect(() => {
-    refreshPersistence();
-  }, [boot.state, refreshPersistence]);
-
-  useEffect(() => {
-    if (viewVisibility.showDiagnostics) return;
-    setDiagnosticsOpen(false);
-  }, [viewVisibility.showDiagnostics]);
-
-  const armNow = useCallback(() => {
-    boot.recordAnchorInteraction("slide00:arm-system", "Primary arm button clicked");
-    if (!boot.canArm) return;
-    boot.requestArm();
-  }, [boot]);
-
-  const confirmArm = useCallback(() => {
-    boot.recordAnchorInteraction("slide00:confirm-arm", "Arm confirmation clicked");
-    if (boot.state.boot.status === "ARMED_PENDING_CONFIRM" && !boot.canConfirm) return;
-    boot.confirmArm();
-  }, [boot]);
-
-  const toggleOverride = useCallback(() => {
-    boot.recordAnchorInteraction("slide00:override-toggle", "Operator override toggled");
-    boot.setOverride(!boot.state.boot.overrideEnabled);
-  }, [boot]);
-
-  const softReset = useCallback(() => {
-    boot.recordAnchorInteraction("slide00:soft-reset", "Operator soft reset requested");
-    boot.resetLocal();
-    setShowToast(false);
-    refreshPersistence();
-  }, [boot, refreshPersistence]);
-
-  const hardReset = useCallback(() => {
-    boot.recordAnchorInteraction("slide00:hard-reset", "Operator hard reset requested");
-    boot.resetLocal();
-
-    if (typeof window !== "undefined") {
-      const cleared = clearSystemStorageKeys(window.localStorage);
-      boot.appendOperatorLog({
-        level: "warning",
-        title: "Hard reset completed",
-        detail: `Cleared ${cleared} local storage key(s).`,
-        action: "boot:reset:hard",
-      });
-    }
-
-    setShowToast(false);
-    refreshPersistence();
-  }, [boot, refreshPersistence]);
-
+      ? t("slide00.panel.confirmOverrideButton")
+      : t("slide00.panel.confirmButton");
+
+  const canConfirm =
+    boot.state.boot.status === "ARMED_PENDING_CONFIRM" ? boot.canConfirm : true;
+
+  useEffect(() => {
+    const lastLog = boot.state.operatorLog[boot.state.operatorLog.length - 1];
+    if (!lastLog) return;
+    if (lastLog.action !== "boot:arm:confirmed") return;
+    if (lastToastLogIdRef.current === lastLog.id) return;
+
+    lastToastLogIdRef.current = lastLog.id;
+    setToastDetail(lastLog.title);
+    setShowToast(true);
+  }, [boot.state.operatorLog]);
+
+  useEffect(() => {
+    refreshPersistence();
+  }, [boot.state, refreshPersistence]);
+
+  useEffect(() => {
+    if (viewVisibility.showDiagnostics) return;
+    setDiagnosticsOpen(false);
+  }, [viewVisibility.showDiagnostics]);
+
+  const armNow = useCallback(() => {
+    boot.recordAnchorInteraction("slide00:arm-system", "Primary arm button clicked");
+    if (!boot.canArm) return;
+    boot.requestArm();
+  }, [boot]);
+
+  const confirmArm = useCallback(() => {
+    boot.recordAnchorInteraction("slide00:confirm-arm", "Arm confirmation clicked");
+    if (boot.state.boot.status === "ARMED_PENDING_CONFIRM" && !boot.canConfirm) return;
+    boot.confirmArm();
+  }, [boot]);
+
+  const toggleOverride = useCallback(() => {
+    boot.recordAnchorInteraction("slide00:override-toggle", "Operator override toggled");
+    boot.setOverride(!boot.state.boot.overrideEnabled);
+  }, [boot]);
+
+  const softReset = useCallback(() => {
+    boot.recordAnchorInteraction("slide00:soft-reset", "Operator soft reset requested");
+    boot.resetLocal();
+    setShowToast(false);
+    refreshPersistence();
+  }, [boot, refreshPersistence]);
+
+  const hardReset = useCallback(() => {
+    boot.recordAnchorInteraction("slide00:hard-reset", "Operator hard reset requested");
+    boot.resetLocal();
+
+    if (typeof window !== "undefined") {
+      const cleared = clearSystemStorageKeys(window.localStorage);
+      boot.appendOperatorLog({
+        level: "warning",
+        title: "Hard reset completed",
+        detail: `Cleared ${cleared} local storage key(s).`,
+        action: "boot:reset:hard",
+      });
+    }
+
+    setShowToast(false);
+    refreshPersistence();
+  }, [boot, refreshPersistence]);
+
   const copySnapshot = useCallback(async () => {
-    boot.recordAnchorInteraction("slide00:snapshot-copy", "Operator requested snapshot copy");
-    const copied = await boot.copySnapshotToClipboard();
-
+    boot.recordAnchorInteraction("slide00:snapshot-copy", "Operator requested snapshot copy");
+    const copied = await boot.copySnapshotToClipboard();
+
     boot.appendOperatorLog({
       level: copied ? "success" : "warning",
       title: copied ? "Snapshot copied" : "Snapshot copy unavailable",
-      detail: copied
-        ? "Snapshot JSON copied to clipboard."
-        : "Clipboard API unavailable. Use download snapshot.",
+      detail: copied
+        ? "Snapshot JSON copied to clipboard."
+        : "Clipboard API unavailable. Use download snapshot.",
       action: copied ? "boot:snapshot:copied" : "boot:snapshot:copy:failed",
     });
-  }, [boot]);
 
+    return copied;
+  }, [boot]);
+
   const downloadSnapshot = useCallback(() => {
-    boot.recordAnchorInteraction(
-      "slide00:snapshot-download",
-      "Operator requested snapshot download"
-    );
-    const downloaded = boot.downloadSnapshot("boot-snapshot.json");
-
+    boot.recordAnchorInteraction(
+      "slide00:snapshot-download",
+      "Operator requested snapshot download"
+    );
+    const downloaded = boot.downloadSnapshot("boot-snapshot.json");
+
     boot.appendOperatorLog({
       level: downloaded ? "success" : "warning",
-      title: downloaded ? "Snapshot downloaded" : "Snapshot download unavailable",
-      detail: downloaded
-        ? "Snapshot file was generated locally."
-        : "Download API unavailable in this environment.",
+      title: downloaded ? "Snapshot downloaded" : "Snapshot download unavailable",
+      detail: downloaded
+        ? "Snapshot file was generated locally."
+        : "Download API unavailable in this environment.",
       action: downloaded ? "boot:snapshot:downloaded" : "boot:snapshot:download:failed",
     });
-  }, [boot]);
-
-  const toggleDemoScript = useCallback(() => {
-    const next = !demoScriptActive;
-    setDemoScriptActive(next);
-    boot.recordAnchorInteraction(
-      "slide00:toggle-demo-script",
-      `Demo script toggled ${next ? "on" : "off"}`
-    );
-    window.dispatchEvent(
-      new CustomEvent("wow:demo-script-toggle", { detail: { enabled: next } })
-    );
-  }, [boot, demoScriptActive]);
-
-  const toggleMirror = useCallback(() => {
-    const next = !mirrorActive;
-    setMirrorActive(next);
-    boot.recordAnchorInteraction(
-      "slide00:toggle-mirror",
-      `Mirror intro toggled ${next ? "on" : "off"}`
-    );
-    window.dispatchEvent(new CustomEvent("wow:mirror-toggle", { detail: { enabled: next } }));
-  }, [boot, mirrorActive]);
 
+    return downloaded;
+  }, [boot]);
+
+  const toggleDemoScript = useCallback(() => {
+    const next = !demoScriptActive;
+    setDemoScriptActive(next);
+    boot.recordAnchorInteraction(
+      "slide00:toggle-demo-script",
+      `Demo script toggled ${next ? "on" : "off"}`
+    );
+    window.dispatchEvent(
+      new CustomEvent("wow:demo-script-toggle", { detail: { enabled: next } })
+    );
+  }, [boot, demoScriptActive]);
+
+  const toggleMirror = useCallback(() => {
+    const next = !mirrorActive;
+    setMirrorActive(next);
+    boot.recordAnchorInteraction(
+      "slide00:toggle-mirror",
+      `Mirror intro toggled ${next ? "on" : "off"}`
+    );
+    window.dispatchEvent(new CustomEvent("wow:mirror-toggle", { detail: { enabled: next } }));
+  }, [boot, mirrorActive]);
+
   const diagnosticsMeta = useMemo(
     () => [
       {
         key: "state",
-        label: "boot state",
+        label: t("slide00.diagnostics.meta.state"),
         value: boot.state.boot.status,
         testId: "boot-state-value",
       },
       {
         key: "gate",
-        label: "gate lock",
-        value: boot.gateLocked ? "LOCKED" : "OPEN",
+        label: t("slide00.diagnostics.meta.gate"),
+        value: boot.gateLocked ? t("slide00.kpi.gate.locked") : t("slide00.kpi.gate.open"),
       },
       {
         key: "event",
-        label: "last event",
+        label: t("slide00.diagnostics.meta.event"),
         value: boot.diagnostics.lastEvent
           ? `${boot.diagnostics.lastEvent.id} · ${boot.diagnostics.lastEvent.action}`
-          : "--",
+          : t("slide00.diagnostics.meta.none"),
       },
       {
         key: "anchor",
-        label: "last anchor",
-        value: boot.diagnostics.lastInteractedAnchor ?? "--",
+        label: t("slide00.diagnostics.meta.anchor"),
+        value: boot.diagnostics.lastInteractedAnchor ?? t("slide00.diagnostics.meta.none"),
       },
     ],
-    [boot.state.boot.status, boot.gateLocked, boot.diagnostics.lastEvent, boot.diagnostics.lastInteractedAnchor]
+    [boot.state.boot.status, boot.gateLocked, boot.diagnostics.lastEvent, boot.diagnostics.lastInteractedAnchor, t]
   );
-
+
   const diagnosticsControls = useMemo(
     () => [
       {
         key: "override",
-        copy: "Allow advance without arming (operator-assisted only).",
+        copy: t("slide00.diagnostics.controls.override.copy"),
         actions: [
           {
             key: "toggle",
-            label: boot.state.boot.overrideEnabled ? "override on" : "override off",
+            label: boot.state.boot.overrideEnabled
+              ? t("slide00.diagnostics.controls.override.on")
+              : t("slide00.diagnostics.controls.override.off"),
             active: boot.state.boot.overrideEnabled,
             onClick: toggleOverride,
             testId: "operator-override-toggle",
-          },
-        ],
+          },
+        ],
       },
       {
         key: "reset",
-        copy: "Soft reset local runtime to IDLE and clear active boot snapshot.",
+        copy: t("slide00.diagnostics.controls.reset.copy"),
         actions: [
           {
             key: "soft-reset",
-            label: "soft reset",
+            label: t("slide00.diagnostics.controls.reset.button"),
             onClick: softReset,
             testId: "operator-reset-local",
           },
-        ],
+        ],
       },
       {
         key: "snapshot",
-        copy: "Snapshot export (deterministic JSON).",
+        copy: t("slide00.diagnostics.controls.snapshot.copy"),
         actions: [
           {
             key: "copy",
-            label: "copy",
+            label: t("slide00.diagnostics.controls.snapshot.copyButton"),
             onClick: copySnapshot,
             testId: "operator-copy-snapshot",
           },
           {
             key: "download",
-            label: "download",
+            label: t("slide00.diagnostics.controls.snapshot.downloadButton"),
             onClick: downloadSnapshot,
             testId: "operator-download-snapshot",
           },
-        ],
+        ],
       },
       {
         key: "demo-script",
-        copy: "Manual script surface (still blocked before arming).",
+        copy: t("slide00.diagnostics.controls.demo.copy"),
         actions: [
           {
             key: "demo",
-            label: demoScriptActive ? "script on" : "script off",
+            label: demoScriptActive
+              ? t("slide00.diagnostics.controls.demo.on")
+              : t("slide00.diagnostics.controls.demo.off"),
             active: demoScriptActive,
             onClick: toggleDemoScript,
           },
-        ],
+        ],
       },
       {
         key: "mirror",
-        copy: "Manual mirror intro (still blocked before arming).",
+        copy: t("slide00.diagnostics.controls.mirror.copy"),
         actions: [
           {
             key: "mirror",
-            label: mirrorActive ? "mirror on" : "mirror off",
+            label: mirrorActive
+              ? t("slide00.diagnostics.controls.mirror.on")
+              : t("slide00.diagnostics.controls.mirror.off"),
             active: mirrorActive,
             onClick: toggleMirror,
           },
-        ],
-      },
-    ],
-    [
-      boot.state.boot.overrideEnabled,
-      copySnapshot,
-      demoScriptActive,
-      downloadSnapshot,
-      mirrorActive,
-      softReset,
-      toggleDemoScript,
-      toggleMirror,
+        ],
+      },
+    ],
+    [
+      boot.state.boot.overrideEnabled,
+      copySnapshot,
+      demoScriptActive,
+      downloadSnapshot,
+      mirrorActive,
+      softReset,
+      toggleDemoScript,
+      toggleMirror,
       toggleOverride,
+      t,
     ]
   );
+
+  const diagnosticsLogRows = useMemo(
+    () =>
+      boot.state.operatorLog
+        .slice(-8)
+        .reverse()
+        .map((entry) => ({
+          id: entry.id,
+          head: `${entry.action} · ${formatTimestamp(entry.ts)}`,
+          body: `${entry.title} - ${entry.detail}`,
+        })),
+    [boot.state.operatorLog]
+  );
+
+  const lastEventLabel = boot.diagnostics.lastEvent
+    ? `${boot.diagnostics.lastEvent.id} · ${boot.diagnostics.lastEvent.action}`
+    : t("slide00.diagnostics.meta.none");
+
+  const cinematicFlagSummary = [
+    WOW_TOUR ? "tour" : null,
+    WOW_TOUR_AUTOSTART ? "tour_autostart" : null,
+    WOW_DEMO_SCRIPT ? "demo_script" : null,
+    WOW_OPENING_CINEMA ? "opening_cinema" : null,
+    WOW_MIRROR ? "mirror" : null,
+  ]
+    .filter(Boolean)
+    .join(", ");
+
+  const status = useMemo(() => {
+    if (boot.state.boot.status === "IDLE") return t("slide00.statusLabel.IDLE");
+    if (boot.state.boot.status === "ARMED_PENDING_CONFIRM") return t("slide00.statusLabel.ARMED_PENDING_CONFIRM");
+    if (boot.state.boot.status === "ARMED_CONFIRMED") return t("slide00.statusLabel.ARMED_CONFIRMED");
+    if (boot.state.boot.status === "OPERATOR_ASSISTED") return t("slide00.statusLabel.OPERATOR_ASSISTED");
+    return boot.state.boot.status;
+  }, [boot.state.boot.status, t]);
+
+  const statusNarrativeLabel = useMemo(() => {
+    if (boot.state.boot.status === "IDLE") return t("slide00.statusNarrative.IDLE");
+    if (boot.state.boot.status === "ARMED_PENDING_CONFIRM") return t("slide00.statusNarrative.ARMED_PENDING_CONFIRM");
+    if (boot.state.boot.status === "ARMED_CONFIRMED") return t("slide00.statusNarrative.ARMED_CONFIRMED");
+    if (boot.state.boot.status === "OPERATOR_ASSISTED") return t("slide00.statusNarrative.OPERATOR_ASSISTED");
+    return t("slide00.statusNarrative.UNKNOWN");
+  }, [boot.state.boot.status, t]);
 
-  const diagnosticsLogRows = useMemo(
-    () =>
-      boot.state.operatorLog
-        .slice(-8)
-        .reverse()
-        .map((entry) => ({
-          id: entry.id,
-          head: `${entry.action} · ${formatTimestamp(entry.ts)}`,
-          body: `${entry.title} - ${entry.detail}`,
-        })),
-    [boot.state.operatorLog]
+  const diagnosticsSurfaceVisible = viewVisibility.showDiagnostics && OPERATOR_DIAGNOSTICS;
+  const stateChips = useMemo<BootStatusChip[]>(
+    () => [
+      { id: "IDLE", label: t("slide00.stateChip.idle"), variant: "danger" },
+      { id: "ARMED_PENDING_CONFIRM", label: t("slide00.stateChip.pending"), variant: "warning" },
+      { id: "ARMED_CONFIRMED", label: t("slide00.stateChip.armed"), variant: "default" },
+      { id: "OPERATOR_ASSISTED", label: t("slide00.stateChip.assisted"), variant: "warning" },
+    ],
+    [t]
   );
 
-  const lastEventLabel = boot.diagnostics.lastEvent
-    ? `${boot.diagnostics.lastEvent.id} · ${boot.diagnostics.lastEvent.action}`
-    : "--";
+  const addActionFeedback = useCallback((actionId: string, message: string) => {
+    setActionFeedback((prev) => ({
+      ...prev,
+      [actionId]: `${message} · ${formatTimestamp(Date.now())}`,
+    }));
+  }, []);
 
-  const cinematicFlagSummary = [
-    WOW_TOUR ? "tour" : null,
-    WOW_TOUR_AUTOSTART ? "tour_autostart" : null,
-    WOW_DEMO_SCRIPT ? "demo_script" : null,
-    WOW_OPENING_CINEMA ? "opening_cinema" : null,
-    WOW_MIRROR ? "mirror" : null,
-  ]
-    .filter(Boolean)
-    .join(", ");
+  const runFirstAction = useCallback(
+    async (
+      actionId: string,
+      label: string,
+      enabled: boolean,
+      action: () => void | Promise<boolean>
+    ) => {
+      if (!enabled) {
+        addActionFeedback(actionId, t("slide00.actionFeedback.blocked", { label }));
+        return;
+      }
+
+      const result = await action();
+      if (result === false) {
+        addActionFeedback(actionId, t("slide00.actionFeedback.unavailable", { label }));
+        return;
+      }
+
+      addActionFeedback(actionId, t("slide00.actionFeedback.executed", { label }));
+    },
+    [addActionFeedback, t]
+  );
 
-  const status = statusLabel(boot.state.boot.status);
+  const statusTone =
+    boot.state.boot.status === "ARMED_CONFIRMED"
+      ? "good"
+      : boot.state.boot.status === "ARMED_PENDING_CONFIRM"
+        ? "warn"
+        : boot.state.boot.status === "OPERATOR_ASSISTED"
+          ? "warn"
+          : "danger";
 
-  const diagnosticsSurfaceVisible = viewVisibility.showDiagnostics && OPERATOR_DIAGNOSTICS;
+  const statusItems = useMemo<StatusStripItem[]>(
+    () => [
+      {
+        key: "state",
+        label: t("slide00.statusStrip.state"),
+        value: status,
+        tone: statusTone,
+      },
+      {
+        key: "gate",
+        label: t("slide00.statusStrip.gate"),
+        value: boot.gateLocked ? t("slide00.kpi.gate.locked") : t("slide00.kpi.gate.open"),
+        tone: boot.gateLocked ? "danger" : "good",
+      },
+      {
+        key: "path",
+        label: t("slide00.statusStrip.path"),
+        value: boot.isArmed
+          ? t("slide00.kpi.path.evidence")
+          : boot.isOperatorAssisted
+            ? t("slide00.kpi.path.assisted")
+            : t("slide00.kpi.path.strict"),
+        tone: boot.isArmed ? "good" : boot.isOperatorAssisted ? "warn" : "neutral",
+      },
+      {
+        key: "blockers",
+        label: t("slide00.statusStrip.blockers"),
+        value: `${boot.diagnostics.evidenceSummary.blockersSatisfied}/${
+          boot.diagnostics.evidenceSummary.blockersSatisfied +
+          boot.diagnostics.evidenceSummary.blockersMissing
+        }`,
+        tone: boot.diagnostics.evidenceSummary.blockersMissing > 0 ? "warn" : "good",
+      },
+    ],
+    [
+      boot.gateLocked,
+      boot.isArmed,
+      boot.isOperatorAssisted,
+      boot.diagnostics.evidenceSummary.blockersSatisfied,
+      boot.diagnostics.evidenceSummary.blockersMissing,
+      status,
+      statusTone,
+      t,
+    ]
+  );
 
+  const firstActions = useMemo<FirstActionModel[]>(
+    () => [
+      {
+        id: "arm",
+        title: t("slide00.firstActions.action.arm.title"),
+        description: t("slide00.firstActions.action.arm.description"),
+        badge: boot.canArm ? t("slide00.firstActions.badge.ready") : t("slide00.firstActions.badge.blocked"),
+        badgeTone: boot.canArm ? "good" : "warn",
+        enabled: boot.canArm,
+        feedback: actionFeedback.arm,
+        onClick: () => {
+          void runFirstAction("arm", t("slide00.firstActions.action.arm.confirm"), boot.canArm, () => {
+            armNow();
+          });
+        },
+        testId: "first-action-arm",
+      },
+      {
+        id: "confirm",
+        title: t("slide00.firstActions.action.confirm.title"),
+        description: t("slide00.firstActions.action.confirm.description"),
+        badge: canConfirm && showConfirmButton
+          ? t("slide00.firstActions.badge.ready")
+          : t("slide00.firstActions.badge.blocked"),
+        badgeTone: canConfirm && showConfirmButton ? "good" : "warn",
+        enabled: canConfirm && showConfirmButton,
+        feedback: actionFeedback.confirm,
+        onClick: () => {
+          void runFirstAction(
+            "confirm",
+            t("slide00.firstActions.action.confirm.confirm"),
+            canConfirm && showConfirmButton,
+            () => {
+              confirmArm();
+            }
+          );
+        },
+        testId: "first-action-confirm",
+      },
+      {
+        id: "override",
+        title: t("slide00.firstActions.action.override.title"),
+        description: t("slide00.firstActions.action.override.description"),
+        badge: t("slide00.firstActions.badge.ready"),
+        badgeTone: boot.state.boot.overrideEnabled ? "warn" : "neutral",
+        enabled: true,
+        feedback: actionFeedback.override,
+        onClick: () => {
+          void runFirstAction("override", t("slide00.firstActions.action.override.confirm"), true, () => {
+            toggleOverride();
+          });
+        },
+        testId: "first-action-override",
+      },
+      {
+        id: "diagnostics",
+        title: t("slide00.firstActions.action.diagnostics.title"),
+        description: t("slide00.firstActions.action.diagnostics.description"),
+        badge: diagnosticsSurfaceVisible ? t("slide00.firstActions.badge.ready") : t("slide00.firstActions.badge.blocked"),
+        badgeTone: diagnosticsSurfaceVisible ? "good" : "danger",
+        enabled: diagnosticsSurfaceVisible,
+        feedback: actionFeedback.diagnostics,
+        onClick: () => {
+          void runFirstAction(
+            "diagnostics",
+            t("slide00.firstActions.action.diagnostics.confirm"),
+            diagnosticsSurfaceVisible,
+            () => {
+              setDiagnosticsOpen(true);
+            }
+          );
+        },
+        testId: "first-action-diagnostics",
+      },
+      {
+        id: "hud",
+        title: t("slide00.firstActions.action.hud.title"),
+        description: t("slide00.firstActions.action.hud.description"),
+        badge: viewVisibility.showTopHudRow
+          ? t("slide00.firstActions.badge.executed")
+          : t("slide00.firstActions.badge.ready"),
+        badgeTone: viewVisibility.showTopHudRow ? "good" : "neutral",
+        enabled: true,
+        feedback: actionFeedback.hud,
+        onClick: () => {
+          void runFirstAction("hud", t("slide00.firstActions.action.hud.confirm"), true, () => {
+            viewVisibility.setShowTopHudRow(!viewVisibility.showTopHudRow);
+          });
+        },
+        testId: "first-action-hud",
+      },
+      {
+        id: "reset",
+        title: t("slide00.firstActions.action.reset.title"),
+        description: t("slide00.firstActions.action.reset.description"),
+        badge: t("slide00.firstActions.badge.ready"),
+        badgeTone: "warn",
+        enabled: true,
+        feedback: actionFeedback.reset,
+        onClick: () => {
+          void runFirstAction("reset", t("slide00.firstActions.action.reset.confirm"), true, () => {
+            softReset();
+          });
+        },
+        testId: "first-action-reset",
+      },
+      {
+        id: "snapshot-copy",
+        title: t("slide00.firstActions.action.snapshotCopy.title"),
+        description: t("slide00.firstActions.action.snapshotCopy.description"),
+        badge: t("slide00.firstActions.badge.ready"),
+        badgeTone: "neutral",
+        enabled: true,
+        feedback: actionFeedback["snapshot-copy"],
+        onClick: () => {
+          void runFirstAction(
+            "snapshot-copy",
+            t("slide00.firstActions.action.snapshotCopy.confirm"),
+            true,
+            () => copySnapshot()
+          );
+        },
+        testId: "first-action-snapshot-copy",
+      },
+      {
+        id: "snapshot-download",
+        title: t("slide00.firstActions.action.snapshotDownload.title"),
+        description: t("slide00.firstActions.action.snapshotDownload.description"),
+        badge: t("slide00.firstActions.badge.ready"),
+        badgeTone: "neutral",
+        enabled: true,
+        feedback: actionFeedback["snapshot-download"],
+        onClick: () => {
+          void runFirstAction(
+            "snapshot-download",
+            t("slide00.firstActions.action.snapshotDownload.confirm"),
+            true,
+            () => downloadSnapshot()
+          );
+        },
+        testId: "first-action-snapshot-download",
+      },
+    ],
+    [
+      actionFeedback,
+      armNow,
+      boot.canArm,
+      boot.state.boot.overrideEnabled,
+      canConfirm,
+      confirmArm,
+      copySnapshot,
+      diagnosticsSurfaceVisible,
+      downloadSnapshot,
+      runFirstAction,
+      showConfirmButton,
+      softReset,
+      t,
+      toggleOverride,
+      viewVisibility,
+    ]
+  );
+
   return (
     <SlideContainer>
-      <Slide00Shell
-        nav={<NavArea prev={prevSlide} next={nextSlide} />}
-        toast={<BootToast open={showToast} detail={toastDetail} onDismiss={() => setShowToast(false)} />}
-        diagnostics={
-          diagnosticsSurfaceVisible ? (
-            <>
-              <DiagnosticsDockToggle
-                open={diagnosticsOpen}
-                onClick={() => setDiagnosticsOpen((prev) => !prev)}
-              />
-              <DiagnosticsDock
-                open={diagnosticsOpen}
-                compact={diagnosticsCompact}
-                onBack={() => setDiagnosticsOpen(false)}
-                onToggleMode={() => setDiagnosticsCompact((prev) => !prev)}
-                metaItems={diagnosticsMeta}
-                controlRows={diagnosticsControls}
-                satisfiedRows={boot.diagnostics.satisfiedEvidence}
-                missingRows={boot.diagnostics.missingBlockers}
-                logRows={diagnosticsLogRows}
-                footerCopy="local diagnostics only · does not alter evidence semantics"
-                footerTime={new Date().toLocaleString()}
-              />
-            </>
-          ) : null
-        }
+      <TokenBridge
+        preset={densityPreset.preset}
+        width={viewportMetrics.viewportWidth}
+        height={viewportMetrics.viewportHeight}
+        scaleX={viewportMetrics.scaleX}
+        scaleY={viewportMetrics.scaleY}
+        compactViewport={viewportMetrics.compactViewport}
+        className="slide00-token-bridge"
       >
-        <BootTopline
-          brandTitle="HITECH RTS"
-          brandSubtitle="boot / deterministic gate"
-          slideLabel="slide 00 · boot gate"
-        />
+        <PowerConsoleFrame preset={densityPreset.preset} metrics={viewportMetrics}>
+          <Slide00Shell
+            nav={<NavArea prev={prevSlide} next={nextSlide} />}
+            toast={
+              <BootToast
+                open={showToast}
+                detail={toastDetail}
+                onDismiss={() => setShowToast(false)}
+                title={t("slide00.toast.title")}
+                dismissLabel={t("slide00.toast.dismiss")}
+              />
+            }
+            diagnostics={
+              diagnosticsSurfaceVisible ? (
+                <>
+                  <DiagnosticsDockToggle
+                    open={diagnosticsOpen}
+                    onClick={() => setDiagnosticsOpen((prev) => !prev)}
+                    openLabel={t("slide00.diagnostics.toggle.open")}
+                    closedLabel={t("slide00.diagnostics.toggle.closed")}
+                  />
+                  <DiagnosticsDock
+                    open={diagnosticsOpen}
+                    compact={diagnosticsCompact}
+                    onBack={() => setDiagnosticsOpen(false)}
+                    onToggleMode={() => setDiagnosticsCompact((prev) => !prev)}
+                    metaItems={diagnosticsMeta}
+                    controlRows={diagnosticsControls}
+                    satisfiedRows={boot.diagnostics.satisfiedEvidence}
+                    missingRows={boot.diagnostics.missingBlockers}
+                    logRows={diagnosticsLogRows}
+                    footerCopy={t("slide00.diagnostics.footer.copy")}
+                    footerTime={t("slide00.diagnostics.footer.time", { time: new Date().toLocaleString() })}
+                    title={t("slide00.diagnostics.title")}
+                    modeCompactLabel={t("slide00.diagnostics.mode.compact")}
+                    modeDockedLabel={t("slide00.diagnostics.mode.docked")}
+                    backLabel={t("slide00.diagnostics.back")}
+                    satisfiedTitle={t("slide00.diagnostics.section.satisfied")}
+                    missingTitle={t("slide00.diagnostics.section.missing")}
+                    logTitle={t("slide00.diagnostics.section.log")}
+                    noneLabel={t("slide00.diagnostics.none")}
+                    logEmptyLabel={t("slide00.diagnostics.log.empty")}
+                  />
+                </>
+              ) : null
+            }
+          >
+            <BootTopline
+              brandTitle={t("slide00.topline.brandTitle")}
+              brandSubtitle={t("slide00.topline.brandSubtitle")}
+              slideLabel={t("slide00.topline.slideLabel")}
+            />
 
-        <Header
-          title="BOOT CONSOLE"
-          breadcrumb="ACTION / WHY / CONFIRM"
-          slideNum={1}
-          rightBadge={`STATE ${status}`}
-        />
+            <Header
+              title={t("slide00.header.title")}
+              breadcrumb={t("slide00.header.breadcrumb")}
+              slideNum={1}
+              rightBadge={t("slide00.header.rightBadge", { status })}
+            />
 
-        <BootCenterLayout
-          main={
-            <BootPanel
-              header={
-                <BootPanelHeader
-                  title="Operator arming required"
-                  subtitle={
-                    <>
-                      This deck starts in manual mode. Scripted systems remain blocked until
-                      <strong> evidence:system:armed </strong>
-                      is satisfied by explicit operator action.
-                    </>
-                  }
-                  whyLabel="why: register verifiable activity"
-                />
+            <PowerConsoleGrid
+              main={
+                <>
+                  <PowerConsoleSection className="slide00-power-console-section--firstproof">
+                    <FirstProofRitual
+                      recordAnchorInteraction={boot.recordAnchorInteraction}
+                      profile={firstProofProfile}
+                      showInlineRightSeal={false}
+                      onSnapshotChange={onFirstProofSnapshotChange}
+                    />
+                  </PowerConsoleSection>
+
+                  <BootPanel
+                    header={
+                      <BootPanelHeader
+                        title={t("slide00.panel.title")}
+                        subtitle={
+                          <>
+                            {t("slide00.panel.subtitle.start")} <strong>{t("slide00.panel.subtitle.armed")}</strong>{" "}
+                            {t("slide00.panel.subtitle.end")}
+                          </>
+                        }
+                        whyLabel={t("slide00.panel.why")}
+                      />
+                    }
+                    body={
+                      <BootPanelBody
+                        status={boot.state.boot.status}
+                        armLabel={t("slide00.panel.armButton")}
+                        canArm={boot.canArm}
+                        canConfirm={canConfirm}
+                        showConfirm={showConfirmButton}
+                        confirmLabel={confirmLabel}
+                        onArm={armNow}
+                        onConfirm={confirmArm}
+                        confirmState={confirmSlot.state}
+                        confirmText={confirmSlot.text}
+                        confirmStrongText={confirmSlot.strongText}
+                        cards={kpiCards}
+                        stateChips={stateChips}
+                      />
+                    }
+                    footer={
+                      <BootPanelFooter>
+                        <p className="slide00-arm-emphasis-copy">{t("slide00.panel.emphasis")}</p>
+                      </BootPanelFooter>
+                    }
+                  />
+                </>
               }
-              body={
-                <BootPanelBody
-                  status={boot.state.boot.status}
-                  canArm={boot.canArm}
-                  canConfirm={canConfirm}
-                  showConfirm={showConfirmButton}
-                  confirmLabel={confirmLabel}
-                  onArm={armNow}
-                  onConfirm={confirmArm}
-                  confirmState={confirmSlot.state}
-                  confirmText={confirmSlot.text}
-                  confirmStrongText={confirmSlot.strongText}
-                  cards={kpiCards}
-                />
+              side={
+                <PowerConsoleSection className="slide00-power-console-section--side">
+                  <SideDockScrollRegion maxHeight={viewportMetrics.sideScrollHeight}>
+                    <BootSideColumn>
+                      <RightSeal snapshot={firstProofSnapshot} profile={firstProofProfile} />
+
+                      <ViewControlsTogglePanel
+                        showTopHudRow={viewVisibility.showTopHudRow}
+                        showTopRibbon={viewVisibility.showTopRibbon}
+                        showDiagnostics={viewVisibility.showDiagnostics}
+                        onTopHudRowChange={viewVisibility.setShowTopHudRow}
+                        onTopRibbonChange={viewVisibility.setShowTopRibbon}
+                        onDiagnosticsChange={viewVisibility.setShowDiagnostics}
+                        title={t("slide00.viewControls.title")}
+                        copy={t("slide00.viewControls.copy")}
+                        topHudLabel={t("slide00.viewControls.topHud")}
+                        topRibbonLabel={t("slide00.viewControls.topRibbon")}
+                        diagnosticsLabel={t("slide00.viewControls.diagnostics")}
+                      />
+
+                      {/* TODO(slide00-first-proof): Legacy side modules intentionally kept but hidden in this ritual lock iteration. */}
+                      <div hidden aria-hidden="true">
+                        <BootStatusBadge
+                          isArmed={boot.isArmed}
+                          isOperatorAssisted={boot.isOperatorAssisted}
+                          narrative={statusNarrativeLabel}
+                          lastEventLabel={lastEventLabel}
+                          label={t("slide00.badge.systemStatus.label")}
+                          armedLabel={t("slide00.badge.systemStatus.armed")}
+                          assistedLabel={t("slide00.badge.systemStatus.assisted")}
+                          lockedLabel={t("slide00.badge.systemStatus.locked")}
+                          lastEventPrefix={t("slide00.badge.systemStatus.lastEvent")}
+                        />
+
+                        <OpeningFlagsBadge
+                          summary={cinematicFlagSummary || t("slide00.diagnostics.none")}
+                          autostartReason={humanReason(boot.gates.tourAutostart.reason)}
+                          warning={boot.gates.tourAutostart.reason === "autostart-disabled-by-boot-contract"}
+                          label={t("slide00.badge.flags.label")}
+                          autostartLabel={t("slide00.badge.flags.autostart")}
+                        />
+
+                        <PersistenceIndicator
+                          persisted={persistence.hasSnapshot}
+                          keyCount={persistence.keys.length}
+                          keys={persistence.keys}
+                          title={t("slide00.persistence.title")}
+                          detectedLabel={t("slide00.persistence.detected")}
+                          emptyLabel={t("slide00.persistence.none")}
+                          keyCountLabel={t("slide00.persistence.keys", { count: persistence.keys.length })}
+                        />
+
+                        <ResetControls
+                          onSoftReset={softReset}
+                          onHardReset={hardReset}
+                          title={t("slide00.reset.title")}
+                          copy={t("slide00.reset.copy")}
+                          softLabel={t("slide00.reset.soft")}
+                          hardLabel={t("slide00.reset.hard")}
+                        />
+
+                        <GateMatrix
+                          rows={gateRows}
+                          humanReason={humanReason}
+                          title={t("slide00.gate.title")}
+                          availableLabel={t("slide00.gate.available")}
+                          lockedLabel={t("slide00.gate.locked")}
+                          disabledLabel={t("slide00.gate.disabled")}
+                        />
+                      </div>
+                    </BootSideColumn>
+                  </SideDockScrollRegion>
+                </PowerConsoleSection>
               }
-              footer={
-                <BootPanelFooter>
-                  <p className="slide00-arm-emphasis-copy">
-                    arm lane reserved for glow, glass and directional emphasis modules.
-                  </p>
-                </BootPanelFooter>
+              afterMain={
+                <>
+                  <PowerConsoleSection className="slide00-power-console-section--status">
+                    <StatusStrip
+                      title={t("slide00.statusStrip.title")}
+                      subtitle={t("slide00.statusStrip.subtitle")}
+                      items={statusItems}
+                    />
+                  </PowerConsoleSection>
+                  <PowerConsoleSection className="slide00-power-console-section--actions">
+                    <FirstActionsRail
+                      title={t("slide00.firstActions.title")}
+                      subtitle={t("slide00.firstActions.subtitle")}
+                      actions={firstActions}
+                    />
+                  </PowerConsoleSection>
+                </>
               }
             />
-          }
-          side={
-            <BootSideColumn>
-              <BootStatusBadge
-                isArmed={boot.isArmed}
-                isOperatorAssisted={boot.isOperatorAssisted}
-                narrative={statusNarrative(boot.state.boot.status)}
-                lastEventLabel={lastEventLabel}
-              />
-
-              <OpeningFlagsBadge
-                summary={cinematicFlagSummary || "none"}
-                autostartReason={humanReason(boot.gates.tourAutostart.reason)}
-                warning={boot.gates.tourAutostart.reason === "autostart-disabled-by-boot-contract"}
-              />
-
-              <ViewControlsTogglePanel
-                showTopHudRow={viewVisibility.showTopHudRow}
-                showTopRibbon={viewVisibility.showTopRibbon}
-                showDiagnostics={viewVisibility.showDiagnostics}
-                onTopHudRowChange={viewVisibility.setShowTopHudRow}
-                onTopRibbonChange={viewVisibility.setShowTopRibbon}
-                onDiagnosticsChange={viewVisibility.setShowDiagnostics}
-              />
-
-              <PersistenceIndicator
-                persisted={persistence.hasSnapshot}
-                keyCount={persistence.keys.length}
-                keys={persistence.keys}
-              />
 
-              <ResetControls onSoftReset={softReset} onHardReset={hardReset} />
+            <EvidenceList
+              title={t("slide00.evidence.title")}
+              rows={blockerRows}
+              formatTimestamp={formatTimestamp}
+              metaLabel={t("slide00.evidence.meta")}
+              confirmedLabel={(time) => t("slide00.evidence.confirmed", { time })}
+              awaitingLabel={t("slide00.evidence.awaiting")}
+              satisfiedLabel={t("slide00.evidence.state.satisfied")}
+              missingLabel={t("slide00.evidence.state.missing")}
+              idleLabel={t("slide00.evidence.state.idle")}
+            />
 
-              <GateMatrix rows={gateRows} humanReason={humanReason} />
-            </BootSideColumn>
-          }
-        />
+            <BootFoot
+              left={t("slide00.foot.left", { time: formatDateTime(Date.now()) })}
+              right={t("slide00.foot.right", {
+                anchor: boot.diagnostics.lastInteractedAnchor ?? t("slide00.diagnostics.meta.none"),
+              })}
+            />
 
-        <EvidenceList title="evidence blockers" rows={blockerRows} formatTimestamp={formatTimestamp} />
+            <BootNote warning={boot.isOperatorAssisted}>
+              {t("slide00.note.override.start")} <strong>{t("slide00.note.override.armed")}</strong>
+              {t("slide00.note.override.end")}
+            </BootNote>
 
-        <BootFoot
-          left={`local time: ${formatDateTime(Date.now())}`}
-          right={`last anchor: ${boot.diagnostics.lastInteractedAnchor ?? "--"}`}
-        />
+            <BootNote danger={boot.gateLocked}>{t("slide00.note.locked")}</BootNote>
 
-        <BootNote warning={boot.isOperatorAssisted}>
-          override path can unlock progression for operator testing, but it never satisfies
-          <strong> evidence:system:armed</strong>.
-        </BootNote>
-
-        <BootNote danger={boot.gateLocked}>
-          when locked, WOW tour/demo-script/opening-cinema stay disabled regardless of flags.
-        </BootNote>
-
-        <Slide00HiddenState
-          bootStatus={boot.state.boot.status}
-          armedEvidence={
-            boot.state.evidence.entries["evidence:system:armed"].satisfied
-              ? "satisfied"
-              : "missing"
-          }
+            <Slide00HiddenState
+              bootStatus={boot.state.boot.status}
+              armedEvidence={
+                boot.state.evidence.entries["evidence:system:armed"].satisfied
+                  ? "satisfied"
+                  : "missing"
+              }
+            />
+          </Slide00Shell>
+        </PowerConsoleFrame>
+
+        <FitDiagnosticsOverlay
+          enabled={SHOW_FIT_DIAGNOSTICS}
+          preset={densityPreset.preset}
+          presetReason={densityPreset.reason}
+          metrics={viewportMetrics}
         />
-      </Slide00Shell>
+      </TokenBridge>
     </SlideContainer>
   );
 };
diff --git a/components/slides/slide00-ui/index.ts b/components/slides/slide00-ui/index.ts
index 70b5a1c..7423355 100644
--- a/components/slides/slide00-ui/index.ts
+++ b/components/slides/slide00-ui/index.ts
@@ -30,4 +30,10 @@ export * from "./TopHudRow";
 export * from "./TopRibbon";
 export * from "./ViewControlsTogglePanel";
 export * from "./slide00.helpers";
-export * from "./types";
+export * from "./types";
+export * from "./layout";
+export * from "./copy";
+export * from "./interactions";
+export * from "./first-proof";
+export * from "./tokens";
+export * from "./tokens/TokenBridge";
diff --git a/tests/unit/playwright-harness.unit.ts b/tests/unit/playwright-harness.unit.ts
index 377c7a6..e4e88c3 100644
--- a/tests/unit/playwright-harness.unit.ts
+++ b/tests/unit/playwright-harness.unit.ts
@@ -7,6 +7,7 @@ const allowedE2eSpecs = [
   'tests/e2e/demo.e2e.spec.ts',
   'tests/e2e/gemini-boundary.e2e.spec.ts',
   'tests/e2e/slide00-boot-gate.e2e.spec.ts',
+  'tests/e2e/slide00-firstproof.e2e.spec.ts',
 ] as const;
 
 function normalize(relPath: string): string {
diff --git a/tests/unit/run-all.ts b/tests/unit/run-all.ts
index dc919de..88fa340 100644
--- a/tests/unit/run-all.ts
+++ b/tests/unit/run-all.ts
@@ -5,12 +5,16 @@ import { runBootReducerSpecs } from './boot-reducer.unit';
 import { runBootWowGateSpecs } from './boot-wow-gate.unit';
 import { runGuideEngineSpecs } from './wow-guide-engine.unit';
 import { runGuideSchemaSpecs } from './wow-guide-schema.unit';
+import { runSlide00CopySpecs } from './slide00-copy.unit';
+import { runFirstProofHelperSpecs } from '../../components/slides/slide00-ui/first-proof/__tests__/firstProof.helpers.test';
 
 runBootReducerSpecs();
 runBootEvidenceSpecs();
 runBootWowGateSpecs();
 runGuideEngineSpecs();
 runGuideSchemaSpecs();
+runSlide00CopySpecs();
+runFirstProofHelperSpecs();
 runPlaywrightHarnessSpecs();
 runNoReworkGuardSpecs();
```

6) Command outputs (typecheck/build/test)
npm run typecheck
```txt
> copy-of-hitech-rts-a---deck-v32@0.0.0 typecheck
> tsc -p tsconfig.verify.json --noEmit
```
npm run build
```txt
> copy-of-hitech-rts-a---deck-v32@0.0.0 build
> node scripts/client-boundary-guard.mjs --strict && node scripts/no-rework-guard.mjs && vite build

[client-boundary] PASS no client exposure findings
[client-boundary] report=F:\OneDrive\Hitech\3.Proyectos\CHAT GPT AI Estudio\repos\Inversion\.run\client-boundary-guard.json
[no-rework] PASS
vite v6.4.1 building for production...
✓ 218 modules transformed.
✓ built in 2.46s
(!) Some chunks are larger than 500 kB after minification.
```
npm run test:unit
```txt
> copy-of-hitech-rts-a---deck-v32@0.0.0 test:unit
> tsx tests/unit/run-all.ts

[unit] PASS
```
npm run test:e2e -- --grep "Slide00" (optional)
```txt
> copy-of-hitech-rts-a---deck-v32@0.0.0 test:e2e
> playwright test --grep Slide00

Running 3 tests using 1 worker
ok 1 tests\e2e\slide00-boot-gate.e2e.spec.ts
ok 2 tests\e2e\slide00-boot-gate.e2e.spec.ts
ok 3 tests\e2e\slide00-firstproof.e2e.spec.ts
3 passed (21.7s)
```

7) Known risks / what not touched
- Known risk: Slide00.tsx was already heavily dirty before this iteration; scoped diff above isolates this block as best as possible.
- Known risk: right panel legacy modules are intentionally preserved but hidden behind TODO in this iteration.
- Explicit deletions outside new files in this iteration scope: file deletions = 0. Existing file line removals are limited to Slide00 wiring/index adjustments required for ritual integration.
- Not touched: runtime/boot semantics, runtime/evidence internals, providers wiring contracts, Slide01+ domains.
